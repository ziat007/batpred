{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Home battery prediction and automatic charging for Home Assistant supporting multiple inverters including: GivEnergy Hybrid, AC and AIO Solis Solax Sunsynk Huawei SolarEdge Fox Sofar LuxPower Solar Assistant Sigenergy Sigenstor Also known by some as Batpred or Batman! License Please see License Copyright (c) Trefor Southwell April 2025 - All rights reserved This software may be used at no cost for personal use only No warranty is given, either expressed or implied For support please raise a GitHub ticket or use the Facebook Group: Predbat and watch my YouTube Channel Some inverters have their own groups e.g.: GivTCP Solis If you want to buy me a beer then please use Paypal or Github sponsor Taster Once you are up and running you will get a chart that predicts your battery levels over time: You can also see this in a plan format predicting your overall costs and your carbon footprint (if enabled, UK only for now): You can see the cost over time for the plan that Predbat has made and also how it might turn out if your solar production (should you have solar) is lower than expected or if you use a bit more energy than planned (10% scenario): You can see your energy rates over time and where the battery is being charged: Power charts can show you how the prediction maps to your inverter: You can model iBoost or similar solar diverters, this will be shown on your plan and you can even use it to trigger smart devices e.g. an emersion heater based on energy rates. You can predict when your car will charge and use Predbat to schedule the cheapest car charging slots: Charts can track your cost savings using Predbat and from having a PV and Battery system The calibration chart is useful for tuning the model for things like inverter losses until it matches reality: Predbat can track your actual vs predicted energy usage and make real-time adjustments to the predictions if you use more or less: You can tune lots of parameters to match your system and needs: You can also override the plan temporarily if you have a particular reason to: Please read the documentation for more information!","title":"Introduction"},{"location":"#introduction","text":"Home battery prediction and automatic charging for Home Assistant supporting multiple inverters including: GivEnergy Hybrid, AC and AIO Solis Solax Sunsynk Huawei SolarEdge Fox Sofar LuxPower Solar Assistant Sigenergy Sigenstor Also known by some as Batpred or Batman!","title":"Introduction"},{"location":"#license","text":"Please see License Copyright (c) Trefor Southwell April 2025 - All rights reserved This software may be used at no cost for personal use only No warranty is given, either expressed or implied For support please raise a GitHub ticket or use the Facebook Group: Predbat and watch my YouTube Channel Some inverters have their own groups e.g.: GivTCP Solis If you want to buy me a beer then please use Paypal or Github sponsor","title":"License"},{"location":"#taster","text":"Once you are up and running you will get a chart that predicts your battery levels over time: You can also see this in a plan format predicting your overall costs and your carbon footprint (if enabled, UK only for now): You can see the cost over time for the plan that Predbat has made and also how it might turn out if your solar production (should you have solar) is lower than expected or if you use a bit more energy than planned (10% scenario): You can see your energy rates over time and where the battery is being charged: Power charts can show you how the prediction maps to your inverter: You can model iBoost or similar solar diverters, this will be shown on your plan and you can even use it to trigger smart devices e.g. an emersion heater based on energy rates. You can predict when your car will charge and use Predbat to schedule the cheapest car charging slots: Charts can track your cost savings using Predbat and from having a PV and Battery system The calibration chart is useful for tuning the model for things like inverter losses until it matches reality: Predbat can track your actual vs predicted energy usage and make real-time adjustments to the predictions if you use more or less: You can tune lots of parameters to match your system and needs: You can also override the plan temporarily if you have a particular reason to: Please read the documentation for more information!","title":"Taster"},{"location":"apps-yaml/","text":"apps.yaml settings The basic Predbat configuration is defined in the apps.yaml file. Depending on how you installed Predbat the apps.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat add-on installation method , apps.yaml will be in the directory /addon_configs/6adb4f0d_predbat , with the HACS, Appdaemon add-on then Predbat installation method , it's in /config/appdaemon/apps/batpred/config/ , or if the combined AppDaemon/Predbat add-on installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/apps . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-on's) to edit the apps.yaml file - see editing configuration files within Home Assistant if you need to install an editor. This section of the documentation describes what the different configuration items in apps.yaml do. When you edit apps.yaml , the change will automatically be detected and Predbat will be reloaded with the updated file. You don't need to restart the Predbat or AppDaemon add-on for your edits to take effect. Warning! apps.yaml file format When editing the apps.yaml file you must ensure that the file remains correctly formatted. YAML files are especially finicky about how the file contents are indented and it's very easy to end up with an incorrectly formatted file that will cause problems for Predbat. The YAML Basics from This Smart Home is a good introduction video to how YAML should be correctly structured but as a brief introduction: At the start of the apps.yaml is the predbat module definition: pred_bat: module: predbat class: PredBat YAML can be thought of as a tree structure with 'pred_bat' at the top of the tree and everything else, e.g. 'module' and 'class' being children of the pred_bat tree. Each child entry must be indented by two spaces under the parent it follows, so 'module' and 'class' are thus children of 'pred_bat'. The YAML file consists of configuration item, a colon, and then the configuration value, for example, timezone is a child configuration item under the over-arching 'pred_bat' parent: timezone: Europe/London If the configuration item is a list of values, each of the list values appears on a new line, indented by a further two spaces, a dash, and then the value. For example, car_charging_response is a child of 'pred_bat' and consists of two values, 'yes' and 'no': car_charging_now_response: - 'yes' - 'on' Child entries can have children of their own, so for example rates_import_override is a child of the overarching 'pred_bat', and it has children configuration items of its own being 'start', 'end' and 'rate': rates_import_override: - start: '13:00:00' end: '14:00:00' rate: 0 The indentation of children being two spaces indented from their parents and there being two spaces before the dash are especially critical. It's easy to mis-edit and have one or three spaces which isn't valid YAML. NB: the sequence of entries in apps.yaml doesn't matter, as long as the YAML itself is structured correctly you can move things and edit things anywhere in the file. Templates You can find template configurations in the following location: https://github.com/springfall2008/batpred/tree/main/templates The GivEnergy GivTCP template will be installed by default but if you are using another inverter please copy the correct template into the directory where your apps.yaml is stored, replacing the existing apps.yaml file, and modify it from there. Please read Inverter Setup for inverter control software and details of setting apps.yaml for non-GivEnergy inverters Checking your apps.yaml Syntax errors will be highlighted by the Home Assistant editor or via other YAML-aware editors such as VSCode. Once you have completed your apps.yaml and started Predbat you may want to open the Predbat Web Interface and click on 'apps.yaml'. Review any items shown in a red background as those do not match (it's okay for a 2nd inverter not to match if you only have one configured). Regular expressions that do not match can be ignored if you are not supporting that feature (e.g. Car SOC if you don't have a car). As an example these do not match and are shown in the web interface in red, I'm ignoring them as I only have one inverter and I'm using the Predbat internal Solcast rather than the external integration: Basics Basic configuration items prefix Set to the prefix name to be used for all entities that Predbat creates in Home Assistant. Default 'predbat'. Unlikely that you will need to change this. prefix: predbat timezone Set to your local timezone, the default is Europe/London. It must be set to a valid Python time zone for your location timezone: Europe/London currency_symbols Sets your symbol to use for your main currency e.g. \u00a3 or $ and for 1/100th unit e.g. p or c currency_symbols: - '\u00a3' - 'p' template Initially set to True, this is used to stop Predbat from operating until you have finished configuring your apps.yaml. Once you have made all other required changes to apps.yaml this line should be deleted or commented out: template: True Home Assistant connection Predbat can speak directly to Home Assistant rather than going via AppDaemon. If you are using a standard Predbat add-on then this will be automatic and you should normally not need to set this. If you find you get issues where Predbat cannot communicate with Home Assistant after running for a long period of time and you get web socket errors, then creating a HA access key as described below can resolve this. If you run Predbat in a Docker container then you will need to set the URL or IP address of Home Assistant and an access key. The access key is a long-lived security access token you can create inside Home Assistant: Click on your user initials (bottom left) in HA; Click the Security tab Scroll to the bottom of the security screen and under 'Long-lived Access tokens', click 'Create Token' then copy the generated access token into ha_key in apps.yaml Currently, if this communication is not established Predbat will fall back to AppDaemon, however, some users have experienced failures due to a 10-second timeout set by AppDaemon. In future versions of Predbat, AppDaemon will be removed. ha_url: 'http://homeassistant.local:8123' ha_key: 'xxxxxxxxxxx' TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This will remove the need for a DNS lookup of the IP address every time Predbat talks to Home Assistant and may improve reliability as a result. threads If defined sets the number of threads to use during plan calculation, the default is 'auto' which will use the same number of threads as you have CPUs in your system. Valid values are: 'auto' - Use the same number of threads as your CPU count '0' - Don't use threads - disabled 'N' - Use N threads, recommended values are between 2 and 8 threads: auto Web interface Docker users can change the web port for the Predbat web interface by setting web_port to a new port number. The default port of 5052 must always be used for the Predbat add-on. web_port: 5052 notify_devices A list of device names to notify when Predbat sends a notification. The default is just 'notify' which contacts all mobile devices notify_devices: - mobile_app_treforsiphone12_2 days_previous Predbat needs to know what your likely future house load will be to set and manage the battery level to support it. days_previous defines a list (which has to be entered as one entry per line) of the previous days of historical house load that are to be used to predict your future daily load. It's recommended that you set days_previous so Predbat calculates an average house load using sufficient days' history so that 'unusual' load activity (e.g. saving sessions, \"big washing day\", etc) get averaged out. For example, if you just want Predbat to assume the house load on a particular day is the same as the same day of last week: days_previous: - 7 Or if you want Predbat to take the average of the same day for the last two weeks: days_previous: - 7 - 14 Further details and worked examples of how days_previous works are covered at the end of this document. Do keep in mind that Home Assistant only keeps 10 days of history by default, so if you want to access more than this for Predbat you might need to increase the number of days of history kept in HA before it is purged by editing and adding the following to the /homeassistant/configuration.yaml configuration file and restarting Home Assistant afterwards: recorder: purge_keep_days: 14 days_previous_weight - A list (again with one entry per line) of weightings to be applied to each of the days in days_previous. For example, to apply a 100% weighting for the first-day entry in days_previous, but only a 50% weighting to the second day in days_previous: days_previous_weight: - 1 - 0.5 The default value is 1, and all history days are equally weighted, so if you don't want to weight individual days you can simply use: days_previous_weight: - 1 forecast_hours the number of hours that Predbat will forecast, 48 is the suggested amount, although other values can be used such as 30 or 36 if you have a small battery and thus don't need to forecast 2 days ahead. forecast_hours: 48 Inverter information The template apps.yaml for each inverter type comes pre-configured with regular expressions that should auto-discover the Home Assistant entity names for that inverter type. If you have more than one inverter or entity names are non-standard then you will need to edit apps.yaml for your inverter entities. Givenergy cloud direct Predbat now supports direct communication with the GivEnergy cloud services, with this method you can have your inverter auto-configured. Just log into the GivEnergy web site and create an API key and copy it into the key settings. The number of inverters and their settings will be configured automatically. If you set ge_cloud_automatic to False then you can manually configure to point to Predbat's GE Cloud configuration. If you set ge_cloud_data to False then Predbat will use the local data for history rather than the cloud data, you will need to wait until you have a few days work (at least days_previous days) before this will work correctly. ge_cloud_data: True ge_cloud_serial: '{geserial}' ge_cloud_key: 'xxxxx' ge_cloud_direct: True ge_cloud_automatic: True num_inverters The number of inverters you have. If you increase this above 1 you must provide multiple of each of the inverter entities num_inverters: 1 inverter_type inverter_type defaults to 'GE' (GivEnergy) if not set in apps.yaml, or should be set to one of the inverter types that are already pre-programmed into Predbat: GE: GivEnergy GEC: GivEnergy Cloud GEE: GivEnergy EMC GS: Ginlong Solis SE: SolarEdge SX4: Solax Gen4 (Modbus Power Control) SF: Sofar HYD SFMB: Sofar HYD with solarman modbus HU: Huawei Solar SK: Sunsynk SA: Solar Assistant If you have multiple inverters, then set inverter_type to a list of the inverter types. If you have created a custom inverter type in apps.yaml then inverter_type must be set to the same code as has been used in the custom inverter definition. geserial Only for GE inverters, this is a helper regular expression to find your inverter serial number, if it doesn't work edit it manually or change individual entities to match. If you have more than one GivEnergy inverter you will need one per inverter to be used in the later configuration lines. If you only have a single GivEnergy inverter then comment out all lines that refer to geserial2 in apps.yaml. geserial: 're:sensor.givtcp_(.+)_soc_kwh' geserial2: 're:sensor.givtcp2_(.+)_soc_kwh' If you are running GivTCP v3 and have an 'All-In-One' (AIO) or a 3-phase inverter then the helper regular expression will not correctly work and you will need to manually set geserial in apps.yaml to your inverter serial number, e.g.: geserial: 'chNNNNgZZZ' TIP: If you have a single GivEnergy AIO, all control is directly to the AIO and the gateway is not required. Check the GivTCP configuration to determine whether inverter 1 (the givtcp sensors) is the AIO or the gateway, or inverter 2 (the givtcp2 sensors) is the AIO or gateway. Then in apps.yaml comment out the lines corresponding to the gateway, leaving just the givtcp or givtcp2 lines for the AIO. Also, delete the appropriate givtcp_rest inverter control line corresponding to the gateway so that Predbat controls the AIO directly. TIP2: If you have multiple GivEnergy AIO's, all the AIO's are controlled by the AIO gateway and not controlled individually. geserial should be manually configured to be your AIO gateway serial number 'gwNNNNgZZZ' and all the geserial2 lines should be commented out in apps.yaml. You should also delete the second givtcp_rest inverter control line so that Predbat controls the AIOs via the gateway. GivTCP version 3 is required for multiple AIOs or a 3-phase inverter. Historical data Predbat can either get historical data (house load, import, export and PV generation) directly from GivTCP or it can obtain it from the GivEnergy cloud. Unless you have a specific reason to not use the GivTCP data (e.g. you've lost your GivTCP data), its recommended to use GivTCP. Data from Home Assistant The following configuration entries in apps.yaml are pre-configured to automatically use the appropriate sensors. If you have a 3-phase electricity supply and one inverter (and battery) on each phase then you will need to add one line for the load, import, export and PV sensors for each of the 3 phases. If you have a single-phase electricity supply and multiple inverters on the phase then you will need to add one line for each of the load and PV sensors. You don't need multiple lines for the import or export sensors as each inverter will give the total import or export information. Edit if necessary if you have non-standard sensor names: load_today - Entity name for the house load in kWh today (must be incrementing) import_today - Imported energy today in kWh (incrementing) export_today - Exported energy today in kWh (incrementing) pv_today - PV energy today in kWh (incrementing). If you have multiple inverters, enter each inverter PV sensor on a separate line. If you have an AC-coupled inverter then enter the Home Assistant sensor for your PV inverter. If you don't have any PV panels, comment or delete this line out of apps.yaml. See the Workarounds section below for configuration settings for scaling these if required. If you have multiple inverters then you may find that the load_today figures are incorrect as the inverters share the house load between them. In this circumstance, one solution is to create a Home Assistant template helper to calculate house load from {pv generation}+{battery discharge}-{battery charge}+{import}-{export}. The example below is defined in configuration.yaml (not the HA user interface) so it only updates every 5 minutes rather than on every underlying sensor state change: e.g. # Home consumption sensor, updated every 5 minutes instead of the default of every sensor state change template: - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Today\" unique_id: \"house_load_today\" unit_of_measurement: kWh state_class: total device_class: energy state: > {% set x=( states('sensor.givtcp_XXX_pv_energy_today_kwh')|float(0) + <inverter 2>... + states('sensor.givtcp_XXX_battery_discharge_energy_today_kwh')|float(0) + <inverter 2>... - states('sensor.givtcp_XXX_battery_charge_energy_today_kwh')|float(0) - <inverter 2>... + states('sensor.givtcp_XXX_import_energy_today_kwh')|float(0) - states('sensor.givtcp_XXX_export_energy_today_kwh')|float(0) ) %} {{ max(x,0)|round(1) }} GivEnergy Cloud Data If you have an issue with the GivTCP data, Predbat can get the required historical data from the GivEnergy cloud instead. This data is updated every 30 minutes. Connecting to the cloud is less efficient and means that Predbat will be dependent upon your internet connection and the GivEnergy cloud to operate. ge_cloud_data - When True Predbat will connect to the GivEnergy cloud rather than GivTCP sensors for historical load_today, import_today and export_today inverter data ge_cloud_serial - Set the inverter serial number to use for the cloud data ge_cloud_key - Set to your API Key for the GE Cloud (long string) If you need to create a ge_cloud_key, in the GivEnergy cloud portal: Click 'account settings' in the menu bar (icon of a person overlaid with a cogwheel) Click 'Manage Account Security' then 'Manage API Tokens' then 'Create API Token' Enter a name for the token e.g. 'Predbat' Select 'No expiry' for the token expiry duration, or choose a fixed duration but remember to create a new token before it expires as Predbat's access will stop once the token expires Ensure that 'api:inverter' is ticked Create token Finally, copy/paste the token created into ge_cloud_key within apps.yaml GivEnergy Cloud controls Experimental Predbat now supports GE Cloud controls directly from inside Predbat. When enabled Predbat will connect directly with the GE Cloud and expose the controls of your inverter inside home assistant. Note You will still have to configure apps.yaml to point to these controls. ge_cloud_direct - Set to True to enable GE Cloud direct access ge_cloud_key - Set to your API Key for the GE Cloud (long string) Load filtering By default, if Predbat sees a gap in the historical load data it will fill it with average data. This is to help in the cases of small amounts of lost data. For entire lost days you should change days_previous to point to different days(s) or include 3 or more days and if you set switch.predbat_load_filter_modal to true, the lowest day's historical load will be discarded. load_filter_threshold - Sets the number of minutes of zero load data to be considered a gap (that's filled with average data), the default is 30. To disable, set it to 1440. iBoost energy iboost_energy_today - Set to a sensor which tracks the amount of energy sent to your solar diverter, which can also be used to subtract from your historical load for more accurate predictions. Inverter control configurations inverter_limit One per inverter. Controls the way Predbat models your inverter, this does not change the way it is controlled. When set, it defines the maximum AC output power in watts for your inverter. This is used by Predbat in calculating the plan to emulate clipping that occurs in the inverter when your solar produces more than the inverter can handle, but it won't be that accurate as the source of the data isn't minute-by-minute. For a Hybrid inverter make sure the Hybrid Inverter toggle is on, you should set the inverter limit to be the maximum power of the inverter in Watts e.g. a 5kW inverter will have a limit of 5000. If you have a separate Micro Inverter for your PV then you should add its power to the inverter limit For an AC Coupled inverter make sure the Hybrid Inverter toggle is off and set this to the power of your AC Coupled inverter. Do not add on separate Micro Inverters to the total power. If you have multiple inverters then set the value of each one in a list format. NB: inverter_limit is ONLY used by Predbat to improve the quality of the plan, any solar clipping is done by the inverter and is not controlled by Predbat. export_limit One per inverter (optional). Controls the way Predbat models your inverter, this does not change the way it is controlled. When set defines the maximum watts of AC power your inverter can export to the grid at (e.g. 2500). This is used by Predbat in calculating the plan to emulate your inverter's software export limit setting that you will have if your G98/G99 approval was lower than your maximum inverter power (check your install information for details). If you do not set an export limit then it is assumed to be unlimited (and thus limited by your inverter or PV system). inverter_limit_charge and inverter_limit_discharge - One per inverter (optional) When set in Watts, overrides the maximum charge/discharge rate settings used when controlling the inverter. This can be used if you need Predbat to cap your inverter battery rate (e.g. charge overnight at a slower rate to reduce inverter/battery heating) as Predbat will normally configure all timed charges or discharges to be at the inverter's maximum rate. inverter_can_charge_during_export Global setting, defaults to True. Controls the way Predbat models your inverter, this does not change the way it is controlled. During a force export period if the generated solar exceeds the inverter limit or the export limit then the inverter will scale back the export rate. If this setting is True then the inverter can end up charging the battery from PV while still in Force Export mode. If this setting if False then the inverter will not charge the battery and the excess PV will be lost. Controlling the Inverter There are a few different ways to control your inverter: Home Assistant entity controls (standard) GivTCP REST Interface (GivEnergy Inverters only) Service API MQTT API Home Assistant entity inverter control Predbat can control inverters by updating Home Assistant entities. The template apps.yaml for is pre-configured with regular expressions for many configuration items, but some of them may need updating to match your system. If you only have a single inverter then the second inverter lines can be commented out if so desired or left in place (as they are ignored). The givtcp_rest line should be commented out/deleted on anything but GivTCP REST mode. Charge/Discharge rate charge_rate - Battery charge rate entity in watts discharge_rate - Battery discharge max rate entity in watts or charge_rate_percent - Battery charge rate entity in percent of maximum rate (0-100) discharge_rate_percent - Battery discharge max rate entity in percent of maximum rate (0-100) Battery Information battery_voltage - Current battery voltage (only needed for inverters controlled via amps) battery_rate_max - Sets the maximum battery charge/discharge rate in watts (e.g. 6000). For GivEnergy inverters this can be determined from the inverter, but must be set for non-GivEnergy inverters or Predbat will default to 2600W. soc_max - Entity name for the maximum charge level for the battery in kWh battery_min_soc - When set limits the target SOC% setting for charge and discharge to a minimum percentage value reserve - sensor name for the reserve setting in % battery_temperature - Defined the temperature of the battery in degrees C (default is 20 if not set) Power Data Note this are not required for normal operation, only to produce power flow data or for battery curve calculations. One entry per inverter: battery_power - Current battery power in W or kW Battery power should be positive for discharge and negative for charge, if your sensor is the other way around then set battery_power_invert to True pv_power - Current PV power in W or kW load_power - Current load power in W or kW grid_power - Current grid power in W or kW Grid power should be negative for import and positive for export, if your sensor is the other way around then set grid_power_invert to True e.g: battery_power: - sensor.givtcp_{geserial}_battery_power battery_power_invert: - False grid_power: - sensor.givtcp_{geserial}_grid_power grid_power_invert: - False pv_power: - sensor.givtcp_{geserial}_pv_power load_power: - sensor.givtcp_{geserial}_load_power Battery SoC soc_kw - Entity name of the battery SOC in kWh, should be the inverter one not an individual battery or soc_percent Entity name of the battery SOC in percent of the maximum battery size, should be the inverter one not an individual battery Inverter Info inverter_reserve_max - When set defines the maximum reserve setting in % (default is 100) inverter_mode - Givenergy inverter mode control inverter_time - Inverter timestamp, used to track the last update of the inverter data inverter_battery_rate_min - Defines the minimum discharge/charge rate of the battery in watts (default is 0) Schedule charge_start_time - Battery charge start time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_end_time - Battery charge end time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_limit - Entity name for used to set the SOC target for the battery in percentage (AC charge target) scheduled_charge_enable - Scheduled charge enable config scheduled_discharge_enable - Scheduled discharge enable config discharge_start_time - scheduled discharge slot_1 start time discharge_end_time - scheduled discharge slot_1 end time discharge_target_soc - Set the battery target percent for timed exports, will be written to minimum by Predbat. pause_mode - Givenergy pause mode register (if present) pause_start_time - scheduled pause start time (only if supported by your inverter) pause_end_time - scheduled pause start time (only if supported by your inverter) If you are using REST control the configuration items should still be kept as not all controls work with REST. TIP: Some older GivEnergy inverters such as the Gen 1 hybrid and AC3 inverter that have had firmware upgrades to introduce battery pause functionality do not have sufficient memory on the inverter to provide control of battery pause start and end times. GivTCP does not recognise this and so still provides the select.givtcp_xxxx_battery_pause_start_time_slot and end_time_slot controls, but they do not work. Predbat can report an error trying to set them, or they revert back to 00:00:00 after being changed by Predbat and there will also be errors setting these controls reported in the GivTCP log. For these inverters the pause_start_time and pause_end_time entries should be commented out in apps.yaml to stop Predbat trying to use them. See section below on creating the battery charge power curve . REST Interface inverter control For GivEnergy inverters Predbat can control the inverter directly via REST instead of via the Home Assistant GivTCP inverter controls detailed above. When configured in apps.yaml, control communication from Predbat to GivTCP is via REST which bypasses some issues with MQTT. givtcp_rest - One entry per Inverter, sets the GivTCP REST API URL ( http://homeassistant.local:6345 is the normal address and port for the first inverter, and the same address but ending :6346 if you have a second inverter - if you don't have a second inverter (or if you have multiple AIO's that are controlled through the gateway), delete the second line. If you are using Docker then change 'homeassistant.local' to the Docker IP address. TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This may improve reliability of the REST connection as it doesn't need to lookup the HA server IP address each time. To check your REST is working open up the readData API point in a Web browser e.g: http://homeassistant.local:6345/readData If you get a bunch of inverter information back then it's working! Note that Predbat will still retrieve inverter information via REST, this configuration only applies to how Predbat controls the inverter. Service API Some inverters have the Service API enabled, this allows the configuration to call an arbitrary Home Assistant service to start/stop charging and discharging charge_start_service - Should be set to a service that is called when charging starts charge_freeze_service - If your inverter supports charge freeze set to a service that starts this mode charge_stop_service - Should be set to a service that is called when charging/charge freeze stops discharge_start_service - Should be set to a service that is called when force export (discharge) starts discharge_freeze_service - If your inverter supports export freeze set to a service that starts this mode discharge_stop_service - Should be set to a service that is called when export/export freeze stops Services that are not configuration will not be called. Example service is below: charge_start_service: service: switch.turn_off entity_id: \"switch.sunsynk_inverter_use_timer\" See Service API for details. Note that device_id will be passed to the service automatically, it can be set in apps.yaml. MQTT API Some Inverters are enabled with an MQTT API, in this case certain MQTT messages are send via the HA MQTT service. The mqtt_topic in apps.yaml set in the root of the MQTT topic (shown as topic below). Set reserve Called when the reserve (discharge-to %) is changed topic: topic /set/reserve payload: reserve Set target soc Called when the target (charge-to %) SoC is changed topic: topic /set/target_soc payload: soc Set charge rate Called to change the charge rate in Watts topic: topic /set/charge_rate payload: charge_rate Set discharge rate Called to change the discharge rate in Watts topic: topic /set/discharge_rate payload: discharge_rate Set charge Called when a charge is started topic: topic /set/charge payload: charge_rate Set discharge Called when a forced export (discharge) is started topic: topic /set/discharge payload: discharge_rate Set auto Called when a charge/discharge is cancelled and the inverter goes back to home demand mode. topic: topic /set/auto payload: true Solcast Solar Forecast As described in the Predbat installation instructions , Predbat needs a solar forecast in order to predict solar generation and battery charging which can be provided by the Solcast integration. By default, the template apps.yaml is pre-configured to use the Solcast forecast integration for Home Assistant. The apps.yaml contains regular expressions for the following configuration items that should auto-discover the Solcast forecast entity names. They are unlikely to need changing although a few people have reported their entity names don't contain 'solcast' so worth checking, or editing if you have non-standard names: pv_forecast_today - Entity name for today's Solcast forecast pv_forecast_tomorrow - Entity name for tomorrow's Solcast's forecast pv_forecast_d3 - Entity name for Solcast's forecast for the day after tomorrow pv_forecast_d4 - Entity name for Solcast's forecast for two days after tomorrow Sensors for d5, d6 & d7 are supported, but not that useful so are not pre-defined in the template. If you do not have a PV array then comment out or delete these Solcast lines from apps.yaml . Alternatively, Predbat can obtain the solar forecast directly from Solcast and the Solcast integration is thus not required. Uncomment the following Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 Note that by default the Solcast API will be used to download all sites (up to 2 for hobby accounts), if you want to override this set your sites manually using solcast_sites as an array of site IDs: solcast_sites: - 'xxxx' If you have more than 2 array orientations and thus more than one Solcast API key, enter each key in a list: solcast_api_key: - xxxx_API_key_1 - yyyy_API_key_2 Keep in mind hobbyist accounts only have 10 polls per day so you need to ensure that the solcast_poll_hours refresh period is set so that you do not exceed the 10 poll limit. If you have two arrays then each Solcast refresh will consume 2 polls so its suggested that you set solcast_poll_hours to 4.8 to maximise your polls over a 24 hour period (5 polls a day, 24/5=poll every 4.8 hours). If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. If you use the same Solcast account for other automations the poll frequency will need to be reduced to ensure the total polls is kept under your account daily poll limit or you will experience failures. If you have multiple PV arrays connected to hybrid inverters or you have AC-coupled inverters, then ensure your PV configuration in Solcast covers all arrays. If however, you have a mixed PV array setup with some PV that does not feed into the inverters that Predbat is managing (e.g. hybrid GE inverters with older firmware but a separate older FIT array that directly feeds AC into the house), then it's recommended that Solcast is only configured for the PV connected to the inverters that Predbat is managing. NB: Gen2, Gen3 and Gen1 hybrid inverters with the 'fast performance' firmware can charge their batteries from excess AC that would be exported, so for these inverters, you should configure Solcast with your total solar generation capability. Solcast produces 3 forecasted PV estimates, the 'central' (50% or most likely to occur) PV forecast, the '10%' (1 in 10 more cloud coverage 'worst case') PV forecast, and the '90%' (1 in 10 less cloud coverage 'best case') PV forecast. By default, Predbat will use the central (PV50) estimate and apply to it the input_number.predbat_pv_metric10_weight weighting of the 10% (worst case) estimate. You can thus adjust the metric10_weight to be more pessimistic about the solar forecast. Predbat models cloud coverage by using the difference between the PV and PV10 forecasts to work out a cloud factor, this modulates the PV output predictions up and down over the 30-minute slot as if there were passing clouds. This can have an impact on planning, especially for things like freeze charging which could assume the PV will cover the house load but it might not due to clouds. pv_estimate in apps.yaml can be used to configure Predbat to always use the 10% forecast by setting the configuration item to '10', or '90' to always use the 90% PV estimate (not recommended!). Set to blank or delete / comment out the line to use the default central estimate. If pv_estimate is set to 10 then input_number.predbat_pv_metric10_weight in Home Assistant should be set to 1.0. See also PV configuration options in Home Assistant . Forecast.solar Solar Forecast The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality. Energy Rates There are a number of configuration items in apps.yaml for telling Predbat what your import and export rates are. These are described in detail in Energy Rates and are listed here just for completeness: metric_octopus_import - Import rates from the Octopus Energy integration metric_octopus_export - Export rates from the Octopus Energy integration metric_octopus_gas - Gas rates from the Octopus Energy integration octopus_intelligent_slot - Octopus Intelligent GO slot sensor from the Octopus Energy integration octopus_saving_session - Energy saving sessions sensor from the Octopus Energy integration octopus_saving_session_octopoints_per_penny - Sets the Octopoints per pence rates_import_octopus_url - Octopus pricing URL (over-rides metric_octopus_import) rates_export_octopus_url - Octopus export pricing URL (over-rides metric_octopus_export) metric_standing_charge - Standing charge in pounds rates_import - Import rates over a 24-hour period with start and end times rates_export - Export rates over a 24-hour period with start and end times rates_gas - Gas rates over a 24-hour period with start and end times rates_import_override - Over-ride import rate for specific date and time range, e.g. Octopus Power-up events rates_export_override - Over-ride export rate for specific date and time range futurerate_url - URL of future energy market prices for Agile users futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on market prices or not futurerate_peak_start and futurerate_peak_end - start/end times for peak-rate adjustment carbon_intensity - Carbon intensity of the grid in half-hour slots from an integration. Energy Comparison You can configure in apps.yaml a compare_list section to define a list of Energy tariffs for Predbat to compare based on your predicted load and solar generation. See the Predbat Compare feature for details of how to define the tariffs to be compared. Car Charging Integration Predbat can include electric vehicle charging in its plan and manage the battery activity so that the battery isn't discharged into your car when the car is charging (although you can override this if you wish by setting the switch.predbat_car_charging_from_battery to True in Home Assistant). There are two different ways of planning car charging into cheap slots with Predbat, either by the Octopus Energy integration or by Predbat identifying the cheapest slots. These approaches and the set of settings that need to be configured together are described in Car Charging . The full list of car charging configuration items in apps.yaml that are used to plan car charging activity within Predbat are described below. The Home Assistant controls (switches, input numbers, selectors, etc) related to car charging are described in Car Charging configuration within Home Assistant , with a brief mention of pertinent controls included here alongside the apps.yaml configuration items where relevant for context. num_cars should be set in apps.yaml to the number of cars you want Predbat to plan for. Set to 0 if you don't have an EV (and the remaining car sensors in apps.yaml can safely be commented out or deleted as they won't be required). NB: num_cars must be set correctly regardless of whether you are using Octopus Intelligent Go to control your EV charging or Predbat to control the charging; or else Predbat could start discharging your battery when the EV is charging. car_charging_exclusive should be set to True for each car in apps.yaml if you have multiple cars configured in Predbat, but only one car charger. This indicates that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False for each car then it is assumed that the car can charge independently, and hence two or more cars could charge at once. One entry per car. car_charging_exclusive: - True - True Car Charging Filtering Depending upon how the CT clamps and your inverter and electric car charger have been wired, your inverter may 'see' your EV charging as being part of the house load. This means your house load is artificially raised whenever you charge your car. In this circumstance you might want to remove your electric car charging data from the historical house load data so as to not bias the calculations, otherwise you will get high battery charge levels when the car was charged previously (e.g. last week). TIP: Check the house load being reported by your inverter when your car is charging. If it doesn't include the car charging load then there is no need to follow these steps below (and if you do, you'll artificially deflate your house load). switch.predbat_car_charging_hold - A Home Assistant switch that when turned on (True) tells Predbat to remove car charging data from your historical house load so that Predbat's battery prediction plan is not distorted by previous car charging. car_charging_energy - Set in apps.yaml to point to a Home Assistant entity which is the daily incrementing kWh data for the car charger. This has been pre-defined as a regular expression that should auto-detect the appropriate Wallbox and Zappi car charger sensors, or edit as necessary in apps.yaml for your charger sensor. Note that this must be configured to point to an 'energy today' sensor in kWh not an instantaneous power sensor (in kW) from the car charger. IMPORTANT: If car_charging_energy is not configured with the correct sensor or your car charging energy sensor does not accurately report your car charging data (e.g. it falsely reports charging data when not actually charging), this will really mess up your predbat plan as Predbat will exclude all car_charging_energy from your load predictions. Do check the entity! TIP: You can also use car_charging_energy to remove other house load kWh from the data Predbat uses for the forecast, e.g. if you want to remove Mixergy hot water tank heating data from the forecast such as if you sometimes heat on gas, and sometimes electric depending upon import rates. car_charging_energy can be set to a list of energy sensors, one per line if you have multiple EV car chargers, or want to exclude multiple loads, e.g.: car_charging_energy: - 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)' - sensor.mixergy_ID_energy input_number.predbat_car_charging_energy_scale - A Home Assistant entity used to define a scaling factor (in the range of 0 to 1.0) to multiply the car_charging_energy sensor data by if required (e.g. set to 0.001 to convert Watts to kW). If you do not have a suitable car charging energy kWh sensor in Home Assistant then comment the car_charging_energy line out of apps.yaml and configure the following Home Assistant entity: input_number.predbat_car_charging_threshold (default 6 = 6kW)- Sets the kW power threshold above which home consumption is assumed to be car charging and input_number.predbat_car_charging_rate will be subtracted from the historical load data. Planned Car Charging These features allow Predbat to know when you plan to charge your car. If you have an Intelligent Octopus tariff then planning of charging is done via the Octopus app and Predbat obtains this information through the Octopus Energy integration in Home Assistant. switch.predbat_octopus_intelligent_charging - When this Home Assistant switch is enabled, Predbat will plan charging around the Intelligent Octopus slots, taking it into account for battery load and generating the slot information The following apps.yaml configuration items are pre-defined with regular expressions to point to appropriate sensors in the Octopus Energy integration. You should not normally need to change these if you have the Octopus Intelligent tariff: octopus_intelligent_slot - Points to the Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot, and provides the list of future planned charging activity. octopus_ready_time - Points to the Octopus Energy integration sensor that details when the car charging will be completed. Note: the Octopus Integration now provides Octopus Intelligent target time in two formats, either a 'select' entity or a 'time' entity. Predbat uses the time entity (time.octopus_energy_{{ACCOUNT_ID}}_intelligent_target_time) which is disabled by default, so you will need to enable the time entity and disable the matching select entity. octopus_charge_limit - Points to the Octopus Energy integration sensor that provides the car charging limit. octopus_slot_low_rate - Default is True, meaning any Octopus Intelligent Slot reported will be at the lowest rate if at home. If False the existing rates only will be used which is only suitable for tariffs other than IOG. If you don't use Intelligent Octopus then the above 3 Octopus Intelligent configuration lines in apps.yaml can be commented out or deleted, and there are a number of other apps.yaml configuration items that should be set: car_charging_planned - Optional, can be set to a Home Assistant sensor (e.g. from your car charger integration) which lets Predbat know the car is plugged in and planned to charge during low-rate slots. Or manually set it to 'False' to disable this feature, or 'True' to always enable it. The apps.yaml template supplied with Predbat comes pre-configured with a regular expression that should automatically match Zappi or Wallbox car chargers. If you have a different type of charger you will need to configure it manually. car_charging_planned_response - An array of values for the above car_charging_planned sensor which indicate that the car is plugged in and will charge in the next low rate slot. The template apps.yaml comes with a set of pre-defined sensor values that should match most EV chargers. Customise for your car charger sensor if it sets sensor values that are not in the list. car_charging_now - For some cases finding details of planned car charging is difficult. The car_charging_now configuration item can be set to point to a Home Assistant sensor that tells you that the car is currently charging. Predbat will then assume this 30-minute slot is used for charging regardless of the plan. If Octopus Intelligent Charging is enabled and car_charging_now indicates the car is charging then Predbat will also assume that this is a low rate slot for the car/house (and might therefore start charging the battery), otherwise electricity import rates are taken from the normal rate data. WARNING: Some cars will briefly start charging as soon as they are plugged in, which Predbat will detect and assume that this is a low rate slot even when it isn't. It is therefore recommended that you do NOT set car_charging_now unless you have problems with the Octopus Intelligent slots, and car_charging_now should be commented out in apps.yaml . CAUTION: Do not use car_charging_now with Predbat led charging or you will create an infinite loop. Do you use car_charging_now with Octopus intelligent unless you can't make it work any other way as it will assume all car charging is at a low rate. car_charging_now_response - Set to the range of positive responses for car_charging_now to indicate that the car is charging. Useful if you have a sensor for your car charger that isn't binary. To make planned car charging more accurate, configure the following items in apps.yaml : car_charging_battery_size - Set this value in apps.yaml to the car's battery size in kWh which must be entered with one decimal place, e.g. 50.0. If not set, Predbat defaults to 100.0kWh. This will be used to predict when to stop car charging. car_charging_limit - You should configure this to point to a sensor that specifies the % limit the car is set to charge to. This could be a sensor on the EV charger integration or a Home Assistant helper entity you can set as you wish. If you don't specify a sensor Predbat will default to 100% - i.e. fill the car to full. car_charging_soc - You should configure this to point to a sensor (on the HA integration for your EV charger) that specifies the car's current charge level expressed as a percentage - it must NOT be set to a sensor that gives the car's current kWh value as this will cause Predbat to charge the car to an incorrect level. If you don't specify a sensor, Predbat will default to 0%. If you have multiple electric cars then car_charging_soc should be set to a list of sensors, e.g.: car_charging_soc: - 'sensor.tsunami_battery' - 'sensor.toyota_XXX_battery_level' Multiple Electric Cars Multiple cars can be planned with Predbat, in which case you should set num_cars in apps.yaml to the number of cars you want to plan. car_charging_limit , car_charging_planned , car_charging_battery_size and car_charging_soc must then be a list of values (i.e. 2 entries for 2 cars) If you have Intelligent Octopus then Car 0 will be managed by the Octopus Energy integration, if it's enabled Each car will have its own Home Assistant slot sensor created e.g. binary_sensor.predbat_car_charging_slot_1 , SoC planning sensor e.g predbat.car_soc_1 and predbat.car_soc_best_1 for car 1 Watch List - automatically start Predbat execution By default Predbat will run automatically every 5 minute and to execute the plan, and re-evaluate the plan automatically every 10 minutes. You can manually force Predbat to start executing by turning switch.predbat_active on - see Predbat's output data . Additionally Predbat can 'watch' a number of Home Assistant entities and if one of those changes, Predbat will automatically start executing. This can be useful for EV owners such as to detect when you have plugged the EV in (for Predbat to stop the battery discharging), and with Intelligent Octopus Go if Octopus gives you additional charge slots. In apps.yaml , uncomment (or add) the following lines, customising to the list of configuration items you have setup in apps.yaml and want Predbat to watch for changes for: watch_list: - '{octopus_intelligent_slot}' - '{octopus_ready_time}' - '{octopus_charge_limit}' - '{octopus_saving_session}' - '+[car_charging_planned]' - '+[car_charging_soc]' - '{car_charging_now}' Note the notation for watch_list, a single value apps.yaml configuration item such as octopus_intelligent_slot is surrounded by curly bracket parenthesis {}, but for apps.yaml configuration items that can be a list such as car_charging_soc they are surrounded by +[ and ]. Load Forecast In addition to the historical house load data that Predbat uses by default, you can optionally provide a forecast of future load such as is produced by Predheat for Hot water and Heat Pump heating systems or via Predai load_forecast - this should be configured to point to a sensor and attribute. The attribute must be in either The format of 'last_updated' timestamp and 'energy' in incrementing kWh. The format of a dictionary of timestamps and energy data in incremental KWh. For example: Or apps.yaml should be configured to point to the forecast sensor and attribute (in the above formats) like this: load_forecast: - sensor_name$attribute_name So if using Predheat it would be configured as: load_forecast: - predheat.heat_energy$external Set load_forecast_only to True if you do not wish to use the Predbat forecast but instead want to use this as your only forecast data e.g using PredAi: load_forecast_only: True load_forecast: - sensor.givtcp_{geserial}_load_energy_today_kwh_prediction$results Balance Inverters When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. Most of the Predbat configuration for balancing inverters is through a number of Home Assistant controls for Balancing Inverters , but there is one configuration item in apps.yaml : balance_inverters_seconds: seconds Defines how often to run the inverter balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Workarounds There are a number of different configuration items in apps.yaml that can be used to tweak the way Predbat operates and workaround weirdness you may have from your inverter and battery setup. Base load Sometimes the load predictions can yield near zero data due to inaccuracy of data (e.g. a second PV system not tracked, car data being unreliable, poor sensors). In order to not get unrealistically low values you can set a base load value (in watts) which Predbat will use as a minimum load for a 30-minute period. To set a base load set base_load as an integer value in watts. base_load: 300 The above example load forecasts will now not fall below 300 watts which would be 0.15 kWh in a 30-minute period. Clock skew clock_skew: minutes Skews the local (computer) time that Predbat uses (from the computer that Predbat is running on). Set to 1 means add a minute to the Predbat computer time, set to -1 means take a minute off the Predbat computer time. This clock adjustment will be used by Predbat when real-time actions happen e.g. triggering a charge or discharge. If your inverter's time is different to the time on the computer running Home Assistant, you may need to skew the time settings made on the inverter when you trigger charging or discharging. Again 1 means the inverter is 1 minute fast and -1 means the inverter is 1 minute slow. Separate start and end options are applied to the start and end time windows, mostly as you want to start battery activity late (not early) and finish early (not late). You can adjust the charge and discharge times written to the inverter by setting the following in apps.yaml : inverter_clock_skew_start: minutes inverter_clock_skew_end: minutes Skews the setting of the charge slot registers vs the predicted start time inverter_clock_skew_discharge_start: minutes inverter_clock_skew_discharge_end: minutes Skews the setting of the discharge slot registers vs the predicted start time Battery size scaling battery_scaling: - scale Default value 1.0. Multiple battery size scales can be entered, one per inverter on separate lines. This setting is used to scale the battery-reported SoC kWh to make it appear bigger or larger than it is. As the GivEnergy inverters treat all batteries attached to an inverter as in effect one giant battery, if you have multiple batteries on an inverter that need scaling you should enter a composite scaling value for all batteries attached to the inverter. TIP: If you have a GivEnergy 2.6 or 5.2kWh battery then it will have an 80% depth of discharge but it will falsely report its capacity as being the 100% size, so set battery_scaling to 0.8 to report the correct usable capacity figure to Predbat. TIP: Likewise, if you have one or multiple GivEnergy All-in-Ones (AIOs), it will incorrectly report the 13.5kWh usable capacity of each AIO as 15.9kWh, so set battery_scaling to 0.85 to correct this. If you are going to chart your battery SoC in Home Assistant then you may want to use predbat.soc_kw_h0 as your current SoC (as this will be scaled) rather than the usual givtcp_SERIAL_NUMBER_soc GivTCP entity so everything lines up. Import export scaling import_export_scaling: scale Default value 1.0. Used to scale the import & export kWh data from GivTCP if the inverter information is incorrect. Inverter rate minimum inverter_battery_rate_min: watts One per inverter (optional), set in Watts, when set models a \"bug\" in the inverter firmware in some models where if charge or discharge rates are set to 0 you actually get a small amount of charge or discharge. The recommended setting is 200 for Gen 1 hybrids with this issue. Inverter reserve maximum inverter_reserve_max: percent Global, sets the maximum reserve % that may be set to the inverter, the default is 98, as some Gen 2 & Gen 3 inverters and AIO firmware versions refuse to be set to 100. Comment the line out or set it to 100 if your inverter allows setting it to 100%. Automatic restarts If the add-on that is providing the inverter control stops functioning it can prevent Predbat from functioning correctly. In this case, you can tell Predbat how to restart the add-on using a service. Right now only communication loss with GE inverters is detectable but in the future other systems will be supported. When enabled if communication is lost then the service configured will be triggered and can cause a restart which may restart the connection. This may be useful with GivTCP if you have time sync errors or lose the REST service every now and again. The auto_restart itself is a list of commands to run to trigger a restart. The shell command will call a 'sh' shell and can be used to delete files and suchlike. The service command is used to call a service and can contain arguments of addon and/or entity_id . The configuration below is for GivTCP v3. auto_restart: - shell: 'rm -rf /homeassistant/GivTCP/*.pkl' - service: hassio/addon_restart addon: 533ea71a_givtcp NB: If you are running GivTCP v2 then the line '533ea71a_givtcp' must be replaced with 'a6a2857d_givtcp' as the slug-id (Home Assistant add-on identifier) is different between GivTCP v2 and v3. Battery charge/discharge curves Some batteries tail off their charge rate at high SoC% or their discharge rate at low SoC%, and these optional configuration items enable you to model this tail-off in Predbat. Note that the charge/discharge curves only affect the accuracy of the charging/discharging model Predbat applies in the forward battery plan, Predbat will still instruct the inverter to charge/discharge at full rate regardless of the charging curve. If you know the battery charge or discharge curves (e.g. manufacturer info or your own testing) then you can manually configure this in apps.yaml, or Predbat can calculate the curves based on historical inverter charging/discharging data in Home Assistant. If the battery has not recently been fully charged or fully discharged then Predbat will not be able to calculate the curves and you'll get a warning in the logfile. battery_charge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in charging at high SoC%. Enter the charging curve as a series of steps of % of max charge rate for each SoC percentage. The default is 1.0 (full power) charge to 100%. Modelling the charge curve becomes important if you have limited charging slots (e.g. only a few hours a night) or you wish to make accurate use of the low power charging mode ( switch.predbat_set_charge_low_power ). If the battery_charge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon add-on, or an edit being made to apps.yaml), then Predbat will automatically calculate the charging curve for you from historical battery charging information. You should look at the Predbat logfile to find the predicted battery charging curve and copy/paste it into your apps.yaml file. The logfile will also include a recommendation for how to set your battery_rate_max_scaling setting in HA. The YouTube video charging curve and low power charging explains how the curve works and shows how Predbat automatically creates it. Setting this option to auto will cause the computed curve to be stored and used automatically. This is not recommended if you use low power charging mode as your history will eventually not contain any full power charging data to compute the curve, so in this case it's best to manually configure the charge curve in apps.yaml. NB: For Predbat to calculate your charging curve it needs to have access to historical Home Assistant data for battery_charge_rate, battery_power and soc_kw. These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. If you have a GivEnergy inverter and are using the recommended default REST mode to control your inverter then you will need to uncomment out the following entries in apps.yaml : charge_rate: - number.givtcp_{geserial}_battery_charge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh Example charging curve from a GivEnergy 9.5kWh battery with the latest firmware and Gen 1 inverter: battery_charge_power_curve: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in discharging at low SoC%. Enter the discharging curve as a series of steps of % of max discharge rate for each SoC percentage. The default is 1.0 (full power) discharge to 0%. If the battery_discharge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon add-on, or an edit being made to apps.yaml), then Predbat will automatically calculate the discharging curve for you from historical battery discharging information. You should look at the Predbat logfile to find the predicted battery discharging curve and copy/paste it into your apps.yaml file. Setting This option to auto will cause the computed curve to be stored and used automatically. This may not work very well if you don't do regular discharges to empty the battery. In the same way, as for the battery charge curve above, Predbat needs to have access to historical Home Assistant data for battery_discharge_rate, battery_power and soc_kw. These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. If you are using REST mode to control your GivEnergy inverter then the following entries in apps.yaml will need to be uncommented : discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh Battery temperature curves Your battery's maximum charge and discharge rate can be impacted by cold weather, Predbat can predict this if you provide a temperature sensor and define a curve. You must make sure battery_temperature is defined (one per inverter). Set battery_temperature_history to a sensor with history, this will be used to predict future temperatures based on past changes Set battery_temperature_charge_curve to define the maximum charge rate in C which is a percentage of your battery capacity. Set battery_temperature_discharge_curve to define the maximum discharge rate in C which is a percentage of your battery capacity. An example for GivEnergy Gen2 battery is below. Note You must adjust the curve for your system. gaps in the curve above 20 will use 20 degrees, and gaps below 0 will use 0 degrees. Do not leave gaps in the curve between 20 and 0. # Battery temperature charge adjustment curve # Specific in C which is a multiple of the battery capacity # e.g. 0.33 C is 33% of the battery capacity # values unspecified will be assumed to be 1.0 hence rate is capped by the max charge rate battery_temperature_history: sensor.givtcp_battery_stack_1_bms_temperature battery_temperature_charge_curve: 20: 0.50 19: 0.33 18: 0.33 17: 0.33 16: 0.33 15: 0.33 14: 0.33 13: 0.33 12: 0.33 11: 0.33 10: 0.25 9: 0.25 8: 0.25 7: 0.25 6: 0.25 5: 0.25 4: 0.25 3: 0.25 2: 0.25 1: 0.15 0: 0.00 Alert System Predbat can take data directly from the Meteo-Alarm feed and use it to trigger keeping your battery charged so you have power in the event of a power cut. Please look at their web site for more details. The apps.yaml must be configured to select the URL for your country. The event severity and certainty are all regular expressions and can be set to one or multiple values using regular expression syntax. Any unset values are ignored. Your location (from Home Assistant) is used to filter alerts that apply only to your area. Events that match the given criteria will try to keep your battery at the percentage level specified by keep (default 100%) during the entire event period. This works by using a much stronger version of best_soc_keep but only for that time period. Your Predbat status will also have [Alert] in it during the alert time period and the triangle alert symbol will show on your HTML plan for the time period of the alert. # Alert feeds - customise to your country, the alert types, severity and keep value # Customise to your needs, delete the ones you don't want to trigger on - e.g. remove Amber, Moderate and Possible. alerts: url: \"https://feeds.meteoalarm.org/feeds/meteoalarm-legacy-atom-united-kingdom\" event: \"(Amber|Yellow|Orange|Red).*(Wind|Snow|Fog|Rain|Thunderstorm|Avalanche|Frost|Heat|Coastal event|Flood|Forestfire|Ice|Low temperature|Storm|Tornado|Tsunami|Volcano|Wildfire)\" severity: \"Moderate|Severe|Extreme\" certainty: \"Possible|Likely|Expected\" keep: 40 Triggers export_triggers - The export trigger feature is useful to help trigger your own automation based on Predbat predicting in the plan that you will have spare solar energy that would be exported - this could happen if the battery is full or there is more predicted solar generation than can be charged into the battery. You can use the trigger in an automation, for example, you could turn on an immersion heater or the washing machine to consume the excess solar power. The triggers count export energy until the next active charge slot only. For each trigger give a name, the minutes of export needed, and the energy required in that time. Multiple triggers can be enabled by Predbat at once so in total you could use too much energy if multiple triggered automations all run. Each trigger specified in apps.yaml will create a Home Assistant entity called 'binary_sensor.predbat_export_trigger_ name ' which will be turned on when the predicted trigger conditions are valid. Connect this binary sensor to your automation to start whatever you want to trigger. Set the name for each trigger, the number of minutes of solar export you need, and the amount of energy in kWh you will need available during that period in apps.yaml: For example: export_triggers: - name: \"large\" minutes: 60 energy: 1.0 - name: \"small\" minutes: 15 energy: 0.25 Note: Predbat will set an export trigger to True if in the plan it predicts that there will be more than the specified amount of excess solar energy over the specified time. In the example above, the 'large' trigger will be set to True for the 1-hour period where Predbat predicts that there will be a total of 1kWh of excess solar generation over that period . For clarity the trigger is not set based on actual excess solar generation or export. It should also be recognised that this prediction could be wrong; there could be less solar generation or more house load than was predicted in the plan. If you wish to trigger activities based on Predbat charging or discharging the battery rather than spare solar energy you can instead use the following binary sensors in Home Assistant: binary_sensor.predbat_charging - Will be True when the home battery is inside a charge slot (either being charged or being held at a level). Note that this does include charge freeze slots where the discharge rate is set to zero without charging the battery. binary_sensor.predbat_exporting - Will be True when the home battery is inside a force discharge slot. This does not include discharge freeze slots where the charge rate is set to zero to export excess solar only. Understanding how days_previous works As described earlier, days_previous is a list of the previous days of historical house load that are averaged together to predict your future daily load. e.g., if you want the average of the same day for the last 2 weeks: days_previous: - 7 - 14 This section describes in more detail how days_previous is used by Predbat in creating the future battery plan, and gives some worked examples and a 'gotcha' to be aware of. When Predbat forecasts future home demand it counts backwards the days_previous number of days to find the appropriate historical home consumption. This is best explained through a worked example: In this example, days_previous is set to use history from 2 days ago: days_previous: - 2 If right now today it's Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 2 days from Tuesday so will use the historical home consumption from Sunday 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 2 days from that day, so will use historical home consumption from Monday 9am as being the Wednesday 9am prediction. This pattern of counting backwards days_previous days to find the appropriate time slot to load historical home consumption from requires Predbat to operate some additional special processing if days_previous is set to a low value or forecast_hours to a high value. Extending the previous example but this time days_previous is set to use history from just the previous day: days_previous: - 1 Today it's still Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 1 day from Tuesday so will use the historical home consumption from today's (Monday) 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 1 day from that day, so looks for historical home consumption from Tuesday 9am as being the Wednesday 9am prediction, but of course, it's still Monday, and Tuesday hasn't happened yet so we can't know what that historical consumption was! What Predbat does in this circumstance is to subtract a further day from days_previous and for Wednesday 9am's prediction, it will therefore use the historical load from Monday 9am. This issue of finding future historical load only occurs when days_previous is set to 1 and Predbat is forecasting more than 24 hours from 'now'. So to highlight this with some edge cases, today is still Monday 3:15pm, days_previous is still set to '1' and in the forward plan: For tomorrow's (Tuesday) 2:30pm slot, Predbat looks backwards 1 day from Tuesday and takes the historical home consumption from today's (Monday) 2:30pm slot. For tomorrow's (Tuesday) 3:00pm slot, Predbat looks backwards 1 day and takes the historical load from today's (Monday) 3:00pm slot - which we are only part way through so only 15 minutes of load will be predicted for tomorrow 3pm. For tomorrow's (Tuesday) 3:30pm slot, Predbat looks backwards 1 day but the 3:30pm slot today hasn't yet occurred so Predbat will take the historical load from the prior day and has to use Sunday's 3:30pm load for tomorrow's prediction. Ditto the predicted load for tomorrow's (Tuesday) 4:00pm slot comes from Sunday 4pm. As today rolls forward and Predbat keeps on updating the forward plan every 5 minutes the prediction will be updated with the correct previous_day history as and when it exists. It's recommended therefore that days_previous isn't set to 1, or if it is, that you understand the way this has to work and the consequences. If you want to set days_previous to take an average of the house load over all the days of the last week it's suggested that it be set as: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8","title":"apps.yaml settings"},{"location":"apps-yaml/#appsyaml-settings","text":"The basic Predbat configuration is defined in the apps.yaml file. Depending on how you installed Predbat the apps.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat add-on installation method , apps.yaml will be in the directory /addon_configs/6adb4f0d_predbat , with the HACS, Appdaemon add-on then Predbat installation method , it's in /config/appdaemon/apps/batpred/config/ , or if the combined AppDaemon/Predbat add-on installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/apps . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-on's) to edit the apps.yaml file - see editing configuration files within Home Assistant if you need to install an editor. This section of the documentation describes what the different configuration items in apps.yaml do. When you edit apps.yaml , the change will automatically be detected and Predbat will be reloaded with the updated file. You don't need to restart the Predbat or AppDaemon add-on for your edits to take effect.","title":"apps.yaml settings"},{"location":"apps-yaml/#warning-appsyaml-file-format","text":"When editing the apps.yaml file you must ensure that the file remains correctly formatted. YAML files are especially finicky about how the file contents are indented and it's very easy to end up with an incorrectly formatted file that will cause problems for Predbat. The YAML Basics from This Smart Home is a good introduction video to how YAML should be correctly structured but as a brief introduction: At the start of the apps.yaml is the predbat module definition: pred_bat: module: predbat class: PredBat YAML can be thought of as a tree structure with 'pred_bat' at the top of the tree and everything else, e.g. 'module' and 'class' being children of the pred_bat tree. Each child entry must be indented by two spaces under the parent it follows, so 'module' and 'class' are thus children of 'pred_bat'. The YAML file consists of configuration item, a colon, and then the configuration value, for example, timezone is a child configuration item under the over-arching 'pred_bat' parent: timezone: Europe/London If the configuration item is a list of values, each of the list values appears on a new line, indented by a further two spaces, a dash, and then the value. For example, car_charging_response is a child of 'pred_bat' and consists of two values, 'yes' and 'no': car_charging_now_response: - 'yes' - 'on' Child entries can have children of their own, so for example rates_import_override is a child of the overarching 'pred_bat', and it has children configuration items of its own being 'start', 'end' and 'rate': rates_import_override: - start: '13:00:00' end: '14:00:00' rate: 0 The indentation of children being two spaces indented from their parents and there being two spaces before the dash are especially critical. It's easy to mis-edit and have one or three spaces which isn't valid YAML. NB: the sequence of entries in apps.yaml doesn't matter, as long as the YAML itself is structured correctly you can move things and edit things anywhere in the file.","title":"Warning! apps.yaml file format"},{"location":"apps-yaml/#templates","text":"You can find template configurations in the following location: https://github.com/springfall2008/batpred/tree/main/templates The GivEnergy GivTCP template will be installed by default but if you are using another inverter please copy the correct template into the directory where your apps.yaml is stored, replacing the existing apps.yaml file, and modify it from there. Please read Inverter Setup for inverter control software and details of setting apps.yaml for non-GivEnergy inverters","title":"Templates"},{"location":"apps-yaml/#checking-your-appsyaml","text":"Syntax errors will be highlighted by the Home Assistant editor or via other YAML-aware editors such as VSCode. Once you have completed your apps.yaml and started Predbat you may want to open the Predbat Web Interface and click on 'apps.yaml'. Review any items shown in a red background as those do not match (it's okay for a 2nd inverter not to match if you only have one configured). Regular expressions that do not match can be ignored if you are not supporting that feature (e.g. Car SOC if you don't have a car). As an example these do not match and are shown in the web interface in red, I'm ignoring them as I only have one inverter and I'm using the Predbat internal Solcast rather than the external integration:","title":"Checking your apps.yaml"},{"location":"apps-yaml/#basics","text":"Basic configuration items","title":"Basics"},{"location":"apps-yaml/#prefix","text":"Set to the prefix name to be used for all entities that Predbat creates in Home Assistant. Default 'predbat'. Unlikely that you will need to change this. prefix: predbat","title":"prefix"},{"location":"apps-yaml/#timezone","text":"Set to your local timezone, the default is Europe/London. It must be set to a valid Python time zone for your location timezone: Europe/London","title":"timezone"},{"location":"apps-yaml/#currency_symbols","text":"Sets your symbol to use for your main currency e.g. \u00a3 or $ and for 1/100th unit e.g. p or c currency_symbols: - '\u00a3' - 'p'","title":"currency_symbols"},{"location":"apps-yaml/#template","text":"Initially set to True, this is used to stop Predbat from operating until you have finished configuring your apps.yaml. Once you have made all other required changes to apps.yaml this line should be deleted or commented out: template: True","title":"template"},{"location":"apps-yaml/#home-assistant-connection","text":"Predbat can speak directly to Home Assistant rather than going via AppDaemon. If you are using a standard Predbat add-on then this will be automatic and you should normally not need to set this. If you find you get issues where Predbat cannot communicate with Home Assistant after running for a long period of time and you get web socket errors, then creating a HA access key as described below can resolve this. If you run Predbat in a Docker container then you will need to set the URL or IP address of Home Assistant and an access key. The access key is a long-lived security access token you can create inside Home Assistant: Click on your user initials (bottom left) in HA; Click the Security tab Scroll to the bottom of the security screen and under 'Long-lived Access tokens', click 'Create Token' then copy the generated access token into ha_key in apps.yaml Currently, if this communication is not established Predbat will fall back to AppDaemon, however, some users have experienced failures due to a 10-second timeout set by AppDaemon. In future versions of Predbat, AppDaemon will be removed. ha_url: 'http://homeassistant.local:8123' ha_key: 'xxxxxxxxxxx' TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This will remove the need for a DNS lookup of the IP address every time Predbat talks to Home Assistant and may improve reliability as a result.","title":"Home Assistant connection"},{"location":"apps-yaml/#threads","text":"If defined sets the number of threads to use during plan calculation, the default is 'auto' which will use the same number of threads as you have CPUs in your system. Valid values are: 'auto' - Use the same number of threads as your CPU count '0' - Don't use threads - disabled 'N' - Use N threads, recommended values are between 2 and 8 threads: auto","title":"threads"},{"location":"apps-yaml/#web-interface","text":"Docker users can change the web port for the Predbat web interface by setting web_port to a new port number. The default port of 5052 must always be used for the Predbat add-on. web_port: 5052","title":"Web interface"},{"location":"apps-yaml/#notify_devices","text":"A list of device names to notify when Predbat sends a notification. The default is just 'notify' which contacts all mobile devices notify_devices: - mobile_app_treforsiphone12_2","title":"notify_devices"},{"location":"apps-yaml/#days_previous","text":"Predbat needs to know what your likely future house load will be to set and manage the battery level to support it. days_previous defines a list (which has to be entered as one entry per line) of the previous days of historical house load that are to be used to predict your future daily load. It's recommended that you set days_previous so Predbat calculates an average house load using sufficient days' history so that 'unusual' load activity (e.g. saving sessions, \"big washing day\", etc) get averaged out. For example, if you just want Predbat to assume the house load on a particular day is the same as the same day of last week: days_previous: - 7 Or if you want Predbat to take the average of the same day for the last two weeks: days_previous: - 7 - 14 Further details and worked examples of how days_previous works are covered at the end of this document. Do keep in mind that Home Assistant only keeps 10 days of history by default, so if you want to access more than this for Predbat you might need to increase the number of days of history kept in HA before it is purged by editing and adding the following to the /homeassistant/configuration.yaml configuration file and restarting Home Assistant afterwards: recorder: purge_keep_days: 14 days_previous_weight - A list (again with one entry per line) of weightings to be applied to each of the days in days_previous. For example, to apply a 100% weighting for the first-day entry in days_previous, but only a 50% weighting to the second day in days_previous: days_previous_weight: - 1 - 0.5 The default value is 1, and all history days are equally weighted, so if you don't want to weight individual days you can simply use: days_previous_weight: - 1","title":"days_previous"},{"location":"apps-yaml/#forecast_hours","text":"the number of hours that Predbat will forecast, 48 is the suggested amount, although other values can be used such as 30 or 36 if you have a small battery and thus don't need to forecast 2 days ahead. forecast_hours: 48","title":"forecast_hours"},{"location":"apps-yaml/#inverter-information","text":"The template apps.yaml for each inverter type comes pre-configured with regular expressions that should auto-discover the Home Assistant entity names for that inverter type. If you have more than one inverter or entity names are non-standard then you will need to edit apps.yaml for your inverter entities.","title":"Inverter information"},{"location":"apps-yaml/#givenergy-cloud-direct","text":"Predbat now supports direct communication with the GivEnergy cloud services, with this method you can have your inverter auto-configured. Just log into the GivEnergy web site and create an API key and copy it into the key settings. The number of inverters and their settings will be configured automatically. If you set ge_cloud_automatic to False then you can manually configure to point to Predbat's GE Cloud configuration. If you set ge_cloud_data to False then Predbat will use the local data for history rather than the cloud data, you will need to wait until you have a few days work (at least days_previous days) before this will work correctly. ge_cloud_data: True ge_cloud_serial: '{geserial}' ge_cloud_key: 'xxxxx' ge_cloud_direct: True ge_cloud_automatic: True","title":"Givenergy cloud direct"},{"location":"apps-yaml/#num_inverters","text":"The number of inverters you have. If you increase this above 1 you must provide multiple of each of the inverter entities num_inverters: 1","title":"num_inverters"},{"location":"apps-yaml/#inverter_type","text":"inverter_type defaults to 'GE' (GivEnergy) if not set in apps.yaml, or should be set to one of the inverter types that are already pre-programmed into Predbat: GE: GivEnergy GEC: GivEnergy Cloud GEE: GivEnergy EMC GS: Ginlong Solis SE: SolarEdge SX4: Solax Gen4 (Modbus Power Control) SF: Sofar HYD SFMB: Sofar HYD with solarman modbus HU: Huawei Solar SK: Sunsynk SA: Solar Assistant If you have multiple inverters, then set inverter_type to a list of the inverter types. If you have created a custom inverter type in apps.yaml then inverter_type must be set to the same code as has been used in the custom inverter definition.","title":"inverter_type"},{"location":"apps-yaml/#geserial","text":"Only for GE inverters, this is a helper regular expression to find your inverter serial number, if it doesn't work edit it manually or change individual entities to match. If you have more than one GivEnergy inverter you will need one per inverter to be used in the later configuration lines. If you only have a single GivEnergy inverter then comment out all lines that refer to geserial2 in apps.yaml. geserial: 're:sensor.givtcp_(.+)_soc_kwh' geserial2: 're:sensor.givtcp2_(.+)_soc_kwh' If you are running GivTCP v3 and have an 'All-In-One' (AIO) or a 3-phase inverter then the helper regular expression will not correctly work and you will need to manually set geserial in apps.yaml to your inverter serial number, e.g.: geserial: 'chNNNNgZZZ' TIP: If you have a single GivEnergy AIO, all control is directly to the AIO and the gateway is not required. Check the GivTCP configuration to determine whether inverter 1 (the givtcp sensors) is the AIO or the gateway, or inverter 2 (the givtcp2 sensors) is the AIO or gateway. Then in apps.yaml comment out the lines corresponding to the gateway, leaving just the givtcp or givtcp2 lines for the AIO. Also, delete the appropriate givtcp_rest inverter control line corresponding to the gateway so that Predbat controls the AIO directly. TIP2: If you have multiple GivEnergy AIO's, all the AIO's are controlled by the AIO gateway and not controlled individually. geserial should be manually configured to be your AIO gateway serial number 'gwNNNNgZZZ' and all the geserial2 lines should be commented out in apps.yaml. You should also delete the second givtcp_rest inverter control line so that Predbat controls the AIOs via the gateway. GivTCP version 3 is required for multiple AIOs or a 3-phase inverter.","title":"geserial"},{"location":"apps-yaml/#historical-data","text":"Predbat can either get historical data (house load, import, export and PV generation) directly from GivTCP or it can obtain it from the GivEnergy cloud. Unless you have a specific reason to not use the GivTCP data (e.g. you've lost your GivTCP data), its recommended to use GivTCP.","title":"Historical data"},{"location":"apps-yaml/#data-from-home-assistant","text":"The following configuration entries in apps.yaml are pre-configured to automatically use the appropriate sensors. If you have a 3-phase electricity supply and one inverter (and battery) on each phase then you will need to add one line for the load, import, export and PV sensors for each of the 3 phases. If you have a single-phase electricity supply and multiple inverters on the phase then you will need to add one line for each of the load and PV sensors. You don't need multiple lines for the import or export sensors as each inverter will give the total import or export information. Edit if necessary if you have non-standard sensor names: load_today - Entity name for the house load in kWh today (must be incrementing) import_today - Imported energy today in kWh (incrementing) export_today - Exported energy today in kWh (incrementing) pv_today - PV energy today in kWh (incrementing). If you have multiple inverters, enter each inverter PV sensor on a separate line. If you have an AC-coupled inverter then enter the Home Assistant sensor for your PV inverter. If you don't have any PV panels, comment or delete this line out of apps.yaml. See the Workarounds section below for configuration settings for scaling these if required. If you have multiple inverters then you may find that the load_today figures are incorrect as the inverters share the house load between them. In this circumstance, one solution is to create a Home Assistant template helper to calculate house load from {pv generation}+{battery discharge}-{battery charge}+{import}-{export}. The example below is defined in configuration.yaml (not the HA user interface) so it only updates every 5 minutes rather than on every underlying sensor state change: e.g. # Home consumption sensor, updated every 5 minutes instead of the default of every sensor state change template: - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Today\" unique_id: \"house_load_today\" unit_of_measurement: kWh state_class: total device_class: energy state: > {% set x=( states('sensor.givtcp_XXX_pv_energy_today_kwh')|float(0) + <inverter 2>... + states('sensor.givtcp_XXX_battery_discharge_energy_today_kwh')|float(0) + <inverter 2>... - states('sensor.givtcp_XXX_battery_charge_energy_today_kwh')|float(0) - <inverter 2>... + states('sensor.givtcp_XXX_import_energy_today_kwh')|float(0) - states('sensor.givtcp_XXX_export_energy_today_kwh')|float(0) ) %} {{ max(x,0)|round(1) }}","title":"Data from Home Assistant"},{"location":"apps-yaml/#givenergy-cloud-data","text":"If you have an issue with the GivTCP data, Predbat can get the required historical data from the GivEnergy cloud instead. This data is updated every 30 minutes. Connecting to the cloud is less efficient and means that Predbat will be dependent upon your internet connection and the GivEnergy cloud to operate. ge_cloud_data - When True Predbat will connect to the GivEnergy cloud rather than GivTCP sensors for historical load_today, import_today and export_today inverter data ge_cloud_serial - Set the inverter serial number to use for the cloud data ge_cloud_key - Set to your API Key for the GE Cloud (long string) If you need to create a ge_cloud_key, in the GivEnergy cloud portal: Click 'account settings' in the menu bar (icon of a person overlaid with a cogwheel) Click 'Manage Account Security' then 'Manage API Tokens' then 'Create API Token' Enter a name for the token e.g. 'Predbat' Select 'No expiry' for the token expiry duration, or choose a fixed duration but remember to create a new token before it expires as Predbat's access will stop once the token expires Ensure that 'api:inverter' is ticked Create token Finally, copy/paste the token created into ge_cloud_key within apps.yaml","title":"GivEnergy Cloud Data"},{"location":"apps-yaml/#givenergy-cloud-controls","text":"Experimental Predbat now supports GE Cloud controls directly from inside Predbat. When enabled Predbat will connect directly with the GE Cloud and expose the controls of your inverter inside home assistant. Note You will still have to configure apps.yaml to point to these controls. ge_cloud_direct - Set to True to enable GE Cloud direct access ge_cloud_key - Set to your API Key for the GE Cloud (long string)","title":"GivEnergy Cloud controls"},{"location":"apps-yaml/#load-filtering","text":"By default, if Predbat sees a gap in the historical load data it will fill it with average data. This is to help in the cases of small amounts of lost data. For entire lost days you should change days_previous to point to different days(s) or include 3 or more days and if you set switch.predbat_load_filter_modal to true, the lowest day's historical load will be discarded. load_filter_threshold - Sets the number of minutes of zero load data to be considered a gap (that's filled with average data), the default is 30. To disable, set it to 1440.","title":"Load filtering"},{"location":"apps-yaml/#iboost-energy","text":"iboost_energy_today - Set to a sensor which tracks the amount of energy sent to your solar diverter, which can also be used to subtract from your historical load for more accurate predictions.","title":"iBoost energy"},{"location":"apps-yaml/#inverter-control-configurations","text":"","title":"Inverter control configurations"},{"location":"apps-yaml/#inverter_limit","text":"One per inverter. Controls the way Predbat models your inverter, this does not change the way it is controlled. When set, it defines the maximum AC output power in watts for your inverter. This is used by Predbat in calculating the plan to emulate clipping that occurs in the inverter when your solar produces more than the inverter can handle, but it won't be that accurate as the source of the data isn't minute-by-minute. For a Hybrid inverter make sure the Hybrid Inverter toggle is on, you should set the inverter limit to be the maximum power of the inverter in Watts e.g. a 5kW inverter will have a limit of 5000. If you have a separate Micro Inverter for your PV then you should add its power to the inverter limit For an AC Coupled inverter make sure the Hybrid Inverter toggle is off and set this to the power of your AC Coupled inverter. Do not add on separate Micro Inverters to the total power. If you have multiple inverters then set the value of each one in a list format. NB: inverter_limit is ONLY used by Predbat to improve the quality of the plan, any solar clipping is done by the inverter and is not controlled by Predbat.","title":"inverter_limit"},{"location":"apps-yaml/#export_limit","text":"One per inverter (optional). Controls the way Predbat models your inverter, this does not change the way it is controlled. When set defines the maximum watts of AC power your inverter can export to the grid at (e.g. 2500). This is used by Predbat in calculating the plan to emulate your inverter's software export limit setting that you will have if your G98/G99 approval was lower than your maximum inverter power (check your install information for details). If you do not set an export limit then it is assumed to be unlimited (and thus limited by your inverter or PV system).","title":"export_limit"},{"location":"apps-yaml/#inverter_limit_charge-and-inverter_limit_discharge-one-per-inverter-optional","text":"When set in Watts, overrides the maximum charge/discharge rate settings used when controlling the inverter. This can be used if you need Predbat to cap your inverter battery rate (e.g. charge overnight at a slower rate to reduce inverter/battery heating) as Predbat will normally configure all timed charges or discharges to be at the inverter's maximum rate.","title":"inverter_limit_charge and inverter_limit_discharge - One per inverter (optional)"},{"location":"apps-yaml/#inverter_can_charge_during_export","text":"Global setting, defaults to True. Controls the way Predbat models your inverter, this does not change the way it is controlled. During a force export period if the generated solar exceeds the inverter limit or the export limit then the inverter will scale back the export rate. If this setting is True then the inverter can end up charging the battery from PV while still in Force Export mode. If this setting if False then the inverter will not charge the battery and the excess PV will be lost.","title":"inverter_can_charge_during_export"},{"location":"apps-yaml/#controlling-the-inverter","text":"There are a few different ways to control your inverter: Home Assistant entity controls (standard) GivTCP REST Interface (GivEnergy Inverters only) Service API MQTT API","title":"Controlling the Inverter"},{"location":"apps-yaml/#home-assistant-entity-inverter-control","text":"Predbat can control inverters by updating Home Assistant entities. The template apps.yaml for is pre-configured with regular expressions for many configuration items, but some of them may need updating to match your system. If you only have a single inverter then the second inverter lines can be commented out if so desired or left in place (as they are ignored). The givtcp_rest line should be commented out/deleted on anything but GivTCP REST mode.","title":"Home Assistant entity inverter control"},{"location":"apps-yaml/#chargedischarge-rate","text":"charge_rate - Battery charge rate entity in watts discharge_rate - Battery discharge max rate entity in watts or charge_rate_percent - Battery charge rate entity in percent of maximum rate (0-100) discharge_rate_percent - Battery discharge max rate entity in percent of maximum rate (0-100)","title":"Charge/Discharge rate"},{"location":"apps-yaml/#battery-information","text":"battery_voltage - Current battery voltage (only needed for inverters controlled via amps) battery_rate_max - Sets the maximum battery charge/discharge rate in watts (e.g. 6000). For GivEnergy inverters this can be determined from the inverter, but must be set for non-GivEnergy inverters or Predbat will default to 2600W. soc_max - Entity name for the maximum charge level for the battery in kWh battery_min_soc - When set limits the target SOC% setting for charge and discharge to a minimum percentage value reserve - sensor name for the reserve setting in % battery_temperature - Defined the temperature of the battery in degrees C (default is 20 if not set)","title":"Battery Information"},{"location":"apps-yaml/#power-data","text":"Note this are not required for normal operation, only to produce power flow data or for battery curve calculations. One entry per inverter: battery_power - Current battery power in W or kW Battery power should be positive for discharge and negative for charge, if your sensor is the other way around then set battery_power_invert to True pv_power - Current PV power in W or kW load_power - Current load power in W or kW grid_power - Current grid power in W or kW Grid power should be negative for import and positive for export, if your sensor is the other way around then set grid_power_invert to True e.g: battery_power: - sensor.givtcp_{geserial}_battery_power battery_power_invert: - False grid_power: - sensor.givtcp_{geserial}_grid_power grid_power_invert: - False pv_power: - sensor.givtcp_{geserial}_pv_power load_power: - sensor.givtcp_{geserial}_load_power","title":"Power Data"},{"location":"apps-yaml/#battery-soc","text":"soc_kw - Entity name of the battery SOC in kWh, should be the inverter one not an individual battery or soc_percent Entity name of the battery SOC in percent of the maximum battery size, should be the inverter one not an individual battery","title":"Battery SoC"},{"location":"apps-yaml/#inverter-info","text":"inverter_reserve_max - When set defines the maximum reserve setting in % (default is 100) inverter_mode - Givenergy inverter mode control inverter_time - Inverter timestamp, used to track the last update of the inverter data inverter_battery_rate_min - Defines the minimum discharge/charge rate of the battery in watts (default is 0)","title":"Inverter Info"},{"location":"apps-yaml/#schedule","text":"charge_start_time - Battery charge start time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_end_time - Battery charge end time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_limit - Entity name for used to set the SOC target for the battery in percentage (AC charge target) scheduled_charge_enable - Scheduled charge enable config scheduled_discharge_enable - Scheduled discharge enable config discharge_start_time - scheduled discharge slot_1 start time discharge_end_time - scheduled discharge slot_1 end time discharge_target_soc - Set the battery target percent for timed exports, will be written to minimum by Predbat. pause_mode - Givenergy pause mode register (if present) pause_start_time - scheduled pause start time (only if supported by your inverter) pause_end_time - scheduled pause start time (only if supported by your inverter) If you are using REST control the configuration items should still be kept as not all controls work with REST. TIP: Some older GivEnergy inverters such as the Gen 1 hybrid and AC3 inverter that have had firmware upgrades to introduce battery pause functionality do not have sufficient memory on the inverter to provide control of battery pause start and end times. GivTCP does not recognise this and so still provides the select.givtcp_xxxx_battery_pause_start_time_slot and end_time_slot controls, but they do not work. Predbat can report an error trying to set them, or they revert back to 00:00:00 after being changed by Predbat and there will also be errors setting these controls reported in the GivTCP log. For these inverters the pause_start_time and pause_end_time entries should be commented out in apps.yaml to stop Predbat trying to use them. See section below on creating the battery charge power curve .","title":"Schedule"},{"location":"apps-yaml/#rest-interface-inverter-control","text":"For GivEnergy inverters Predbat can control the inverter directly via REST instead of via the Home Assistant GivTCP inverter controls detailed above. When configured in apps.yaml, control communication from Predbat to GivTCP is via REST which bypasses some issues with MQTT. givtcp_rest - One entry per Inverter, sets the GivTCP REST API URL ( http://homeassistant.local:6345 is the normal address and port for the first inverter, and the same address but ending :6346 if you have a second inverter - if you don't have a second inverter (or if you have multiple AIO's that are controlled through the gateway), delete the second line. If you are using Docker then change 'homeassistant.local' to the Docker IP address. TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This may improve reliability of the REST connection as it doesn't need to lookup the HA server IP address each time. To check your REST is working open up the readData API point in a Web browser e.g: http://homeassistant.local:6345/readData If you get a bunch of inverter information back then it's working! Note that Predbat will still retrieve inverter information via REST, this configuration only applies to how Predbat controls the inverter.","title":"REST Interface inverter control"},{"location":"apps-yaml/#service-api","text":"Some inverters have the Service API enabled, this allows the configuration to call an arbitrary Home Assistant service to start/stop charging and discharging charge_start_service - Should be set to a service that is called when charging starts charge_freeze_service - If your inverter supports charge freeze set to a service that starts this mode charge_stop_service - Should be set to a service that is called when charging/charge freeze stops discharge_start_service - Should be set to a service that is called when force export (discharge) starts discharge_freeze_service - If your inverter supports export freeze set to a service that starts this mode discharge_stop_service - Should be set to a service that is called when export/export freeze stops Services that are not configuration will not be called. Example service is below: charge_start_service: service: switch.turn_off entity_id: \"switch.sunsynk_inverter_use_timer\" See Service API for details. Note that device_id will be passed to the service automatically, it can be set in apps.yaml.","title":"Service API"},{"location":"apps-yaml/#mqtt-api","text":"Some Inverters are enabled with an MQTT API, in this case certain MQTT messages are send via the HA MQTT service. The mqtt_topic in apps.yaml set in the root of the MQTT topic (shown as topic below).","title":"MQTT API"},{"location":"apps-yaml/#set-reserve","text":"Called when the reserve (discharge-to %) is changed topic: topic /set/reserve payload: reserve","title":"Set reserve"},{"location":"apps-yaml/#set-target-soc","text":"Called when the target (charge-to %) SoC is changed topic: topic /set/target_soc payload: soc","title":"Set target soc"},{"location":"apps-yaml/#set-charge-rate","text":"Called to change the charge rate in Watts topic: topic /set/charge_rate payload: charge_rate","title":"Set charge rate"},{"location":"apps-yaml/#set-discharge-rate","text":"Called to change the discharge rate in Watts topic: topic /set/discharge_rate payload: discharge_rate","title":"Set discharge rate"},{"location":"apps-yaml/#set-charge","text":"Called when a charge is started topic: topic /set/charge payload: charge_rate","title":"Set charge"},{"location":"apps-yaml/#set-discharge","text":"Called when a forced export (discharge) is started topic: topic /set/discharge payload: discharge_rate","title":"Set discharge"},{"location":"apps-yaml/#set-auto","text":"Called when a charge/discharge is cancelled and the inverter goes back to home demand mode. topic: topic /set/auto payload: true","title":"Set auto"},{"location":"apps-yaml/#solcast-solar-forecast","text":"As described in the Predbat installation instructions , Predbat needs a solar forecast in order to predict solar generation and battery charging which can be provided by the Solcast integration. By default, the template apps.yaml is pre-configured to use the Solcast forecast integration for Home Assistant. The apps.yaml contains regular expressions for the following configuration items that should auto-discover the Solcast forecast entity names. They are unlikely to need changing although a few people have reported their entity names don't contain 'solcast' so worth checking, or editing if you have non-standard names: pv_forecast_today - Entity name for today's Solcast forecast pv_forecast_tomorrow - Entity name for tomorrow's Solcast's forecast pv_forecast_d3 - Entity name for Solcast's forecast for the day after tomorrow pv_forecast_d4 - Entity name for Solcast's forecast for two days after tomorrow Sensors for d5, d6 & d7 are supported, but not that useful so are not pre-defined in the template. If you do not have a PV array then comment out or delete these Solcast lines from apps.yaml . Alternatively, Predbat can obtain the solar forecast directly from Solcast and the Solcast integration is thus not required. Uncomment the following Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 Note that by default the Solcast API will be used to download all sites (up to 2 for hobby accounts), if you want to override this set your sites manually using solcast_sites as an array of site IDs: solcast_sites: - 'xxxx' If you have more than 2 array orientations and thus more than one Solcast API key, enter each key in a list: solcast_api_key: - xxxx_API_key_1 - yyyy_API_key_2 Keep in mind hobbyist accounts only have 10 polls per day so you need to ensure that the solcast_poll_hours refresh period is set so that you do not exceed the 10 poll limit. If you have two arrays then each Solcast refresh will consume 2 polls so its suggested that you set solcast_poll_hours to 4.8 to maximise your polls over a 24 hour period (5 polls a day, 24/5=poll every 4.8 hours). If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. If you use the same Solcast account for other automations the poll frequency will need to be reduced to ensure the total polls is kept under your account daily poll limit or you will experience failures. If you have multiple PV arrays connected to hybrid inverters or you have AC-coupled inverters, then ensure your PV configuration in Solcast covers all arrays. If however, you have a mixed PV array setup with some PV that does not feed into the inverters that Predbat is managing (e.g. hybrid GE inverters with older firmware but a separate older FIT array that directly feeds AC into the house), then it's recommended that Solcast is only configured for the PV connected to the inverters that Predbat is managing. NB: Gen2, Gen3 and Gen1 hybrid inverters with the 'fast performance' firmware can charge their batteries from excess AC that would be exported, so for these inverters, you should configure Solcast with your total solar generation capability. Solcast produces 3 forecasted PV estimates, the 'central' (50% or most likely to occur) PV forecast, the '10%' (1 in 10 more cloud coverage 'worst case') PV forecast, and the '90%' (1 in 10 less cloud coverage 'best case') PV forecast. By default, Predbat will use the central (PV50) estimate and apply to it the input_number.predbat_pv_metric10_weight weighting of the 10% (worst case) estimate. You can thus adjust the metric10_weight to be more pessimistic about the solar forecast. Predbat models cloud coverage by using the difference between the PV and PV10 forecasts to work out a cloud factor, this modulates the PV output predictions up and down over the 30-minute slot as if there were passing clouds. This can have an impact on planning, especially for things like freeze charging which could assume the PV will cover the house load but it might not due to clouds. pv_estimate in apps.yaml can be used to configure Predbat to always use the 10% forecast by setting the configuration item to '10', or '90' to always use the 90% PV estimate (not recommended!). Set to blank or delete / comment out the line to use the default central estimate. If pv_estimate is set to 10 then input_number.predbat_pv_metric10_weight in Home Assistant should be set to 1.0. See also PV configuration options in Home Assistant .","title":"Solcast Solar Forecast"},{"location":"apps-yaml/#forecastsolar-solar-forecast","text":"The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality.","title":"Forecast.solar Solar Forecast"},{"location":"apps-yaml/#energy-rates","text":"There are a number of configuration items in apps.yaml for telling Predbat what your import and export rates are. These are described in detail in Energy Rates and are listed here just for completeness: metric_octopus_import - Import rates from the Octopus Energy integration metric_octopus_export - Export rates from the Octopus Energy integration metric_octopus_gas - Gas rates from the Octopus Energy integration octopus_intelligent_slot - Octopus Intelligent GO slot sensor from the Octopus Energy integration octopus_saving_session - Energy saving sessions sensor from the Octopus Energy integration octopus_saving_session_octopoints_per_penny - Sets the Octopoints per pence rates_import_octopus_url - Octopus pricing URL (over-rides metric_octopus_import) rates_export_octopus_url - Octopus export pricing URL (over-rides metric_octopus_export) metric_standing_charge - Standing charge in pounds rates_import - Import rates over a 24-hour period with start and end times rates_export - Export rates over a 24-hour period with start and end times rates_gas - Gas rates over a 24-hour period with start and end times rates_import_override - Over-ride import rate for specific date and time range, e.g. Octopus Power-up events rates_export_override - Over-ride export rate for specific date and time range futurerate_url - URL of future energy market prices for Agile users futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on market prices or not futurerate_peak_start and futurerate_peak_end - start/end times for peak-rate adjustment carbon_intensity - Carbon intensity of the grid in half-hour slots from an integration.","title":"Energy Rates"},{"location":"apps-yaml/#energy-comparison","text":"You can configure in apps.yaml a compare_list section to define a list of Energy tariffs for Predbat to compare based on your predicted load and solar generation. See the Predbat Compare feature for details of how to define the tariffs to be compared.","title":"Energy Comparison"},{"location":"apps-yaml/#car-charging-integration","text":"Predbat can include electric vehicle charging in its plan and manage the battery activity so that the battery isn't discharged into your car when the car is charging (although you can override this if you wish by setting the switch.predbat_car_charging_from_battery to True in Home Assistant). There are two different ways of planning car charging into cheap slots with Predbat, either by the Octopus Energy integration or by Predbat identifying the cheapest slots. These approaches and the set of settings that need to be configured together are described in Car Charging . The full list of car charging configuration items in apps.yaml that are used to plan car charging activity within Predbat are described below. The Home Assistant controls (switches, input numbers, selectors, etc) related to car charging are described in Car Charging configuration within Home Assistant , with a brief mention of pertinent controls included here alongside the apps.yaml configuration items where relevant for context. num_cars should be set in apps.yaml to the number of cars you want Predbat to plan for. Set to 0 if you don't have an EV (and the remaining car sensors in apps.yaml can safely be commented out or deleted as they won't be required). NB: num_cars must be set correctly regardless of whether you are using Octopus Intelligent Go to control your EV charging or Predbat to control the charging; or else Predbat could start discharging your battery when the EV is charging. car_charging_exclusive should be set to True for each car in apps.yaml if you have multiple cars configured in Predbat, but only one car charger. This indicates that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False for each car then it is assumed that the car can charge independently, and hence two or more cars could charge at once. One entry per car. car_charging_exclusive: - True - True","title":"Car Charging Integration"},{"location":"apps-yaml/#car-charging-filtering","text":"Depending upon how the CT clamps and your inverter and electric car charger have been wired, your inverter may 'see' your EV charging as being part of the house load. This means your house load is artificially raised whenever you charge your car. In this circumstance you might want to remove your electric car charging data from the historical house load data so as to not bias the calculations, otherwise you will get high battery charge levels when the car was charged previously (e.g. last week). TIP: Check the house load being reported by your inverter when your car is charging. If it doesn't include the car charging load then there is no need to follow these steps below (and if you do, you'll artificially deflate your house load). switch.predbat_car_charging_hold - A Home Assistant switch that when turned on (True) tells Predbat to remove car charging data from your historical house load so that Predbat's battery prediction plan is not distorted by previous car charging. car_charging_energy - Set in apps.yaml to point to a Home Assistant entity which is the daily incrementing kWh data for the car charger. This has been pre-defined as a regular expression that should auto-detect the appropriate Wallbox and Zappi car charger sensors, or edit as necessary in apps.yaml for your charger sensor. Note that this must be configured to point to an 'energy today' sensor in kWh not an instantaneous power sensor (in kW) from the car charger. IMPORTANT: If car_charging_energy is not configured with the correct sensor or your car charging energy sensor does not accurately report your car charging data (e.g. it falsely reports charging data when not actually charging), this will really mess up your predbat plan as Predbat will exclude all car_charging_energy from your load predictions. Do check the entity! TIP: You can also use car_charging_energy to remove other house load kWh from the data Predbat uses for the forecast, e.g. if you want to remove Mixergy hot water tank heating data from the forecast such as if you sometimes heat on gas, and sometimes electric depending upon import rates. car_charging_energy can be set to a list of energy sensors, one per line if you have multiple EV car chargers, or want to exclude multiple loads, e.g.: car_charging_energy: - 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)' - sensor.mixergy_ID_energy input_number.predbat_car_charging_energy_scale - A Home Assistant entity used to define a scaling factor (in the range of 0 to 1.0) to multiply the car_charging_energy sensor data by if required (e.g. set to 0.001 to convert Watts to kW). If you do not have a suitable car charging energy kWh sensor in Home Assistant then comment the car_charging_energy line out of apps.yaml and configure the following Home Assistant entity: input_number.predbat_car_charging_threshold (default 6 = 6kW)- Sets the kW power threshold above which home consumption is assumed to be car charging and input_number.predbat_car_charging_rate will be subtracted from the historical load data.","title":"Car Charging Filtering"},{"location":"apps-yaml/#planned-car-charging","text":"These features allow Predbat to know when you plan to charge your car. If you have an Intelligent Octopus tariff then planning of charging is done via the Octopus app and Predbat obtains this information through the Octopus Energy integration in Home Assistant. switch.predbat_octopus_intelligent_charging - When this Home Assistant switch is enabled, Predbat will plan charging around the Intelligent Octopus slots, taking it into account for battery load and generating the slot information The following apps.yaml configuration items are pre-defined with regular expressions to point to appropriate sensors in the Octopus Energy integration. You should not normally need to change these if you have the Octopus Intelligent tariff: octopus_intelligent_slot - Points to the Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot, and provides the list of future planned charging activity. octopus_ready_time - Points to the Octopus Energy integration sensor that details when the car charging will be completed. Note: the Octopus Integration now provides Octopus Intelligent target time in two formats, either a 'select' entity or a 'time' entity. Predbat uses the time entity (time.octopus_energy_{{ACCOUNT_ID}}_intelligent_target_time) which is disabled by default, so you will need to enable the time entity and disable the matching select entity. octopus_charge_limit - Points to the Octopus Energy integration sensor that provides the car charging limit. octopus_slot_low_rate - Default is True, meaning any Octopus Intelligent Slot reported will be at the lowest rate if at home. If False the existing rates only will be used which is only suitable for tariffs other than IOG. If you don't use Intelligent Octopus then the above 3 Octopus Intelligent configuration lines in apps.yaml can be commented out or deleted, and there are a number of other apps.yaml configuration items that should be set: car_charging_planned - Optional, can be set to a Home Assistant sensor (e.g. from your car charger integration) which lets Predbat know the car is plugged in and planned to charge during low-rate slots. Or manually set it to 'False' to disable this feature, or 'True' to always enable it. The apps.yaml template supplied with Predbat comes pre-configured with a regular expression that should automatically match Zappi or Wallbox car chargers. If you have a different type of charger you will need to configure it manually. car_charging_planned_response - An array of values for the above car_charging_planned sensor which indicate that the car is plugged in and will charge in the next low rate slot. The template apps.yaml comes with a set of pre-defined sensor values that should match most EV chargers. Customise for your car charger sensor if it sets sensor values that are not in the list. car_charging_now - For some cases finding details of planned car charging is difficult. The car_charging_now configuration item can be set to point to a Home Assistant sensor that tells you that the car is currently charging. Predbat will then assume this 30-minute slot is used for charging regardless of the plan. If Octopus Intelligent Charging is enabled and car_charging_now indicates the car is charging then Predbat will also assume that this is a low rate slot for the car/house (and might therefore start charging the battery), otherwise electricity import rates are taken from the normal rate data. WARNING: Some cars will briefly start charging as soon as they are plugged in, which Predbat will detect and assume that this is a low rate slot even when it isn't. It is therefore recommended that you do NOT set car_charging_now unless you have problems with the Octopus Intelligent slots, and car_charging_now should be commented out in apps.yaml . CAUTION: Do not use car_charging_now with Predbat led charging or you will create an infinite loop. Do you use car_charging_now with Octopus intelligent unless you can't make it work any other way as it will assume all car charging is at a low rate. car_charging_now_response - Set to the range of positive responses for car_charging_now to indicate that the car is charging. Useful if you have a sensor for your car charger that isn't binary. To make planned car charging more accurate, configure the following items in apps.yaml : car_charging_battery_size - Set this value in apps.yaml to the car's battery size in kWh which must be entered with one decimal place, e.g. 50.0. If not set, Predbat defaults to 100.0kWh. This will be used to predict when to stop car charging. car_charging_limit - You should configure this to point to a sensor that specifies the % limit the car is set to charge to. This could be a sensor on the EV charger integration or a Home Assistant helper entity you can set as you wish. If you don't specify a sensor Predbat will default to 100% - i.e. fill the car to full. car_charging_soc - You should configure this to point to a sensor (on the HA integration for your EV charger) that specifies the car's current charge level expressed as a percentage - it must NOT be set to a sensor that gives the car's current kWh value as this will cause Predbat to charge the car to an incorrect level. If you don't specify a sensor, Predbat will default to 0%. If you have multiple electric cars then car_charging_soc should be set to a list of sensors, e.g.: car_charging_soc: - 'sensor.tsunami_battery' - 'sensor.toyota_XXX_battery_level'","title":"Planned Car Charging"},{"location":"apps-yaml/#multiple-electric-cars","text":"Multiple cars can be planned with Predbat, in which case you should set num_cars in apps.yaml to the number of cars you want to plan. car_charging_limit , car_charging_planned , car_charging_battery_size and car_charging_soc must then be a list of values (i.e. 2 entries for 2 cars) If you have Intelligent Octopus then Car 0 will be managed by the Octopus Energy integration, if it's enabled Each car will have its own Home Assistant slot sensor created e.g. binary_sensor.predbat_car_charging_slot_1 , SoC planning sensor e.g predbat.car_soc_1 and predbat.car_soc_best_1 for car 1","title":"Multiple Electric Cars"},{"location":"apps-yaml/#watch-list-automatically-start-predbat-execution","text":"By default Predbat will run automatically every 5 minute and to execute the plan, and re-evaluate the plan automatically every 10 minutes. You can manually force Predbat to start executing by turning switch.predbat_active on - see Predbat's output data . Additionally Predbat can 'watch' a number of Home Assistant entities and if one of those changes, Predbat will automatically start executing. This can be useful for EV owners such as to detect when you have plugged the EV in (for Predbat to stop the battery discharging), and with Intelligent Octopus Go if Octopus gives you additional charge slots. In apps.yaml , uncomment (or add) the following lines, customising to the list of configuration items you have setup in apps.yaml and want Predbat to watch for changes for: watch_list: - '{octopus_intelligent_slot}' - '{octopus_ready_time}' - '{octopus_charge_limit}' - '{octopus_saving_session}' - '+[car_charging_planned]' - '+[car_charging_soc]' - '{car_charging_now}' Note the notation for watch_list, a single value apps.yaml configuration item such as octopus_intelligent_slot is surrounded by curly bracket parenthesis {}, but for apps.yaml configuration items that can be a list such as car_charging_soc they are surrounded by +[ and ].","title":"Watch List - automatically start Predbat execution"},{"location":"apps-yaml/#load-forecast","text":"In addition to the historical house load data that Predbat uses by default, you can optionally provide a forecast of future load such as is produced by Predheat for Hot water and Heat Pump heating systems or via Predai load_forecast - this should be configured to point to a sensor and attribute. The attribute must be in either The format of 'last_updated' timestamp and 'energy' in incrementing kWh. The format of a dictionary of timestamps and energy data in incremental KWh. For example: Or apps.yaml should be configured to point to the forecast sensor and attribute (in the above formats) like this: load_forecast: - sensor_name$attribute_name So if using Predheat it would be configured as: load_forecast: - predheat.heat_energy$external Set load_forecast_only to True if you do not wish to use the Predbat forecast but instead want to use this as your only forecast data e.g using PredAi: load_forecast_only: True load_forecast: - sensor.givtcp_{geserial}_load_energy_today_kwh_prediction$results","title":"Load Forecast"},{"location":"apps-yaml/#balance-inverters","text":"When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. Most of the Predbat configuration for balancing inverters is through a number of Home Assistant controls for Balancing Inverters , but there is one configuration item in apps.yaml : balance_inverters_seconds: seconds Defines how often to run the inverter balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds.","title":"Balance Inverters"},{"location":"apps-yaml/#workarounds","text":"There are a number of different configuration items in apps.yaml that can be used to tweak the way Predbat operates and workaround weirdness you may have from your inverter and battery setup.","title":"Workarounds"},{"location":"apps-yaml/#base-load","text":"Sometimes the load predictions can yield near zero data due to inaccuracy of data (e.g. a second PV system not tracked, car data being unreliable, poor sensors). In order to not get unrealistically low values you can set a base load value (in watts) which Predbat will use as a minimum load for a 30-minute period. To set a base load set base_load as an integer value in watts. base_load: 300 The above example load forecasts will now not fall below 300 watts which would be 0.15 kWh in a 30-minute period.","title":"Base load"},{"location":"apps-yaml/#clock-skew","text":"clock_skew: minutes Skews the local (computer) time that Predbat uses (from the computer that Predbat is running on). Set to 1 means add a minute to the Predbat computer time, set to -1 means take a minute off the Predbat computer time. This clock adjustment will be used by Predbat when real-time actions happen e.g. triggering a charge or discharge. If your inverter's time is different to the time on the computer running Home Assistant, you may need to skew the time settings made on the inverter when you trigger charging or discharging. Again 1 means the inverter is 1 minute fast and -1 means the inverter is 1 minute slow. Separate start and end options are applied to the start and end time windows, mostly as you want to start battery activity late (not early) and finish early (not late). You can adjust the charge and discharge times written to the inverter by setting the following in apps.yaml : inverter_clock_skew_start: minutes inverter_clock_skew_end: minutes Skews the setting of the charge slot registers vs the predicted start time inverter_clock_skew_discharge_start: minutes inverter_clock_skew_discharge_end: minutes Skews the setting of the discharge slot registers vs the predicted start time","title":"Clock skew"},{"location":"apps-yaml/#battery-size-scaling","text":"battery_scaling: - scale Default value 1.0. Multiple battery size scales can be entered, one per inverter on separate lines. This setting is used to scale the battery-reported SoC kWh to make it appear bigger or larger than it is. As the GivEnergy inverters treat all batteries attached to an inverter as in effect one giant battery, if you have multiple batteries on an inverter that need scaling you should enter a composite scaling value for all batteries attached to the inverter. TIP: If you have a GivEnergy 2.6 or 5.2kWh battery then it will have an 80% depth of discharge but it will falsely report its capacity as being the 100% size, so set battery_scaling to 0.8 to report the correct usable capacity figure to Predbat. TIP: Likewise, if you have one or multiple GivEnergy All-in-Ones (AIOs), it will incorrectly report the 13.5kWh usable capacity of each AIO as 15.9kWh, so set battery_scaling to 0.85 to correct this. If you are going to chart your battery SoC in Home Assistant then you may want to use predbat.soc_kw_h0 as your current SoC (as this will be scaled) rather than the usual givtcp_SERIAL_NUMBER_soc GivTCP entity so everything lines up.","title":"Battery size scaling"},{"location":"apps-yaml/#import-export-scaling","text":"import_export_scaling: scale Default value 1.0. Used to scale the import & export kWh data from GivTCP if the inverter information is incorrect.","title":"Import export scaling"},{"location":"apps-yaml/#inverter-rate-minimum","text":"inverter_battery_rate_min: watts One per inverter (optional), set in Watts, when set models a \"bug\" in the inverter firmware in some models where if charge or discharge rates are set to 0 you actually get a small amount of charge or discharge. The recommended setting is 200 for Gen 1 hybrids with this issue.","title":"Inverter rate minimum"},{"location":"apps-yaml/#inverter-reserve-maximum","text":"inverter_reserve_max: percent Global, sets the maximum reserve % that may be set to the inverter, the default is 98, as some Gen 2 & Gen 3 inverters and AIO firmware versions refuse to be set to 100. Comment the line out or set it to 100 if your inverter allows setting it to 100%.","title":"Inverter reserve maximum"},{"location":"apps-yaml/#automatic-restarts","text":"If the add-on that is providing the inverter control stops functioning it can prevent Predbat from functioning correctly. In this case, you can tell Predbat how to restart the add-on using a service. Right now only communication loss with GE inverters is detectable but in the future other systems will be supported. When enabled if communication is lost then the service configured will be triggered and can cause a restart which may restart the connection. This may be useful with GivTCP if you have time sync errors or lose the REST service every now and again. The auto_restart itself is a list of commands to run to trigger a restart. The shell command will call a 'sh' shell and can be used to delete files and suchlike. The service command is used to call a service and can contain arguments of addon and/or entity_id . The configuration below is for GivTCP v3. auto_restart: - shell: 'rm -rf /homeassistant/GivTCP/*.pkl' - service: hassio/addon_restart addon: 533ea71a_givtcp NB: If you are running GivTCP v2 then the line '533ea71a_givtcp' must be replaced with 'a6a2857d_givtcp' as the slug-id (Home Assistant add-on identifier) is different between GivTCP v2 and v3.","title":"Automatic restarts"},{"location":"apps-yaml/#battery-chargedischarge-curves","text":"Some batteries tail off their charge rate at high SoC% or their discharge rate at low SoC%, and these optional configuration items enable you to model this tail-off in Predbat. Note that the charge/discharge curves only affect the accuracy of the charging/discharging model Predbat applies in the forward battery plan, Predbat will still instruct the inverter to charge/discharge at full rate regardless of the charging curve. If you know the battery charge or discharge curves (e.g. manufacturer info or your own testing) then you can manually configure this in apps.yaml, or Predbat can calculate the curves based on historical inverter charging/discharging data in Home Assistant. If the battery has not recently been fully charged or fully discharged then Predbat will not be able to calculate the curves and you'll get a warning in the logfile. battery_charge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in charging at high SoC%. Enter the charging curve as a series of steps of % of max charge rate for each SoC percentage. The default is 1.0 (full power) charge to 100%. Modelling the charge curve becomes important if you have limited charging slots (e.g. only a few hours a night) or you wish to make accurate use of the low power charging mode ( switch.predbat_set_charge_low_power ). If the battery_charge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon add-on, or an edit being made to apps.yaml), then Predbat will automatically calculate the charging curve for you from historical battery charging information. You should look at the Predbat logfile to find the predicted battery charging curve and copy/paste it into your apps.yaml file. The logfile will also include a recommendation for how to set your battery_rate_max_scaling setting in HA. The YouTube video charging curve and low power charging explains how the curve works and shows how Predbat automatically creates it. Setting this option to auto will cause the computed curve to be stored and used automatically. This is not recommended if you use low power charging mode as your history will eventually not contain any full power charging data to compute the curve, so in this case it's best to manually configure the charge curve in apps.yaml. NB: For Predbat to calculate your charging curve it needs to have access to historical Home Assistant data for battery_charge_rate, battery_power and soc_kw. These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. If you have a GivEnergy inverter and are using the recommended default REST mode to control your inverter then you will need to uncomment out the following entries in apps.yaml : charge_rate: - number.givtcp_{geserial}_battery_charge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh Example charging curve from a GivEnergy 9.5kWh battery with the latest firmware and Gen 1 inverter: battery_charge_power_curve: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in discharging at low SoC%. Enter the discharging curve as a series of steps of % of max discharge rate for each SoC percentage. The default is 1.0 (full power) discharge to 0%. If the battery_discharge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon add-on, or an edit being made to apps.yaml), then Predbat will automatically calculate the discharging curve for you from historical battery discharging information. You should look at the Predbat logfile to find the predicted battery discharging curve and copy/paste it into your apps.yaml file. Setting This option to auto will cause the computed curve to be stored and used automatically. This may not work very well if you don't do regular discharges to empty the battery. In the same way, as for the battery charge curve above, Predbat needs to have access to historical Home Assistant data for battery_discharge_rate, battery_power and soc_kw. These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. If you are using REST mode to control your GivEnergy inverter then the following entries in apps.yaml will need to be uncommented : discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh","title":"Battery charge/discharge curves"},{"location":"apps-yaml/#battery-temperature-curves","text":"Your battery's maximum charge and discharge rate can be impacted by cold weather, Predbat can predict this if you provide a temperature sensor and define a curve. You must make sure battery_temperature is defined (one per inverter). Set battery_temperature_history to a sensor with history, this will be used to predict future temperatures based on past changes Set battery_temperature_charge_curve to define the maximum charge rate in C which is a percentage of your battery capacity. Set battery_temperature_discharge_curve to define the maximum discharge rate in C which is a percentage of your battery capacity. An example for GivEnergy Gen2 battery is below. Note You must adjust the curve for your system. gaps in the curve above 20 will use 20 degrees, and gaps below 0 will use 0 degrees. Do not leave gaps in the curve between 20 and 0. # Battery temperature charge adjustment curve # Specific in C which is a multiple of the battery capacity # e.g. 0.33 C is 33% of the battery capacity # values unspecified will be assumed to be 1.0 hence rate is capped by the max charge rate battery_temperature_history: sensor.givtcp_battery_stack_1_bms_temperature battery_temperature_charge_curve: 20: 0.50 19: 0.33 18: 0.33 17: 0.33 16: 0.33 15: 0.33 14: 0.33 13: 0.33 12: 0.33 11: 0.33 10: 0.25 9: 0.25 8: 0.25 7: 0.25 6: 0.25 5: 0.25 4: 0.25 3: 0.25 2: 0.25 1: 0.15 0: 0.00","title":"Battery temperature curves"},{"location":"apps-yaml/#alert-system","text":"Predbat can take data directly from the Meteo-Alarm feed and use it to trigger keeping your battery charged so you have power in the event of a power cut. Please look at their web site for more details. The apps.yaml must be configured to select the URL for your country. The event severity and certainty are all regular expressions and can be set to one or multiple values using regular expression syntax. Any unset values are ignored. Your location (from Home Assistant) is used to filter alerts that apply only to your area. Events that match the given criteria will try to keep your battery at the percentage level specified by keep (default 100%) during the entire event period. This works by using a much stronger version of best_soc_keep but only for that time period. Your Predbat status will also have [Alert] in it during the alert time period and the triangle alert symbol will show on your HTML plan for the time period of the alert. # Alert feeds - customise to your country, the alert types, severity and keep value # Customise to your needs, delete the ones you don't want to trigger on - e.g. remove Amber, Moderate and Possible. alerts: url: \"https://feeds.meteoalarm.org/feeds/meteoalarm-legacy-atom-united-kingdom\" event: \"(Amber|Yellow|Orange|Red).*(Wind|Snow|Fog|Rain|Thunderstorm|Avalanche|Frost|Heat|Coastal event|Flood|Forestfire|Ice|Low temperature|Storm|Tornado|Tsunami|Volcano|Wildfire)\" severity: \"Moderate|Severe|Extreme\" certainty: \"Possible|Likely|Expected\" keep: 40","title":"Alert System"},{"location":"apps-yaml/#triggers","text":"export_triggers - The export trigger feature is useful to help trigger your own automation based on Predbat predicting in the plan that you will have spare solar energy that would be exported - this could happen if the battery is full or there is more predicted solar generation than can be charged into the battery. You can use the trigger in an automation, for example, you could turn on an immersion heater or the washing machine to consume the excess solar power. The triggers count export energy until the next active charge slot only. For each trigger give a name, the minutes of export needed, and the energy required in that time. Multiple triggers can be enabled by Predbat at once so in total you could use too much energy if multiple triggered automations all run. Each trigger specified in apps.yaml will create a Home Assistant entity called 'binary_sensor.predbat_export_trigger_ name ' which will be turned on when the predicted trigger conditions are valid. Connect this binary sensor to your automation to start whatever you want to trigger. Set the name for each trigger, the number of minutes of solar export you need, and the amount of energy in kWh you will need available during that period in apps.yaml: For example: export_triggers: - name: \"large\" minutes: 60 energy: 1.0 - name: \"small\" minutes: 15 energy: 0.25 Note: Predbat will set an export trigger to True if in the plan it predicts that there will be more than the specified amount of excess solar energy over the specified time. In the example above, the 'large' trigger will be set to True for the 1-hour period where Predbat predicts that there will be a total of 1kWh of excess solar generation over that period . For clarity the trigger is not set based on actual excess solar generation or export. It should also be recognised that this prediction could be wrong; there could be less solar generation or more house load than was predicted in the plan. If you wish to trigger activities based on Predbat charging or discharging the battery rather than spare solar energy you can instead use the following binary sensors in Home Assistant: binary_sensor.predbat_charging - Will be True when the home battery is inside a charge slot (either being charged or being held at a level). Note that this does include charge freeze slots where the discharge rate is set to zero without charging the battery. binary_sensor.predbat_exporting - Will be True when the home battery is inside a force discharge slot. This does not include discharge freeze slots where the charge rate is set to zero to export excess solar only.","title":"Triggers"},{"location":"apps-yaml/#understanding-how-days_previous-works","text":"As described earlier, days_previous is a list of the previous days of historical house load that are averaged together to predict your future daily load. e.g., if you want the average of the same day for the last 2 weeks: days_previous: - 7 - 14 This section describes in more detail how days_previous is used by Predbat in creating the future battery plan, and gives some worked examples and a 'gotcha' to be aware of. When Predbat forecasts future home demand it counts backwards the days_previous number of days to find the appropriate historical home consumption. This is best explained through a worked example: In this example, days_previous is set to use history from 2 days ago: days_previous: - 2 If right now today it's Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 2 days from Tuesday so will use the historical home consumption from Sunday 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 2 days from that day, so will use historical home consumption from Monday 9am as being the Wednesday 9am prediction. This pattern of counting backwards days_previous days to find the appropriate time slot to load historical home consumption from requires Predbat to operate some additional special processing if days_previous is set to a low value or forecast_hours to a high value. Extending the previous example but this time days_previous is set to use history from just the previous day: days_previous: - 1 Today it's still Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 1 day from Tuesday so will use the historical home consumption from today's (Monday) 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 1 day from that day, so looks for historical home consumption from Tuesday 9am as being the Wednesday 9am prediction, but of course, it's still Monday, and Tuesday hasn't happened yet so we can't know what that historical consumption was! What Predbat does in this circumstance is to subtract a further day from days_previous and for Wednesday 9am's prediction, it will therefore use the historical load from Monday 9am. This issue of finding future historical load only occurs when days_previous is set to 1 and Predbat is forecasting more than 24 hours from 'now'. So to highlight this with some edge cases, today is still Monday 3:15pm, days_previous is still set to '1' and in the forward plan: For tomorrow's (Tuesday) 2:30pm slot, Predbat looks backwards 1 day from Tuesday and takes the historical home consumption from today's (Monday) 2:30pm slot. For tomorrow's (Tuesday) 3:00pm slot, Predbat looks backwards 1 day and takes the historical load from today's (Monday) 3:00pm slot - which we are only part way through so only 15 minutes of load will be predicted for tomorrow 3pm. For tomorrow's (Tuesday) 3:30pm slot, Predbat looks backwards 1 day but the 3:30pm slot today hasn't yet occurred so Predbat will take the historical load from the prior day and has to use Sunday's 3:30pm load for tomorrow's prediction. Ditto the predicted load for tomorrow's (Tuesday) 4:00pm slot comes from Sunday 4pm. As today rolls forward and Predbat keeps on updating the forward plan every 5 minutes the prediction will be updated with the correct previous_day history as and when it exists. It's recommended therefore that days_previous isn't set to 1, or if it is, that you understand the way this has to work and the consequences. If you want to set days_previous to take an average of the house load over all the days of the last week it's suggested that it be set as: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8","title":"Understanding how days_previous works"},{"location":"car-charging/","text":"Car charging As a bare minimum, a HA-controllable smart plug with a granny charger could be used, but do consider there could be an electrical spike to the car if the smart plug is turned off when the car is charging. A proper car charger and HA integration are preferable. You will first need to have installed the appropriate Home Assistant integration for your car charger. Configure apps.yaml for your car charging Start by configuring the Car charging settings in apps.yaml . Car Charging Planning There are two ways that Predbat can plan the slots for charging your car: If you have the Intelligent Octopus import tariff, have completed enrollment of your car/charger to Intelligent Octopus (requires a compatible charger or car), and you have installed the Octopus Energy integration - in which case Predbat will use the car charging slots allocated by Octopus Energy in battery prediction. The Octopus Energy integration supports Octopus Intelligent , and through that, Predbat gets most of the information it needs. octopus_intelligent_slot in apps.yaml is pre-configured with a regular expression to point to the Intelligent Slot sensor in the Octopus Energy integration. You should not need to change this, but it is worth checking the Predbat logfile to confirm that it has found your Octopus account details Set switch.predbat_octopus_intelligent_charging to True Information about the car's battery size will be automatically extracted from the Octopus Energy integration You should set the car's current SoC sensor, car_charging_soc in apps.yaml to point to a Home Assistant sensor that specifies the car's current % charge level to have accurate results. This should normally be a sensor provided by your car charger If you don't have this available for your charger then Predbat will assume the car's current charge level is 0% If you set car_charging_limit in apps.yaml then Predbat can also know if the car's limit is set lower than in Intelligent Octopus. If you don't set this Predbat will default to 100%. You can use car_charging_now as a workaround to indicate your car is charging but the Intelligent API hasn't reported it The switch switch.predbat_octopus_intelligent_consider_full ( expert mode ) when turned on will cause Predbat to predict when your car battery is full and assume no further charging will occur. This can be useful if Octopus does not know your car battery's state of charge but you have a sensor setup in Predbat ( car_charging_soc ) which does know the current charge level. Predbat will still assume all Octopus charging slots are low rates even if some are not used by your car. The default for this option is False. The switch switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) can be used to prevent Predbat from assuming the car will be charging or that future extra low-rate slots apply when the car is unplugged. This will only work correctly if car_charging_planned is set correctly in apps.yaml to detect your car being plugged in Let the Octopus app control when your car charges. TIP: If you have a Zappi EV charger then you have to set it to Eco+ mode for IOG to control it. If Predbat starts exporting your battery (e.g. prior to the IOG cheap overnight period) then the Zappi can treat the exported energy as excess solar and start charging the EV battery with it! To prevent this happening, in the Zappi configuration set the Export Margin to 8000W so that the Zappi will only charge the EV from excess solar when more than 8000W is being exported (which should never happen). Predbat-led charging - Here Predbat plans and can initiate the car charging based on the upcoming low import rate slots Ensure car_charging_limit , car_charging_soc and car_charging_planned are set correctly in apps.yaml to point to the appropriate sensors from your EV (see Car charging config in apps.yaml ) Check (and if necessary add) the sensor response value from the sensor configured in car_charging_planned that is returned when the car is 'plugged in and ready to charge' is in the list of car_charging_planned_response values configured in apps.yaml If your car does not have a state of charge (SoC) sensor you can set switch.predbat_car_charging_manual_soc to True to have Predbat create input_number.predbat_car_charging_manual_soc_kwh which will hold the cars SoC in kWh. You will need to manually set this to the car's current charge level before charging, Predbat will increment it during charging sessions but will not reset it automatically. NB: input_number.predbat_car_charging_manual_soc_kwh must be set to the current kWh value of your car battery NOT a percentage SoC figure otherwise, Predbat won't know how much energy there currently is in the battery. NB2: If you have car_charging_soc set and working for your car SoC sensor in apps.yaml, switch.predbat_car_charging_manual_soc must be set to Off as otherwise the car SoC sensor will be ignored Ensure switch.predbat_octopus_intelligent_charging in Home Assistant is set to Off Set input_number.predbat_car_charging_rate to the car's charging rate in kW per hour (e.g. 7.5 for 7.5kWh) If you have more than one car then input_number.predbat_car_charging_rate_1 will be the second car etc. Set select.predbat_car_charging_plan_time to the time you want the car charging to be completed by Turn on switch.predbat_car_charging_plan_smart if you want to use the cheapest slots only. When disabled (turned off) all low-rate slots will be used in time order You can set input_number.predbat_car_charging_plan_max_price if you want to set a maximum price in pence per kWh to charge your car (e.g. 10p). If you set this to zero, this feature is disabled, and all low-rate slots will be used. This may mean you need to use expert mode and change your low-rate threshold to configure which slots should be considered if you have a tariff with more than 2 import rates (e.g. Flux) WARNING: Do not set car_charging_now or you will create a circular dependency. Predbat will set binary_sensor.predbat_car_charging_slot when it determines the car can be charged; you will need to write a Home Assistant automation based on this sensor to control when your car charges. A sample automation to start/stop car charging using a Zappi car charger and the MyEnergi Zappi integration is as follows, this should be adapted for your charger type and how it controls starting/stopping car charging: alias: Car charging description: \"Start/stop car charging based on Predbat determined slots\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" sequence: <commands to turn on your car charger, e.g.> - service: select.select_option data: option: Eco+ target: entity_id: select.myenergi_zappi_charge_mode - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" sequence: <commands to turn off your car charger, e.g.> - service: select.select_option data: option: Stopped target: entity_id: select.myenergi_zappi_charge_mode mode: single NOTE: Multiple cars can be planned with Predbat. Additional Car charging configurations If you have one charger and multiple cars configured in Predbat then set car_charging_exclusive in apps.yaml to True to indicate that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False then it is assumed each car can charge independently and hence two or more could charge at once car_charging_exclusive: - True - True See Car charging filtering and Planned car charging in the apps.yaml settings section of the documentation. switch.predbat_car_charging_from_battery - When set to True the car can drain the home battery, Predbat will manage the correct level of battery accordingly. When set to False home battery discharge will be prevented when your car charges, and all load from the car and home will be from the grid. This is achieved by setting the battery discharge rate to 0 during car charging and to the maximum otherwise. The home battery can still charge from the grid/solar in either case. Only use this if Predbat knows your car charging plan, e.g. you are using Intelligent Octopus or you use the car slots in Predbat to control your car charging. input_number.predbat_car_charging_loss gives the percentage amount of energy lost when charging the car (load in the home vs energy added to the battery). A good setting is 0.08 which is 8%. Example EV and charger setup Sample setup and Predbat automation to use the cheapest charging slots with no/limited Home Assistant Integration. MG4 EV Vehicle with a Hypervolt Car Charger. There is no 3rd party integration with the MG (so no idea of the car's current SoC), and the Hypervolt car charger doesn't understand when an EV is plugged in. Yet it can be stopped and started with a 3rd party integration. In Home Assistant, create a helper entity (Settings / Devices & Services / Helpers) of type 'Number' and set 'Unit of Measurement' to 'kWh': Car Max Charge - input_number.car_max_charge Create a 'Dropdown' helper entity that has two options 'true' and 'false' (in lowercase): Car Charger Plugged in - input_select.car_charger_plugged_in Within the apps.yaml configuration file specify the following configuration settings: Find the line for car_charger_battery_size and enter the Car Battery Size in kWh: Example car_charging_battery_size: - 61.7 Specify the Car Charging Limit to use the Car Max Charge helper entity created earlier: car_charging_limit: - 'input_number.car_max_charge' Find car_charging_planned and replace the template Wallbox and Zappi regular expression with your new dropdown helper entity: car_charging_planned: - 'input_select.car_charger_plugged_in' Find car_charging_planned_response and add 'true' to the list: car_charging_planned_response: - 'yes' - 'on' - 'true' If possible, add an entity keeping track of the kWh used for car charging to car_charging_energy . If your charging device doesn't keep track of kWh you can measure the power sent to the car charger (e.g. from the EV charger integration or an energy monitor/smart plug for the EV charger) then you can create another helper entity to convert kW power into kWh: Create a helper entity (Settings / Devices & Services / Helpers) of type 'Integration - Riemann Sum integral': Name : car_energy_used Input sensor : sensor that measures power consumed by the car charger Integration method : Right Riemann sum Metric prefix : k (kilo) Please look into Integration - Riemann sum integral to convert kW into kWh. And add your custom car charging energy sensor in apps.yaml in place of the template Wallbox and Zappi regular expression: Example car_charging_energy: 'sensor.car_energy_used' car_charging_now must be commented out (hashed out) in apps.yaml : #car_charging_now: # - off Save the apps.yaml file and exit. In Home Assistant, turn on the following Predbat control switches: switch.predbat_car_charging_hold switch.predbat_car_charging_manual_soc switch.predbat_car_charging_plan_smart And turn off the Predbat control switch: switch.predbat_octopus_intelligent_charging HA Charging Slot Automation In Home Assistant (Settings / Automation & Scenes), create an automation to monitor the Predbat car charging slot sensor and turn the charger on and off according to the Predbat plan (the numeric entity id's below would need replacing with the appropriate sensor name for your car charger): alias: Car Charging Slot description: \"\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" then: - type: turn_off entity_id: f6de2df0758744aba60f6b5f domain: switch - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" then: - type: turn_on entity_id: f6de2df0758744aba60f6b5f domain: switch mode: single Finally, for simplicity, add the below entities to your HA Dashboard so you can set them when needed: Car Max Charge - input_number.car_max_charge Car Manual SoC - input_number.predbat_car_charging_manual_soc_kwh Car Charger Plugged in - input_select.car_charger_plugged_in Annoyingly, you have to calculate the kWh your vehicle has in total by taking the Percentage left in the car / 100 * Total Car Battery capacity. For example: 65/100*61.7=40.1 Enter '40.1' into 'Car Manual SoC' and '80%' into 'Car Max charge'. Once the charger is switched to true and your Car Max charge (target SoC) % is higher than the kWh currently in the car, Predbat will plan and charge the car with the kW that are needed to reach the target SoC.","title":"Car charging"},{"location":"car-charging/#car-charging","text":"As a bare minimum, a HA-controllable smart plug with a granny charger could be used, but do consider there could be an electrical spike to the car if the smart plug is turned off when the car is charging. A proper car charger and HA integration are preferable. You will first need to have installed the appropriate Home Assistant integration for your car charger.","title":"Car charging"},{"location":"car-charging/#configure-appsyaml-for-your-car-charging","text":"Start by configuring the Car charging settings in apps.yaml .","title":"Configure apps.yaml for your car charging"},{"location":"car-charging/#car-charging-planning","text":"There are two ways that Predbat can plan the slots for charging your car: If you have the Intelligent Octopus import tariff, have completed enrollment of your car/charger to Intelligent Octopus (requires a compatible charger or car), and you have installed the Octopus Energy integration - in which case Predbat will use the car charging slots allocated by Octopus Energy in battery prediction. The Octopus Energy integration supports Octopus Intelligent , and through that, Predbat gets most of the information it needs. octopus_intelligent_slot in apps.yaml is pre-configured with a regular expression to point to the Intelligent Slot sensor in the Octopus Energy integration. You should not need to change this, but it is worth checking the Predbat logfile to confirm that it has found your Octopus account details Set switch.predbat_octopus_intelligent_charging to True Information about the car's battery size will be automatically extracted from the Octopus Energy integration You should set the car's current SoC sensor, car_charging_soc in apps.yaml to point to a Home Assistant sensor that specifies the car's current % charge level to have accurate results. This should normally be a sensor provided by your car charger If you don't have this available for your charger then Predbat will assume the car's current charge level is 0% If you set car_charging_limit in apps.yaml then Predbat can also know if the car's limit is set lower than in Intelligent Octopus. If you don't set this Predbat will default to 100%. You can use car_charging_now as a workaround to indicate your car is charging but the Intelligent API hasn't reported it The switch switch.predbat_octopus_intelligent_consider_full ( expert mode ) when turned on will cause Predbat to predict when your car battery is full and assume no further charging will occur. This can be useful if Octopus does not know your car battery's state of charge but you have a sensor setup in Predbat ( car_charging_soc ) which does know the current charge level. Predbat will still assume all Octopus charging slots are low rates even if some are not used by your car. The default for this option is False. The switch switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) can be used to prevent Predbat from assuming the car will be charging or that future extra low-rate slots apply when the car is unplugged. This will only work correctly if car_charging_planned is set correctly in apps.yaml to detect your car being plugged in Let the Octopus app control when your car charges. TIP: If you have a Zappi EV charger then you have to set it to Eco+ mode for IOG to control it. If Predbat starts exporting your battery (e.g. prior to the IOG cheap overnight period) then the Zappi can treat the exported energy as excess solar and start charging the EV battery with it! To prevent this happening, in the Zappi configuration set the Export Margin to 8000W so that the Zappi will only charge the EV from excess solar when more than 8000W is being exported (which should never happen). Predbat-led charging - Here Predbat plans and can initiate the car charging based on the upcoming low import rate slots Ensure car_charging_limit , car_charging_soc and car_charging_planned are set correctly in apps.yaml to point to the appropriate sensors from your EV (see Car charging config in apps.yaml ) Check (and if necessary add) the sensor response value from the sensor configured in car_charging_planned that is returned when the car is 'plugged in and ready to charge' is in the list of car_charging_planned_response values configured in apps.yaml If your car does not have a state of charge (SoC) sensor you can set switch.predbat_car_charging_manual_soc to True to have Predbat create input_number.predbat_car_charging_manual_soc_kwh which will hold the cars SoC in kWh. You will need to manually set this to the car's current charge level before charging, Predbat will increment it during charging sessions but will not reset it automatically. NB: input_number.predbat_car_charging_manual_soc_kwh must be set to the current kWh value of your car battery NOT a percentage SoC figure otherwise, Predbat won't know how much energy there currently is in the battery. NB2: If you have car_charging_soc set and working for your car SoC sensor in apps.yaml, switch.predbat_car_charging_manual_soc must be set to Off as otherwise the car SoC sensor will be ignored Ensure switch.predbat_octopus_intelligent_charging in Home Assistant is set to Off Set input_number.predbat_car_charging_rate to the car's charging rate in kW per hour (e.g. 7.5 for 7.5kWh) If you have more than one car then input_number.predbat_car_charging_rate_1 will be the second car etc. Set select.predbat_car_charging_plan_time to the time you want the car charging to be completed by Turn on switch.predbat_car_charging_plan_smart if you want to use the cheapest slots only. When disabled (turned off) all low-rate slots will be used in time order You can set input_number.predbat_car_charging_plan_max_price if you want to set a maximum price in pence per kWh to charge your car (e.g. 10p). If you set this to zero, this feature is disabled, and all low-rate slots will be used. This may mean you need to use expert mode and change your low-rate threshold to configure which slots should be considered if you have a tariff with more than 2 import rates (e.g. Flux) WARNING: Do not set car_charging_now or you will create a circular dependency. Predbat will set binary_sensor.predbat_car_charging_slot when it determines the car can be charged; you will need to write a Home Assistant automation based on this sensor to control when your car charges. A sample automation to start/stop car charging using a Zappi car charger and the MyEnergi Zappi integration is as follows, this should be adapted for your charger type and how it controls starting/stopping car charging: alias: Car charging description: \"Start/stop car charging based on Predbat determined slots\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" sequence: <commands to turn on your car charger, e.g.> - service: select.select_option data: option: Eco+ target: entity_id: select.myenergi_zappi_charge_mode - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" sequence: <commands to turn off your car charger, e.g.> - service: select.select_option data: option: Stopped target: entity_id: select.myenergi_zappi_charge_mode mode: single NOTE: Multiple cars can be planned with Predbat.","title":"Car Charging Planning"},{"location":"car-charging/#additional-car-charging-configurations","text":"If you have one charger and multiple cars configured in Predbat then set car_charging_exclusive in apps.yaml to True to indicate that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False then it is assumed each car can charge independently and hence two or more could charge at once car_charging_exclusive: - True - True See Car charging filtering and Planned car charging in the apps.yaml settings section of the documentation. switch.predbat_car_charging_from_battery - When set to True the car can drain the home battery, Predbat will manage the correct level of battery accordingly. When set to False home battery discharge will be prevented when your car charges, and all load from the car and home will be from the grid. This is achieved by setting the battery discharge rate to 0 during car charging and to the maximum otherwise. The home battery can still charge from the grid/solar in either case. Only use this if Predbat knows your car charging plan, e.g. you are using Intelligent Octopus or you use the car slots in Predbat to control your car charging. input_number.predbat_car_charging_loss gives the percentage amount of energy lost when charging the car (load in the home vs energy added to the battery). A good setting is 0.08 which is 8%.","title":"Additional Car charging configurations"},{"location":"car-charging/#example-ev-and-charger-setup","text":"Sample setup and Predbat automation to use the cheapest charging slots with no/limited Home Assistant Integration. MG4 EV Vehicle with a Hypervolt Car Charger. There is no 3rd party integration with the MG (so no idea of the car's current SoC), and the Hypervolt car charger doesn't understand when an EV is plugged in. Yet it can be stopped and started with a 3rd party integration. In Home Assistant, create a helper entity (Settings / Devices & Services / Helpers) of type 'Number' and set 'Unit of Measurement' to 'kWh': Car Max Charge - input_number.car_max_charge Create a 'Dropdown' helper entity that has two options 'true' and 'false' (in lowercase): Car Charger Plugged in - input_select.car_charger_plugged_in Within the apps.yaml configuration file specify the following configuration settings: Find the line for car_charger_battery_size and enter the Car Battery Size in kWh: Example car_charging_battery_size: - 61.7 Specify the Car Charging Limit to use the Car Max Charge helper entity created earlier: car_charging_limit: - 'input_number.car_max_charge' Find car_charging_planned and replace the template Wallbox and Zappi regular expression with your new dropdown helper entity: car_charging_planned: - 'input_select.car_charger_plugged_in' Find car_charging_planned_response and add 'true' to the list: car_charging_planned_response: - 'yes' - 'on' - 'true' If possible, add an entity keeping track of the kWh used for car charging to car_charging_energy . If your charging device doesn't keep track of kWh you can measure the power sent to the car charger (e.g. from the EV charger integration or an energy monitor/smart plug for the EV charger) then you can create another helper entity to convert kW power into kWh: Create a helper entity (Settings / Devices & Services / Helpers) of type 'Integration - Riemann Sum integral': Name : car_energy_used Input sensor : sensor that measures power consumed by the car charger Integration method : Right Riemann sum Metric prefix : k (kilo) Please look into Integration - Riemann sum integral to convert kW into kWh. And add your custom car charging energy sensor in apps.yaml in place of the template Wallbox and Zappi regular expression: Example car_charging_energy: 'sensor.car_energy_used' car_charging_now must be commented out (hashed out) in apps.yaml : #car_charging_now: # - off Save the apps.yaml file and exit. In Home Assistant, turn on the following Predbat control switches: switch.predbat_car_charging_hold switch.predbat_car_charging_manual_soc switch.predbat_car_charging_plan_smart And turn off the Predbat control switch: switch.predbat_octopus_intelligent_charging HA Charging Slot Automation In Home Assistant (Settings / Automation & Scenes), create an automation to monitor the Predbat car charging slot sensor and turn the charger on and off according to the Predbat plan (the numeric entity id's below would need replacing with the appropriate sensor name for your car charger): alias: Car Charging Slot description: \"\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" then: - type: turn_off entity_id: f6de2df0758744aba60f6b5f domain: switch - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" then: - type: turn_on entity_id: f6de2df0758744aba60f6b5f domain: switch mode: single Finally, for simplicity, add the below entities to your HA Dashboard so you can set them when needed: Car Max Charge - input_number.car_max_charge Car Manual SoC - input_number.predbat_car_charging_manual_soc_kwh Car Charger Plugged in - input_select.car_charger_plugged_in Annoyingly, you have to calculate the kWh your vehicle has in total by taking the Percentage left in the car / 100 * Total Car Battery capacity. For example: 65/100*61.7=40.1 Enter '40.1' into 'Car Manual SoC' and '80%' into 'Car Max charge'. Once the charger is switched to true and your Car Max charge (target SoC) % is higher than the kWh currently in the car, Predbat will plan and charge the car with the kW that are needed to reach the target SoC.","title":"Example EV and charger setup"},{"location":"caution/","text":"Some words of caution Predbat is a powerful hobbyist system that can control many home battery and solar systems. While every attempt has been made to make it as easy to use as possible, it does require a certain amount of technical skill. Increased energy costs While Predbat will normally save you money, an incorrectly configured system can cause your battery to be poorly managed and may increase your electricity bills. I recommend carefully reviewing what your installation is doing once you have enabled it for the first time. Flash memory Some inverters use flash memory with a limited lifespan. Depending on how register writes are managed, the controller can reduce this lifespan. In normal operation, this should not be an issue, but if your setup performs a large number of register writes continuously, you could eventually encounter problems. For example, on a current GivEnergy inverter, it's estimated that the usable limit is around 1 million register writes (although firmware changes may increase this limit). This would allow approximately 270 writes per day, or one every 5 minutes. Each change of inverter mode requires multiple register writes \u2014 e.g. charge start time, end time, scheduled charge enable, set battery pause mode, etc. \u2014 which could total around 6 registers. This means one change of mode every 30 minutes, on average, would be acceptable. However, as most plans include longer intervals (often hours) where the battery is in Demand mode, Charging, or Exporting \u2014 during which registers are not updated \u2014 it is unlikely that this limit will be exceeded. As different inverter designs may have different limits, it's wise to avoid making your plan too complex if it doesn't result in meaningful gains. Things you can do to have a less complex plan include: Keep 'calculate export within charge slots' off Set metric battery cycle to a small non-zero value e.g. 0.5 Set a metric min improvement export to a small value e.g. 5p Ensure inverter losses are set to a representative value Turn off charge_low_power mode Avoid using balance inverters ('switch.predbat_balance_inverters_enable') which can make register changes once or twice a minute unless you are sure this is not an issue Predbat creates an entity called predbat.inverter_register_writes which can be used to check the total number of writes across all inverters. If you divide this by the period of use and by the number of inverters, you will be able to figure out the actual rate of register writes - see the Simple inverter writes dashboard .","title":"Words of caution"},{"location":"caution/#some-words-of-caution","text":"Predbat is a powerful hobbyist system that can control many home battery and solar systems. While every attempt has been made to make it as easy to use as possible, it does require a certain amount of technical skill.","title":"Some words of caution"},{"location":"caution/#increased-energy-costs","text":"While Predbat will normally save you money, an incorrectly configured system can cause your battery to be poorly managed and may increase your electricity bills. I recommend carefully reviewing what your installation is doing once you have enabled it for the first time.","title":"Increased energy costs"},{"location":"caution/#flash-memory","text":"Some inverters use flash memory with a limited lifespan. Depending on how register writes are managed, the controller can reduce this lifespan. In normal operation, this should not be an issue, but if your setup performs a large number of register writes continuously, you could eventually encounter problems. For example, on a current GivEnergy inverter, it's estimated that the usable limit is around 1 million register writes (although firmware changes may increase this limit). This would allow approximately 270 writes per day, or one every 5 minutes. Each change of inverter mode requires multiple register writes \u2014 e.g. charge start time, end time, scheduled charge enable, set battery pause mode, etc. \u2014 which could total around 6 registers. This means one change of mode every 30 minutes, on average, would be acceptable. However, as most plans include longer intervals (often hours) where the battery is in Demand mode, Charging, or Exporting \u2014 during which registers are not updated \u2014 it is unlikely that this limit will be exceeded. As different inverter designs may have different limits, it's wise to avoid making your plan too complex if it doesn't result in meaningful gains. Things you can do to have a less complex plan include: Keep 'calculate export within charge slots' off Set metric battery cycle to a small non-zero value e.g. 0.5 Set a metric min improvement export to a small value e.g. 5p Ensure inverter losses are set to a representative value Turn off charge_low_power mode Avoid using balance inverters ('switch.predbat_balance_inverters_enable') which can make register changes once or twice a minute unless you are sure this is not an issue Predbat creates an entity called predbat.inverter_register_writes which can be used to check the total number of writes across all inverters. If you divide this by the period of use and by the number of inverters, you will be able to figure out the actual rate of register writes - see the Simple inverter writes dashboard .","title":"Flash memory"},{"location":"compare/","text":"Comparing Energy Tariffs While it is quite easy to go off and compare your historical usage against various energy tariffs with existing apps, it is much harder to perform a what-if analysis as the way you control your battery would be different depending on the tariff. For this reason, Predbat offers an energy rate comparison to allow you to know if you are on the best available tariff or when it might be time to switch. Once you have given Predbat a list of tariffs that you want to compare then it will update its predictions daily and keep a history of these over time. If you do decide to switch to Octopus Energy after using this feature please consider using my referral link so we can both save some money: https://share.octopus.energy/jolly-eel-176 Its recommended to watch the YouTube video on Energy tariff comparison as this explains the feature in more detail and what the different columns of the comparison mean. Limitations Keep in mind this is an approximation of costs for the following 24-hour period and the reality could be different. In particular, car charging costs are unlikely to reflect the true picture as it will only be planned after you plug in. Smart tariffs like Octopus Intelligent Go can give you extra cheap car slots, and Octopus Intelligent Flux where Octopus controls the charging/discharging, mean these tariffs cannot be predicted as accurately. When changing tariffs, you should use your judgment, the Predbat Compare data is only a helpful guide. Configuring the tariff's to compare First, you need to tell Predbat in apps.yaml which tariffs you want to compare, you should list all the tariffs you realistically might want to switch between, including your current tariff to act as a baseline. Below is a suggestion of various Octopus tariff combinations (valid Feb 2025) against region A. You will need to change dno_region to match your region code if you decide to use this template - see list of Electricity region codes . As well as Octopus rate URLs (rates_import_octopus_url/rates_export_octopus_url) you can use manual rates (rates_import/rates_export), Octopus integration rates (metric_octopus_import/metric_octopus_export) and Energi Data service rates (metric_energidataservice_import/metric_energidataservice_export). Each tariff must be given an ID which will be used to create a sensor to track predicted cost over time, the full name is used in the description of that sensor and on the web page. The ID can contain alphanumeric characters or underscores; do not use slashes, commas, spaces or other special characters in the ID or predbat will crash when running the compare! If you do not set an import or export rate for a particular tariff then your existing energy rates will be used. # Tariff comparison feature # # Adjust this list to the tariffs you want to compare, include your current tariff also # DNO region code (see https://energy-stats.uk/dno-region-codes-explained/) dno_region: \"A\" compare_list: - id: 'current' name: 'Current Tariff' - id: 'cap_seg' name: 'Price cap import/SEG export' rates_import: - rate: 24.86 rates_export: - rate: 4.1 - id: 'eon_next_drive' name: 'Eon Next Drive import/Fixed export\"' rates_import: - rate: 6.7 start: \"00:00:00\" end: \"07:00:00\" - rate: 24.86 start: \"07:00:00\" end: \"24:00:00\" rates_export: - rate: 16.5 - id: 'igo_fixed' name: 'Intelligent GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-BB-VAR-23-03-01/electricity-tariffs/E-1R-INTELLI-BB-VAR-23-03-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'igo_agile' name: 'Intelligent GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-BB-VAR-23-03-01/electricity-tariffs/E-1R-INTELLI-BB-VAR-23-03-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'go_fixed' name: 'GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-BB-23-02-07/electricity-tariffs/E-1R-GO-VAR-BB-23-02-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'go_agile' name: 'GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-BB-23-02-07/electricity-tariffs/E-1R-GO-VAR-BB-23-02-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'agile_fixed' name: 'Agile import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'agile_agile' name: 'Agile import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'flux' name: 'Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-{dno_region}/standard-unit-rates' - id: 'cosy_fixed' name: 'Cosy import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'cosy_agile' name: 'Cosy import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'snug_fixed' name: 'Snug import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/SNUG-24-11-07/electricity-tariffs/E-1R-SNUG-24-11-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'iflux' name: 'Intelligent Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-IMPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-IMPORT-23-07-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-EXPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-EXPORT-23-07-14-{dno_region}/standard-unit-rates/' Running a comparison By default, the comparison will be run at Midnight every night and saved for the entire day. You can view the comparison on the Predbat web interface under the 'Compare' view. You can manually trigger a new comparison by hitting the 'Compare now' button, or by turning on switch.predbat_compare_active . When a compare is running switch.predbat_compare_active will be turned on, otherwise it will be off. Predbat will highlight which tariff may be the best cost-wise for the next 24-hour period based on the plan optimisation metrics you have defined. The metric includes the value of the contents of your battery and iBoost that has been diverted during this period. The predicted cost is also shown, but keep in mind ending the day with an empty battery may be cheaper today but cost more tomorrow. Comparison sensors For each tariff a new sensor is created in Home Assistant called predbat.compare_tariff_id where id is the ID name you entered above in apps.yaml. This sensor will track the cost as its main value and many details about the prediction in its attributes. You can create charts from these sensors to show how the different tariffs compare on a daily basis.","title":"Comparing Energy Tariffs"},{"location":"compare/#comparing-energy-tariffs","text":"While it is quite easy to go off and compare your historical usage against various energy tariffs with existing apps, it is much harder to perform a what-if analysis as the way you control your battery would be different depending on the tariff. For this reason, Predbat offers an energy rate comparison to allow you to know if you are on the best available tariff or when it might be time to switch. Once you have given Predbat a list of tariffs that you want to compare then it will update its predictions daily and keep a history of these over time. If you do decide to switch to Octopus Energy after using this feature please consider using my referral link so we can both save some money: https://share.octopus.energy/jolly-eel-176 Its recommended to watch the YouTube video on Energy tariff comparison as this explains the feature in more detail and what the different columns of the comparison mean.","title":"Comparing Energy Tariffs"},{"location":"compare/#limitations","text":"Keep in mind this is an approximation of costs for the following 24-hour period and the reality could be different. In particular, car charging costs are unlikely to reflect the true picture as it will only be planned after you plug in. Smart tariffs like Octopus Intelligent Go can give you extra cheap car slots, and Octopus Intelligent Flux where Octopus controls the charging/discharging, mean these tariffs cannot be predicted as accurately. When changing tariffs, you should use your judgment, the Predbat Compare data is only a helpful guide.","title":"Limitations"},{"location":"compare/#configuring-the-tariffs-to-compare","text":"First, you need to tell Predbat in apps.yaml which tariffs you want to compare, you should list all the tariffs you realistically might want to switch between, including your current tariff to act as a baseline. Below is a suggestion of various Octopus tariff combinations (valid Feb 2025) against region A. You will need to change dno_region to match your region code if you decide to use this template - see list of Electricity region codes . As well as Octopus rate URLs (rates_import_octopus_url/rates_export_octopus_url) you can use manual rates (rates_import/rates_export), Octopus integration rates (metric_octopus_import/metric_octopus_export) and Energi Data service rates (metric_energidataservice_import/metric_energidataservice_export). Each tariff must be given an ID which will be used to create a sensor to track predicted cost over time, the full name is used in the description of that sensor and on the web page. The ID can contain alphanumeric characters or underscores; do not use slashes, commas, spaces or other special characters in the ID or predbat will crash when running the compare! If you do not set an import or export rate for a particular tariff then your existing energy rates will be used. # Tariff comparison feature # # Adjust this list to the tariffs you want to compare, include your current tariff also # DNO region code (see https://energy-stats.uk/dno-region-codes-explained/) dno_region: \"A\" compare_list: - id: 'current' name: 'Current Tariff' - id: 'cap_seg' name: 'Price cap import/SEG export' rates_import: - rate: 24.86 rates_export: - rate: 4.1 - id: 'eon_next_drive' name: 'Eon Next Drive import/Fixed export\"' rates_import: - rate: 6.7 start: \"00:00:00\" end: \"07:00:00\" - rate: 24.86 start: \"07:00:00\" end: \"24:00:00\" rates_export: - rate: 16.5 - id: 'igo_fixed' name: 'Intelligent GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-BB-VAR-23-03-01/electricity-tariffs/E-1R-INTELLI-BB-VAR-23-03-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'igo_agile' name: 'Intelligent GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-BB-VAR-23-03-01/electricity-tariffs/E-1R-INTELLI-BB-VAR-23-03-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'go_fixed' name: 'GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-BB-23-02-07/electricity-tariffs/E-1R-GO-VAR-BB-23-02-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'go_agile' name: 'GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-BB-23-02-07/electricity-tariffs/E-1R-GO-VAR-BB-23-02-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'agile_fixed' name: 'Agile import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'agile_agile' name: 'Agile import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'flux' name: 'Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-{dno_region}/standard-unit-rates' - id: 'cosy_fixed' name: 'Cosy import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'cosy_agile' name: 'Cosy import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-{dno_region}/standard-unit-rates/' - id: 'snug_fixed' name: 'Snug import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/SNUG-24-11-07/electricity-tariffs/E-1R-SNUG-24-11-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-BB-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-BB-24-10-26-{dno_region}/standard-unit-rates/' - id: 'iflux' name: 'Intelligent Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-IMPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-IMPORT-23-07-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-EXPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-EXPORT-23-07-14-{dno_region}/standard-unit-rates/'","title":"Configuring the tariff's to compare"},{"location":"compare/#running-a-comparison","text":"By default, the comparison will be run at Midnight every night and saved for the entire day. You can view the comparison on the Predbat web interface under the 'Compare' view. You can manually trigger a new comparison by hitting the 'Compare now' button, or by turning on switch.predbat_compare_active . When a compare is running switch.predbat_compare_active will be turned on, otherwise it will be off. Predbat will highlight which tariff may be the best cost-wise for the next 24-hour period based on the plan optimisation metrics you have defined. The metric includes the value of the contents of your battery and iBoost that has been diverted during this period. The predicted cost is also shown, but keep in mind ending the day with an empty battery may be cheaper today but cost more tomorrow.","title":"Running a comparison"},{"location":"compare/#comparison-sensors","text":"For each tariff a new sensor is created in Home Assistant called predbat.compare_tariff_id where id is the ID name you entered above in apps.yaml. This sensor will track the cost as its main value and many details about the prediction in its attributes. You can create charts from these sensors to show how the different tariffs compare on a daily basis.","title":"Comparison sensors"},{"location":"configuration-guide/","text":"Configuration guide First, get the basics set up, ensure you have the inverter controls configured , you have configured apps.yaml to your setup, and the solar forecast is in place. Make sure your energy rates are configured correctly for import and export. If you have an EV try to set up the car charging sensor correctly so Predbat can tell what part of your historical load is EV charging. You might want to also set the car charging plan so you can predict when your car is plugged in and how much it will charge. It is recommended that you create a dashboard page with all the required entities to control Predbat. This page gives a summary of some of the key configuration settings you should consider in Predbat for different energy tariffs; the Predbat customisation guide details all the Predbat customisation options. You should try to tune input_number.predbat_inverter_loss , input_number.predbat_battery_loss and input_number.predbat_battery_loss_discharge to the correct % loss for your system to get more accurate predictions. Around 4% for each is good for a hybrid inverter. For a Hybrid inverter, the inverter loss includes the loss on inverting PV as well as going from AC to DC when importing. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. For an AC coupled inverter the inverter loss is just the loss of the battery inverter, if you need to model the loss of your PV inverter then use input_number.predbat_pv_scaling or adjust your Solcast output. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. Also, set switch.predbat_inverter_hybrid to True or False depending upon if you have a Hybrid or AC-Coupled battery. The setting input_number.predbat_metric_battery_cycle ( expert mode ) can be used to put a 'virtual cost' in pence per kWh on using your battery for charging and discharging. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. The default is 0.5p (meaning charging and discharging the battery would effectively cost an extra 1p per kWh) but can be set to 0 if you want to turn this feature off. Below is a guide to some of the electricity tariff options and a set of recommended Predbat settings for each tariff type. In theory, most tariffs will work out of the box but still, it's worth reviewing your settings. Fixed daily rates With a fixed daily rate tariff you will just be predicting the battery levels, no charging or discharging is required although it won't hurt if you leave these options enabled. You should set select.predbat_mode to 'Monitor'. Cheap night rate with a bad export rate (e.g. Economy 7 with SEG) In this scenario, you will want to charge overnight based on the next day's solar forecast and don't want Predbat to force export (discharge) your battery. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge You want Predbat to calculate and control charging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit You should set select.predbat_mode to 'Control charge' Cheap night rate, with a good export rate (e.g. Go or Intelligent Octopus Go with Octopus Outgoing) Follow the instructions from the Cheap Night rate above, but you will also want to have automatic export occurring when the export rates are profitable. Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Can be set to non-zero if you want to force a minimum charge level You should set select.predbat_mode to 'Control charge & discharge' You may wish to use rates_export_override to override the night export rate to zero or turn off calculate_export_during_charge and turn on combine_charge . Either of these options will prevent charge / discharge cycling within the cheap period, which Predbat would see as economically sensible but may not be within terms of use for some tariffs. With the overnight charging rate being cheaper than your export rate, you probably want to charge your EV overnight and export all your solar; and not charge the EV from Solar during the day. Settings for doing this vary by charger manufacturer, but for the Zappi charger, set export margin to a value higher than your inverter can output (e.g. 6000W) to ensure that all solar is exported and not used to charge the EV. Multiple rates for import and export (e.g. Octopus Flux & Cozy) Follow the instructions from the Cheap Night rate above, but also you will want to have automatic export when the export rates are profitable. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge' Half hourly variable rates (e.g. Octopus Agile) Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24-48 If you set this to 24 then you will have quicker updates, going to 36/48 for a longer plan input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Configuration guide"},{"location":"configuration-guide/#configuration-guide","text":"First, get the basics set up, ensure you have the inverter controls configured , you have configured apps.yaml to your setup, and the solar forecast is in place. Make sure your energy rates are configured correctly for import and export. If you have an EV try to set up the car charging sensor correctly so Predbat can tell what part of your historical load is EV charging. You might want to also set the car charging plan so you can predict when your car is plugged in and how much it will charge. It is recommended that you create a dashboard page with all the required entities to control Predbat. This page gives a summary of some of the key configuration settings you should consider in Predbat for different energy tariffs; the Predbat customisation guide details all the Predbat customisation options. You should try to tune input_number.predbat_inverter_loss , input_number.predbat_battery_loss and input_number.predbat_battery_loss_discharge to the correct % loss for your system to get more accurate predictions. Around 4% for each is good for a hybrid inverter. For a Hybrid inverter, the inverter loss includes the loss on inverting PV as well as going from AC to DC when importing. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. For an AC coupled inverter the inverter loss is just the loss of the battery inverter, if you need to model the loss of your PV inverter then use input_number.predbat_pv_scaling or adjust your Solcast output. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. Also, set switch.predbat_inverter_hybrid to True or False depending upon if you have a Hybrid or AC-Coupled battery. The setting input_number.predbat_metric_battery_cycle ( expert mode ) can be used to put a 'virtual cost' in pence per kWh on using your battery for charging and discharging. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. The default is 0.5p (meaning charging and discharging the battery would effectively cost an extra 1p per kWh) but can be set to 0 if you want to turn this feature off. Below is a guide to some of the electricity tariff options and a set of recommended Predbat settings for each tariff type. In theory, most tariffs will work out of the box but still, it's worth reviewing your settings.","title":"Configuration guide"},{"location":"configuration-guide/#fixed-daily-rates","text":"With a fixed daily rate tariff you will just be predicting the battery levels, no charging or discharging is required although it won't hurt if you leave these options enabled. You should set select.predbat_mode to 'Monitor'.","title":"Fixed daily rates"},{"location":"configuration-guide/#cheap-night-rate-with-a-bad-export-rate-eg-economy-7-with-seg","text":"In this scenario, you will want to charge overnight based on the next day's solar forecast and don't want Predbat to force export (discharge) your battery. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge You want Predbat to calculate and control charging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit You should set select.predbat_mode to 'Control charge'","title":"Cheap night rate with a bad export rate (e.g. Economy 7 with SEG)"},{"location":"configuration-guide/#cheap-night-rate-with-a-good-export-rate-eg-go-or-intelligent-octopus-go-with-octopus-outgoing","text":"Follow the instructions from the Cheap Night rate above, but you will also want to have automatic export occurring when the export rates are profitable. Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Can be set to non-zero if you want to force a minimum charge level You should set select.predbat_mode to 'Control charge & discharge' You may wish to use rates_export_override to override the night export rate to zero or turn off calculate_export_during_charge and turn on combine_charge . Either of these options will prevent charge / discharge cycling within the cheap period, which Predbat would see as economically sensible but may not be within terms of use for some tariffs. With the overnight charging rate being cheaper than your export rate, you probably want to charge your EV overnight and export all your solar; and not charge the EV from Solar during the day. Settings for doing this vary by charger manufacturer, but for the Zappi charger, set export margin to a value higher than your inverter can output (e.g. 6000W) to ensure that all solar is exported and not used to charge the EV.","title":"Cheap night rate, with a good export rate (e.g. Go or Intelligent Octopus Go with Octopus Outgoing)"},{"location":"configuration-guide/#multiple-rates-for-import-and-export-eg-octopus-flux-cozy","text":"Follow the instructions from the Cheap Night rate above, but also you will want to have automatic export when the export rates are profitable. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Multiple rates for import and export (e.g. Octopus Flux &amp; Cozy)"},{"location":"configuration-guide/#half-hourly-variable-rates-eg-octopus-agile","text":"Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24-48 If you set this to 24 then you will have quicker updates, going to 36/48 for a longer plan input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Half hourly variable rates (e.g. Octopus Agile)"},{"location":"creating-charts/","text":"Creating the charts There are a number of fancy Apex charts that can be produced from Predbat data - things like Home Battery SoC prediction, Cost prediction, Energy Rates, etc. There's a Video Guide to the different charts available on YouTube. To install the charts: Install Apex Charts https://github.com/RomRider/apexcharts-card : In HACS, click on Frontend Click the blue Explore and download repositories button and type 'apex' Click on 'apexcharts-card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' Next, on a Home Assistant dashboard you create the charts you want. There are multiple charts, for each section of the example chart yaml file , create a new apexcharts card and copy the YAML into it: Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Custom: ApexCharts card' Delete the template card configuration and copy/paste ONE Apex chart from the example file Click 'Save' Repeat (adding Apex chart card, copy paste card config) for all of the charts you want to see Customise as you like If you get an error 'Custom element doesn't exist: apexcharts-card' then you've not installed the Apex Charts card correctly from HACS. See the video guides for a walkthrough of what the different charts show. Example charts:","title":"Creating the charts"},{"location":"creating-charts/#creating-the-charts","text":"There are a number of fancy Apex charts that can be produced from Predbat data - things like Home Battery SoC prediction, Cost prediction, Energy Rates, etc. There's a Video Guide to the different charts available on YouTube. To install the charts: Install Apex Charts https://github.com/RomRider/apexcharts-card : In HACS, click on Frontend Click the blue Explore and download repositories button and type 'apex' Click on 'apexcharts-card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' Next, on a Home Assistant dashboard you create the charts you want. There are multiple charts, for each section of the example chart yaml file , create a new apexcharts card and copy the YAML into it: Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Custom: ApexCharts card' Delete the template card configuration and copy/paste ONE Apex chart from the example file Click 'Save' Repeat (adding Apex chart card, copy paste card config) for all of the charts you want to see Customise as you like If you get an error 'Custom element doesn't exist: apexcharts-card' then you've not installed the Apex Charts card correctly from HACS. See the video guides for a walkthrough of what the different charts show. Example charts:","title":"Creating the charts"},{"location":"customisation/","text":"Customisation This document describes the Predbat configuration items in Home Assistant that you can modify to customise Predbat to fit your needs. All of these settings are entities that can be configured directly in Home Assistant (unlike the ' apps.yaml ' configuration items that have to be edited with a file editor). See Displaying output data for information on how to view and edit these entities within Home Assistant. Saving and restoring Predbat settings The selector select.predbat_saverestore can be used to save your current Predbat settings to a YAML file (kept in the directory /config/predbat_save/ ) and to restore the settings from one of these files. Selecting the selector option save current will cause the settings to be saved to a date/time-stamped file. You can rename this file yourself in the Home Assistant filesystem to give it a more human-readable name or delete it if you no longer want to keep it. This is normally best done in an SSH window or via a Samba mount. Selecting the option restore default will put all your settings back to the Predbat defaults. Before the restore, the current Predbat settings will be saved to the file previous.yaml - should you have made a mistake you can restore them quickly again. Selecting any of the .yaml files you have created will restore your settings from this file. Predbat mode The mode that Predbat operates in will change the operation, this can be configured with select.predbat_mode drop-down menu as follows: Monitor Control SOC Only Control charge Control charge & discharge If the switch.predbat_set_read_only is set to True then this prevents Predbat from making modifications to the inverter settings (regardless of the configuration). Predbat will continue making and updating its prediction plan every 5 minutes, but no inverter changes will be made. This is useful if you want to override what Predbat is planning to do (e.g. your own automation), or whilst you are learning how Predbat works before turning it on 'in anger'. NOTE: Changing the Predbat mode or the read-only switch will cause Predbat to reset the inverter settings to default, this will disable both charge and discharge, reset charge and discharge rates to full power and reset the reserve to the default setting Predbat Monitor mode In Monitor mode Predbat will not control or Plan any charging or discharging, inverter balancing will take place if enabled, and the plan will show just what is expected based on the current inverter configuration alone. Predbat Control SOC only mode In Control SOC only mode Predbat will adjust the target charge percentage (SOC target) according to the Best plan, but the charge window will not be modified. This mode can be useful if you just have one fixed charge slot per day and you only want Predbat to control the percentage the battery is charged based on solar generation and predicted house load. CAUTION: You must manually set any charging required on the inverter and if the charge window is disabled then no charging will take place. Predbat Control charge mode In Control charge mode Predbat will set the charge times and charge percentages according to the Best plan, charging can be enabled and disabled by Predbat. Predbat will set the inverter into Eco mode when required to enable the battery to support house load, but it will not plan any forced discharging of the battery for export purposes. This mode can be useful if you don't have an export rate, you have a 'no export' limitation from your electricity supplier, or if you want to preserve the battery for home demand. Predbat Control charge & discharge mode In Control charge & discharge mode Predbat will set both charge and force export (discharge) times and control charge and force export percentages. If you have set the switch.predbat_set_export_freeze_only set to True then forced export won't occur but Predbat can force the export of solar power to the grid when desired. Expert mode Predbat has a toggle switch called switch.predbat_expert_mode which is set to Off by default for new installs (On by default for upgraded installs). A lot of Predbat's more advanced configuration options will not be available unless expert mode is enabled. It's recommended for new users to start without expert mode and then maybe enable it later once you become more confident with the tool. Performance related By default Predbat controls the inverter and updates the plan every 5 minutes, this can however use a lot of CPU power especially on more complex tariffs like Agile when run on lower power machines such as Raspberry PIs and some thin clients. You can tweak input_number.predbat_calculate_plan_every ( expert mode ) to reduce the frequency of replanning while keeping the inverter control in the 5-minute slots. E.g. a value of 10 or 15 minutes should also give good results. If you have performance problems leave switch.predbat_calculate_second_pass ( expert mode ) turned Off as it's quite CPU intensive and provides very little improvement for most systems. You can enable combine_charge_slots and combine_export_slots to speed up planning. Note: Combining export slots may prevent optimal forced export. Combining charge slots is usually fine for tariffs with longer periods of fixed rates but can limit the planning ability in some cases. The number of threads you use can change your performance, you can set threads in apps.yaml to 0 to disable threading if you don't have multiple CPUs available or set it to 'auto' (the default) to use one thread per CPU. It is recommended you don't set this to an odd number of threads. Battery loss options input_number.predbat_battery_loss is an assumed percentage figure for energy lost when charging the battery, the default 0.05 is 5%. input_number.predbat_battery_loss_discharge is an assumed percentage figure for energy lost whilst discharging the battery, the default 0.05 is 5%. input_number.predbat_inverter_loss is an assumed percentage figure for energy lost during the conversion within the inverter from DC to AC or AC to DC, the default is 0% for legacy reasons but please adjust. TIP: Make sure you set the losses correctly, they are decimal percentages, so don't set them to '4' thinking it'll be 4%, Predbat will take this as being 400% and your plan will be very strange! switch.predbat_inverter_hybrid Set to True if you have a hybrid inverter so no inverter losses will be applied for DC charging from Solar generation. Set to False if you have an AC-coupled battery and inverter losses will be applied when charging from solar. NB: This switch only applies when Predbat is modelling solar charging. All grid charging (regardless of inverter type) has to undergo an AC to DC conversion so the inverter_loss % will be included in Predbat's model when charging from the grid. input_number.predbat_metric_battery_cycle ( expert mode ) This sets a 'virtual cost' in pence per kWh on using your battery for charging and discharging. Higher numbers will reduce battery cycles at the expense of using higher energy costs. In theory, if you have a 9.5kWh battery and think it will last say 6000 complete cycles and it cost you \u00a34000, then each full charge and discharge cycle is 19kWh and so the cost per complete cycle is \u00a34000 / 19 / 6000 = 3.5p. Taking the 3.5p per cycle example, if you set predbat_metric_battery_cycle to 1.75 (half of 3.5) then Predbat will apply the \"virtual cost\" of 1.75p to every kWh of charge and discharge of the battery. This cost will be included in Predbat's cost optimisation plan when it decides whether to charge, discharge the battery or let the house run on grid import. NB: For clarity and to re-emphasise, the \"virtual cost\" will be applied to BOTH the cost calculation for charging AND for discharging the battery. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. Note that the cycle cost will not be included in the cost predictions that Predbat produces such as the Predbat HTML plan or Apex charts, it's just a cost taken into account by Predbat at the planning stage when the plan is calculated. NB: Setting this to a non-zero value will increase your daily cost, but will reduce your home battery usage. Figures of around 0p-2p are recommended, the default is 0p per kWh. input_number.predbat_metric_battery_value_scaling ( expert mode ) A percentage value that can be used to scale the value of the energy in the battery at the end of the plan. The battery value is accounted for in the optimisations at the lowest future import rate including charging and inverter losses. A value of 1.0 means no change to this, while lower than 1.0 means to value future battery levels less, greater than 1.0 will value it more (and hence hold more charge at the end of the plan). input_number.metric_self_sufficiency ( expert mode ) A price in pence per kWh used to skew the calculations towards self-sufficiency. Effectively saying to Predbat to account for imports at a higher price than reality in the calculation and thus selecting plans with less import. If you want to be as self-sufficient as possible then set this to the difference between your lowest import rate and the highest export rate to take exports that require additional import appear unprofitable. This setting will not impact the real calculated costs and is only used for plan selection. Values of 5-10p may be worth trying if you prefer to avoid importing even if it saves you money. Scaling and weight options input_number.predbat_battery_rate_max_scaling is a percentage factor to adjust your maximum charge rate from that reported by the inverter. For example, a value of 0.95 would be 95% and indicate charging at 5% slower than reported. For GE inverters the charge rate reports the max AC rate and thus needs to be reduced by inverter losses. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. input_number.predbat_battery_rate_max_scaling_discharge is a percentage factor to adjust your maximum discharge rate from that reported by the inverter. For GE inverters the discharge rate is reported as the max AC rate and thus is fairly accurate. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. switch.predbat_battery_capacity_nominal - When enabled Predbat uses the reported battery size from the GivTCP 'Battery Nominal Capacity' field rather than from the normal GivTCP reported 'Battery Capacity kWh' size. If your battery size is reported wrongly maybe try turning this on and see if it helps. input_number.predbat_load_scaling is a percentage Scaling factor applied to the historical load, increase this if you want to be more pessimistic on future consumption. Use 1.0 to use exactly the previous load data. A value of 1.1 for example would add 10% to the historical load. Note that the output data entity predbat.load_energy_h0 will be scaled accordingly. input_number.predbat_load_scaling10 is a percentage Scaling factor applied to historical load only for the PV10% scenario (this is in addition to load_scaling above). This can be used to make the PV10% scenario take into account extra load usage and hence be more pessimistic while leaving the central scenario unchanged. The default is 1.1 meaning an extra 10% load is added. This will only have an impact if the PV 10% weighting is non-zero. input_number.predbat_load_scaling_saving is a percentage Scaling factor applied to historical load only during Octopus Saving sessions. This can be used to model your household cutting down on energy use inside a saving session (e.g. turning off a heat pump, deferring cooking until after the session, etc). Solar PV adjustment options See also PV configuration options in apps.yaml including an explanation of PV10, PV50 and PV90 terminology. input_number.predbat_pv_scaling is a percentage scaling factor applied to PV data, decrease this if you want to be more pessimistic on PV production vs Solcast. Use 1.0 to accurately apply the Solcast forecast generation data. A value of 0.9, for instance, would reduce 10% from the Solcast generation forecast. input_number.predbat_pv_metric10_weight is the percentage weighting given to the Solcast 10% PV scenario in calculating solar generation. Use 0.0 to disable using the PV 10% in Predbat's forecast of solar generation. A value of 0.1 assumes that 1 in every 10 times we will get the Solcast 10% scenario, and 9 in every 10 times we will get the 'median' Solcast forecast. Predbat estimates solar generation for each half-hour slot to be a pv_metric10_weight weighting of the Solcast 10% PV forecast to the Solcast Median forecast. A value of 0.15 is recommended. Historical load data The historical load data is taken from the load sensor as configured in apps.yaml and the days are selected using days_previous and weighted using days_previous_weight in the same configuration file switch.predbat_load_filter_modal ( expert mode ) when enabled will automatically discard the lowest daily consumption day from the list of days to use (provided you have more than 1 day selected in days_previous). This can be used to ignore a single low usage day in your average calculation. By default is feature is enabled but can be disabled only in expert mode. Car Charging There are a number of configuration items in Home Assistant for Predbat to control your car charging. These are described in detail in Car Charging and are listed here just for completeness: switch.predbat_car_charging_hold - remove the historical car charging load from the house load input_number.predbat_car_charging_threshold - power threshold above which Predbat assumes the car is being charged input_number.predbat_car_charging_energy_scale - used to scale the car_charging_energy sensor in apps.yaml input_number.predbat_car_charging_rate - car's charging rate in kW per hour input_number.predbat_car_charging_loss - percentage energy lost when charging the car switch.predbat_octopus_intelligent_charging - controls whether Octopus Intelligent (via the Octopus Energy integration) controls the car charging or Predbat plans the car charging switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) - used with Octopus Intelligent to prevent Predbat from assuming the car will be charging when the car is unplugged binary_sensor.predbat_car_charging_slot - set to True by Predbat when the car should be charged (Predbat-led charging) select.predbat_car_charging_plan_time - the time you want the car to be charged by switch.predbat_car_charging_plan_smart - allows Predbat to allocate car charging slots to the cheapest times rather than all low-rate slots input_number.predbat_car_charging_plan_max_price - maximum price per kWh to pay when charging your car switch.predbat_car_charging_from_battery - prevent the car from draining the home battery when charging switch.predbat_car_charging_manual_soc - ignore the car_charging_soc car SoC sensor set in apps.yaml input_number.predbat_car_charging_manual_soc_kwh - manually maintained car SoC (used if car SoC sensor is not available) Calculation options See the Predbat mode setting above for basic calculation options input_number.predbat_forecast_plan_hours is the minimum length of the Predbat charge plan, and is the number of hours after the first charge slot to include in the plan. The default of 24 hours is the recommended value (to match energy rate cycles). Note that the actual length of the Predbat plan will vary depending upon when the first charge slot is. switch.predbat_calculate_export_oncharge ( expert mode ) When True calculated export slots will disable or move charge slots, allowing them to intermix. When False export slots will never be placed into charge slots. switch.predbat_set_discharge_during_charge - If turned off disables inverter discharge during charge slots, useful for multi-inverter setups to avoid cross-charging when batteries are out of balance. switch.predbat_inverter_set_charge_before - ( expert_mode ) When True charge slots will be programmed before their start time, when False they will only be configured when the charging time starts. switch.predbat_calculate_tweak_plan ( expert mode ) When True causes Predbat to perform a second pass optimisation across the next 8 charge and export windows in time order. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs which you want to force export late. switch.predbat_calculate_second_pass ( expert mode ) When True causes Predbat to perform a second pass optimisation across all the charge and export windows in time order. NOTE: This feature is quite slow so may need a higher-performance machine. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs in which you want to force export late. switch.calculate_import_low_export ( expert_mode ) When True import slots of the same value are sorted by export price. When False they are sorted just by price and then time. The default is True. By default with this option enabled if there are multiple charge slots of the same price Predbat will try to charge when the export rates are the lowest thus leaving the higher export slots available. switch.calculate_export_high_import ( expert_mode ) When True export slots of the same value are sorted by import price (to avoid the low import slots for export). When False they are sorted just by price and then time. The default is True. By default with this option disabled the latest export slot of the same value will be picked, this is useful for fixed-price export tariffs where you want to export as late in the day as you can. Battery margins and metrics options input_number.predbat_best_soc_keep is the minimum battery level in kWh that Predbat will to try to keep the battery above for the Predbat plan. This is a soft constraint only that's used for longer-term planning and is ignored for the forthcoming first 4 hours of the plan. As this is not used for short-term planning your SoC can drop below this - use input_number.predbat_best_soc_min if you want to force all charges to be above a set level. It's usually good to have best_soc_keep set to 0 to use your entire battery, values above zero will end up costing more money but will ensure you have some spare battery kept back for emergency use. input_number.predbat_best_soc_keep_weight ( expert_mode ) Is used to tune how strongly you want the keep metric to apply. A value of 0 would essentially ignore keep while higher values will make it more important to always stay above your keep threshold even if it costs more money to do so. The default is 0.5 - this is the recommended setting. input_number.predbat_best_soc_min ( expert mode ) sets the minimum charge level (in kWh) for charging during each slot and the minimum force export level also (set to 0 if you want to skip some slots). If you set this to a non-zero value you will need to use the low rate threshold to control which slots you charge from or you may charge all the time. input_number.predbat_best_soc_max ( expert mode ) sets the maximum charge level (in kWh) for charging during each slot. A value of 0 disables this feature. input_number.combine_rate_threshold ( expert mode ) sets a threshold (in pence) to combine charge or export slots into a single larger average rate slot. The default is 0p which disables this feature and all rate changes result in a new slot. switch.predbat_combine_charge_slots Controls if charge slots of > 30 minutes can be combined. When disabled they will be split up, increasing run times but potentially more accurate for planning. Turn this off if you want to enable ad-hoc import during long periods of higher rates but you wouldn't charge normally in that period (e.g. pre-charge at the day rate before a saving session). The default is disabled (False) switch.predbat_combine_export_slots ( expert mode ) Controls if export slots of > 30 minute can be combined. When disabled they will be split up, increasing run times but potentially more accurate for planning. The default is disabled (False) input_number.predbat_metric_min_improvement ( expert mode ) sets the minimum cost improvement in pence that it's worth lowering the battery SOC % for. The default value is 0 which means this feature is disabled and the battery will be charged less if it's cost neutral. If you use input_number.predbat_pv_metric10_weight then you probably don't need to enable this as the 10% forecast does the same thing better Do not use it if you have multiple charge windows in a given period as it won't lead to good results (e.g. Agile) You could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10). input_number.predbat_metric_min_improvement_export ( expert mode ) Sets the minimum pence cost improvement it's worth doing a forced export for. A value of 0.1 is the default which prevents any marginal exports as they must be worth at least 0.1 pence for a 30-minute slot (less for shorter slots). If you increase this value (e.g. you only want to force export if very profitable), then exports will become less common. The value is in pence per 30 minutes of export time. input_number.predbat_metric_min_improvement_export_freeze ( expert mode ) Sets the minimum pence cost improvement it's worth doing an export freeze for. A value of 0.1 is the default which prevents any marginal freezes as they must be worth at least 0.1 pence for a 30-minute slot (less for shorter slots). If you increase this value (e.g. you only want to freeze export if very profitable), then freeze exports will become less common. The value is in pence per 30 minutes of export time. input_number.predbat_metric_min_improvement_swap ( expert mode ) Sets the minimum improvement in cost to swap an export slot to a later time in the day. The default for this setting is -0.25p, meaning that export will be moved later even if it costs up to an extra 0.25p on the plan. The advantage of having late exports means that you are less likely to run out of battery earlier in the day. Values of between -1p and 0p would be recommended. input_number.predbat_rate_low_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future import rates in the plan and determine the import rate threshold below which a slot will be considered to be a potential charging slot. If rate_low_threshold is set to a non-zero value this will set the threshold below future average import rates as the minimum to consider for a charge window, e.g. setting to 0.8 = 80% of the average rate. If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period which makes optimisation harder. input_number.predbat_rate_high_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future export rates in the plan and determine the threshold above which a slot can be considered a potential exporting slot. If rate_high_threshold is set to a non-zero value this will set the threshold above future average export rates as the minimum export rate to consider exporting for, e.g. setting to 1.2 = 20% above average rate. If you set this too high you might not get any export slots. If it's too low you might get too many in the 24-hour period. input_number.predbat_metric_future_rate_offset_import ( expert mode ) Sets an offset to apply to future import energy rates that are not yet published, best used for variable rate tariffs such as Agile import where the rates are not published until 4pm. If you set this to a positive value then Predbat will assume unpublished import rates are higher by the given amount. Setting this to 1 to 1.5p for example results in Predbat being a little more aggressive in the charging calculation for today - Predbat will charge the battery to a higher percentage than it would otherwise as it expects a cost-benefit of using today's lower rates. NB: this can lead to higher costs and to some export if solar generation is better than forecast. input_number.predbat_metric_future_rate_offset_export ( expert mode ) Sets an offset to apply to future export energy rates that are not yet published, best used for variable rate tariffs such as Agile export where the rates are not published until 4pm. If you set this to a negative value then Predbat will assume unpublished export rates are lower by the given amount. switch.predbat_calculate_inday_adjustment ( expert mode ) Enabled by default with damping of 0.95. When enabled will calculate the difference between today's actual load and today's predicated load and adjust the rest of the day's usage prediction accordingly. A scale factor can be set with input_number.predbat_metric_inday_adjust_damping ( expert mode ) to either scale up or down the impact of the in-day adjustment (lower numbers scale down its impact). The in-day adjustment factor can be seen in predbat.load_inday_adjustment and charted with the In-Day Adjustment chart (template can be found in the charts template in Github). switch.predbat_metric_pv_calibration_enable When enabled allows Predbat to use historical data to calibrate your PV production estimates on a 30 minute basis based on actual data. This can be useful to adjust for your systems real performance. Default is Off. input_number.predbat_carbon_metric ( carbon enable ) When Carbon footprint tracking is enabled ( switch.predbat_carbon_enable ) you can specify a cost per Kg of CO2 used to weight the selection of plans. Values of around 10-200 will give varying outcomes to trade off cost vs carbon footprint of your system. Note: Carbon footprint tracking can only be enabled if apps.yaml is configured to point to the correct CO2 cost sensor Inverter control options switch.predbat_set_status_notify Enables mobile notification about changes to the Predbat state (e.g. Charge, Export etc). On by default. switch.predbat_set_inverter_notify Enables mobile notification about all changes to inverter registers (e.g. setting window, turning discharge on/off). Off by default. switch.predbat_set_charge_low_power Enables low-power charging mode where the max charge rate will be automatically determined by Predbat to be the lowest possible rate to meet the charge target. This is only really effective for charge windows longer than 30 minutes. If this setting is turned on, it is strongly recommended that you create a battery_power_charge_curve in apps.yaml as otherwise the low power charge may not reach the charge target in time. This setting is off by default. The YouTube video low power charging and charging curve explains how the low-power charging works and shows how Predbat automatically creates it. input_number.predbat_charge_low_power_margin (requires switch.predbat_set_charge_low_power to be enabled) Controls how many minutes before the completion time to target finishing charging, this defaults to 10 but can be changed between 0 and 30. switch.predbat_set_reserve_enable ( expert_mode ) When enabled the reserve setting is used to hold the battery charge level once it has been reached or to protect against discharging beyond the set limit. Enabled by default. switch.predbat_set_export_freeze When enabled will allow Predbat to export Solar to the grid rather than charging the battery. Enabled by default on those inverters that have this support. switch.predbat_set_charge_freeze ( expert mode ) When enabled will allow Predbat to hold the current battery level while drawing from the grid/solar as an alternative to charging. Enabled by default. switch.predbat_set_export_freeze_only ( expert mode ) When enabled forced export is prevented, but export freeze can be used (if enabled) to export excess solar rather than charging the battery. This is useful with tariffs that pay you for solar exports but don't allow forced export (brown energy). If you have switch.predbat_inverter_hybrid set to False then if switch.predbat_inverter_soc_reset ( expert mode ) is set to True then the target SOC % will be reset to 100% outside of a charge window. This may be required for the AIO inverter to ensure it charges from solar. The default for this switch is True but it can be disabled in expert mode if need be. input_number.predbat_set_reserve_min Defines the battery reserve percentage, i.e. the minimum charge level that should be retained in the battery, a value of 4 is the minimum and recommended to make use of the full battery. When the battery level reaches the specified minimum level, your inverter will start importing from the grid to satisfy house load. If you want to pre-prepare the battery to retain extra charge in the event of a high likelihood of a grid power outage such as storms predicted, you can increase set_reserve_min to a higher value, and then change it back afterwards. (Obviously this is only any use if your inverter is wired to act as an Emergency Power Supply or whole-home backup 'island mode' on the GivEnergy AIO). Note that input_number.predbat_set_reserve_min is used by Predbat to stop the battery SoC dropping below the specified level but it is not used in planning battery charging. i.e. if you change the reserve min to a level higher than the current battery SoC then Predbat will not plan charging activity to increase the SoC to that level; you should set manual charges to increase the SoC level. switch.predbat_inverter_soc_reset ( expert mode ) When enabled the target SOC for the inverter(s) will be reset to 100% when a charge slot is not active, this can be used to workaround some firmware issues where the SOC target is used for solar charging as well as grid charging. When disabled the SOC % will not be changed after a charge slot. This is enabled by default. Balance Inverters When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. The apps.yaml contains a setting balance_inverters_seconds which defines how often to run the balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Enable the switch.predbat_balance_inverters_enable switch in Home Assistant to enable this feature. switch.predbat_balance_inverters_charge - Is used to toggle on/off balancing while the batteries are charging switch.predbat_balance_inverters_discharge - Is used to toggle on/off balancing while the batteries are discharging switch.predbat_balance_inverters_crosscharge - Is used to toggle on/off balancing when the batteries are cross charging input_number.predbat_balance_inverters_threshold_charge - Sets the minimum percentage divergence of SoC during charge before balancing, default is 1% input_number.predbat_balance_inverters_threshold_discharge - Sets the minimum percentage divergence of SoC during discharge before balancing, default is 1% Cloud coverage and load variance Predbat tries to model passing clouds by modulating the PV forecast data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the difference between the PV50% (default) and PV10% scenario produced by Solcast. You can disable this feature ( expert mode only ) using switch.predbat_metric_cloud_enable Predbat tries to model changes in your household load by modulating the historical data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the standard deviation of your load predictions over the coming period (currently 4 hours). You can disable this feature ( expert mode only ) using switch.metric_load_divergence_enable iBoost model options Predbat has an 'iBoost model' that can be used to model using excess solar energy to heat hot water (or similar) instead of it being exported to the grid. This model can be used to control any solar diverter device, for example, an iBoost (e.g. using a Fingerbot or similar device to physically press the 'boost' button on the iBoost), a MyEnergy Eddi (using the MyEnergy integration), or it can be used with a high-power smart switch to turn on the hot water cylinder immersion heater when there is excess solar. So although Predbat refers to controlling an iBoost, you are not limited to just an iBoost device when using this model within Predbat. To turn the model on, switch.predbat_iboost_enable needs to be enabled. The predicted output from the iBoost solar diverter model is returned in predbat.iboost_best and is populated in the 'iBoost' column of the Predbat plan . iBoost basic configuration When you turn on predbat_iBoost_enable the following additional Home Assistant entities are created by Predbat: input_number.predbat_iboost_max_energy Sets the maximum energy in kWh that the solar diverter can consume during a day before turning off - default 3kWh. input_number.predbat_iboost_max_power Sets the maximum power in watts that the solar diverter will consume - default 2400. input_number.predbat_iboost_min_power Sets the minimum power in watts that the solar diverter will consume - default 500. input_number.predbat_iboost_value_scaling Sets how to account for the value of iBoost units of energy. The default value of 0.75 means that each kWh of energy diverted is accounted for as 0.75 times The lowest future import rate. Higher values will generate plans with more solar diversion while lower values will generate less. A value of 0 means all diverted energy should be ignored in planning (assumed to be zero value). switch.predbat_iboost_energy_subtract When enabled (default) energy reported by the iboost_energy_today sensor configured in apps.yaml will be subtracted from your historical load data to improve the accuracy of predictions. If you are using PredAI you will also need to subtract this data inside PredAI configuration. Different boost modes can be selected: iBoost modes Solar switch.predbat_iboost_solar When enabled assume the diverter will use solar power to boost the hot water heating. switch.predbat_iboost_solar_excess When disabled will allow any solar power to be diverted while if enabled only excess power (power that would otherwise be exported) will be used. The default is Off. By default iboost will not run the battery is in force export mode unless you turn on switch.predbat_iboost_on_export input_number.predbat_iboost_min_soc sets the minimum home battery SoC percentage that must be in the battery before the solar diverter is turned on. The default is 0 meaning hot water heating can occur regardless of what SoC level the battery is at. Battery switch.predbat_iboost_charging If set to on, the diverter will operate when the battery is charging (can be combined with solar) Energy rates only If both of the above are off, but iBoost is enabled then boost will happen solely based on energy rates (see below). switch.predbat_iboost_smart Will pick the lowest import rate slots within 24 hours to achieve the desired energy as specified by input_number.predbat_iboost_max_energy . Only slots at or below the rate threshold will be selected. Note this option only applies when iboost_solar and iboost battery are both off. input_number.predbat_iboost_smart_min_length Sets the minimum slot length in minutes to iBoost (only applies for energy rate only modes). The default is 30 minutes but can be set in multiples of 30. Increasing this slot size could increase costs depending on your tariff. switch.predbat_iboost_on_export If set to on allows iBoost to run even if the battery is forced to export to the grid, otherwise it won't run in these circumstances. switch.iboost_prevent_discharge When set will stop your battery from discharging when iBoost is active and thus prevent your battery from draining to the diverter. This switch will work in all modes and is not recommended to be used when iBoost Solar is enabled as it will prevent your battery from discharging during excess solar periods which could cause additional imports due to passing clouds. iBoost energy rate filtering input_number.predbat_iboost_rate_threshold Sets the maximum import rate (in pence) that the diverter will trigger on, defaults to 100. input_number.predbat_iboost_rate_threshold_export Sets the maximum export rate (in pence) that the diverter will trigger on, defaults to 100. switch.predbat_iboost_gas When enabled will control the diverter to only operate when import electric rates are lower than gas rates. switch.predbat_iboost_gas_export When enabled will control the diverter to only operate when export electric rates are lower than gas rates. These can be useful if you have the choice to heat your hot water by immersion heater or by gas boiler. Note: Gas rates have to be configured in apps.yaml using metric_octopus_gas or rates_gas depending upon whether you are using the Octopus Integration or not. input_number.predbat_iboost_gas_scale Sets the scaling of the gas rates (set in apps.yaml )used before comparing with electric rates, to account for gas boiler losses and efficiency. It should be set to the reciprocal of the boiler efficiency, i.e. for an 80% efficient gas boiler, set to 1.25. iBoost control iBoost output data You will see input_number.predbat_iboost_today entity which tracks the estimated kWh consumed by the solar diverter during the day, and resets at midnight every night. The binary_sensor.predbat_iboost_active entity will be enabled when the solar diverter should be active and can be used for automations to trigger the immersion heater boost. The attributes within this sensor include 'solar' which includes Solar diversion should be active and 'full' which indicates iBoost should run at maximum rate (could be during a charge cycle or grid import). Example template automation for controlling the solar diverter: alias: Solar Diverter description: \"Start/stop solar diverter based on Predbat-determined slots\" trigger: - platform: state entity_id: - binary_sensor.predbat_iboost_active action: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"True\" sequence: <commands to turn on your solar diverter> - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"False\" sequence: <commands to turn off your solar diverter> mode: single If you have an incrementing sensor that tracks the solar diverter energy usage then to make your predictions more accurate you should set the iboost_energy_today sensor in apps.yaml to point to it, and optionally set iboost_energy_scaling if the sensor isn't in kWh (e.g. set to 0.001 if the sensor is in Watts). The sensor should be an incrementing sensor which can reset at midnight or not. Holiday mode When you go away you are likely to use less electricity and so the previous load data will be quite pessimistic. Using the Home Assistant entity input_number.predbat_holiday_days_left you can set the number of full days that you will be away (including today). The number will count down by 1 day at midnight until it gets back to zero. Whilst the holiday days left are non-zero, Predbat's 'holiday mode' is active. When Predbat's 'holiday mode' is active the historical load data will be taken from yesterday's data (1 day ago) rather than from the days_previous setting in apps.yaml . This means Predbat will adjust more quickly to the new usage pattern. If you have been away for a longer period (more than your normal days_previous setting) then obviously it's going to take longer for the historical data to catch up, you could then enable holiday mode for another 7 days after your return. In summary: For short holidays set holiday_days_left to the number of full days you are away, including today but excluding the return day For longer holidays set holiday_days_left to the number of days you are away plus another 7 days until the data catches back up Manual control In some cases, you may want to override Predbat's planned behaviour and make a decision yourself. One way to achieve this is to put Predbat into read-only mode using switch.predbat_set_read_only . When going to read-only mode the inverter will be put back to the default settings and you should then control it yourself using GivTCP or the App appropriate to your inverter. A better alternative in some cases is to tell Predbat what you want it to do using the manual force features: You can force the battery to be charged within a 30-minute slot by using the select.predbat_manual_charge selector. Pick the 30-minute slot you wish to charge in, and Predbat will change the plan to charge in the selected slot. You can select multiple slots by using the drop-down menu more than once. When Predbat updates the plan you will see the slots picked to be charging slots in the current value of this selector, and annotated in the Predbat HTML plan with an upside down 'F' symbol. You can cancel a force slot by selecting the slot time again (it will be shown in square brackets to indicate it's already selected). The select.predbat_manual_export selector can be used to manually force an export within a 30-minute slot in the same way as the manual force charge feature. The force export takes priority over force charging. The select.predbat_manual_demand selector is used to force Predbat to demand mode during a 30-minute slot, this implies no forced grid charging or exporting of the battery. House load will be supplied from solar, or the battery if there is insufficient solar, or grid import if there is insufficient battery charge. This is described as 'ECO' Mode for GivEnergy inverters but other inverters use different terminology. The select.predbat_manual_freeze_charge selector is used to force Predbat to freeze charge during a 30-minute slot, this implies the battery will not discharge and hold at the current level. The grid may be used if solar is not enough to cover the load. The select.predbat_manual_freeze_export selector is used to force Predbat to freeze export during a 30-minute slot, this implies the battery will not charge but will still discharge for the house load. Any solar will be exported to the grid. When you use the manual override features you can only select times in the next 18 hours, the overrides will be removed once their time slot expires (they do not repeat). _NOTE: once you select a time slot from any of the select.predbat_manual_ selectors the selected time slot is immediately marked on the drop-down and you can then make another change. Predbat still has to update the plan which it will be doing so in the background, and this can take a few minutes to run (depending on the speed and power of the PC you are running Home Assistant on) so don't be surprised why the Predbat plan doesn't change immediately - remember you can see the date/time the plan was last updated on the first row of the plan. CAUTION: If you leave Predbat turned off for a long period of time then the override timeslots could end up repeating when you restart Debug switch.predbat_debug_enable When on will create lots of debugging information to aid diagnosis of Predbat issues. By default this is turned off and its recommended that its only switched on when debug logs are requested. With the switch on: Firstly Predbat prints lots of extra debug information in the predbat logfile which means the logfile will fill and swap to a new file more rapidly Secondly Predbat will create a debug output file 'debug/predbat_debug_HH_MM_SS.yaml' in a subfolder of the Predbat installation directory. This file contains a full export of your current Predbat config and is extremely useful to enable recreating your setup to diagnose issues. Any sensitive information such as Solcast or GivEnergy Cloud API keys are automatically removed. The following automation might be useful to automatically turn off Predbat debug mode after turning it on to capture the debug logs: alias: \"Predbat: Auto turn-off debug mode\" description: \"\" triggers: - trigger: state entity_id: - switch.predbat_debug_enable to: \"on\" for: minutes: 10 conditions: [] actions: - action: script.notify_all_devices metadata: {} data: title: \"INFO: Turned off Predbat debug after 10 minutes\" critical: \"N\" url: \"\" message: switch.predbat_debug_enable turned off - action: switch.turn_off target: entity_id: switch.predbat_debug_enable data: {} mode: single switch.predbat_plan_debug ( expert mode ) when enabled adds some extra debug to the Predbat HTML plan - see Predbat Plan debug mode for more details.","title":"Customisation"},{"location":"customisation/#customisation","text":"This document describes the Predbat configuration items in Home Assistant that you can modify to customise Predbat to fit your needs. All of these settings are entities that can be configured directly in Home Assistant (unlike the ' apps.yaml ' configuration items that have to be edited with a file editor). See Displaying output data for information on how to view and edit these entities within Home Assistant.","title":"Customisation"},{"location":"customisation/#saving-and-restoring-predbat-settings","text":"The selector select.predbat_saverestore can be used to save your current Predbat settings to a YAML file (kept in the directory /config/predbat_save/ ) and to restore the settings from one of these files. Selecting the selector option save current will cause the settings to be saved to a date/time-stamped file. You can rename this file yourself in the Home Assistant filesystem to give it a more human-readable name or delete it if you no longer want to keep it. This is normally best done in an SSH window or via a Samba mount. Selecting the option restore default will put all your settings back to the Predbat defaults. Before the restore, the current Predbat settings will be saved to the file previous.yaml - should you have made a mistake you can restore them quickly again. Selecting any of the .yaml files you have created will restore your settings from this file.","title":"Saving and restoring Predbat settings"},{"location":"customisation/#predbat-mode","text":"The mode that Predbat operates in will change the operation, this can be configured with select.predbat_mode drop-down menu as follows: Monitor Control SOC Only Control charge Control charge & discharge If the switch.predbat_set_read_only is set to True then this prevents Predbat from making modifications to the inverter settings (regardless of the configuration). Predbat will continue making and updating its prediction plan every 5 minutes, but no inverter changes will be made. This is useful if you want to override what Predbat is planning to do (e.g. your own automation), or whilst you are learning how Predbat works before turning it on 'in anger'. NOTE: Changing the Predbat mode or the read-only switch will cause Predbat to reset the inverter settings to default, this will disable both charge and discharge, reset charge and discharge rates to full power and reset the reserve to the default setting","title":"Predbat mode"},{"location":"customisation/#predbat-monitor-mode","text":"In Monitor mode Predbat will not control or Plan any charging or discharging, inverter balancing will take place if enabled, and the plan will show just what is expected based on the current inverter configuration alone.","title":"Predbat Monitor mode"},{"location":"customisation/#predbat-control-soc-only-mode","text":"In Control SOC only mode Predbat will adjust the target charge percentage (SOC target) according to the Best plan, but the charge window will not be modified. This mode can be useful if you just have one fixed charge slot per day and you only want Predbat to control the percentage the battery is charged based on solar generation and predicted house load. CAUTION: You must manually set any charging required on the inverter and if the charge window is disabled then no charging will take place.","title":"Predbat Control SOC only mode"},{"location":"customisation/#predbat-control-charge-mode","text":"In Control charge mode Predbat will set the charge times and charge percentages according to the Best plan, charging can be enabled and disabled by Predbat. Predbat will set the inverter into Eco mode when required to enable the battery to support house load, but it will not plan any forced discharging of the battery for export purposes. This mode can be useful if you don't have an export rate, you have a 'no export' limitation from your electricity supplier, or if you want to preserve the battery for home demand.","title":"Predbat Control charge mode"},{"location":"customisation/#predbat-control-charge-discharge-mode","text":"In Control charge & discharge mode Predbat will set both charge and force export (discharge) times and control charge and force export percentages. If you have set the switch.predbat_set_export_freeze_only set to True then forced export won't occur but Predbat can force the export of solar power to the grid when desired.","title":"Predbat Control charge &amp; discharge mode"},{"location":"customisation/#expert-mode","text":"Predbat has a toggle switch called switch.predbat_expert_mode which is set to Off by default for new installs (On by default for upgraded installs). A lot of Predbat's more advanced configuration options will not be available unless expert mode is enabled. It's recommended for new users to start without expert mode and then maybe enable it later once you become more confident with the tool.","title":"Expert mode"},{"location":"customisation/#performance-related","text":"By default Predbat controls the inverter and updates the plan every 5 minutes, this can however use a lot of CPU power especially on more complex tariffs like Agile when run on lower power machines such as Raspberry PIs and some thin clients. You can tweak input_number.predbat_calculate_plan_every ( expert mode ) to reduce the frequency of replanning while keeping the inverter control in the 5-minute slots. E.g. a value of 10 or 15 minutes should also give good results. If you have performance problems leave switch.predbat_calculate_second_pass ( expert mode ) turned Off as it's quite CPU intensive and provides very little improvement for most systems. You can enable combine_charge_slots and combine_export_slots to speed up planning. Note: Combining export slots may prevent optimal forced export. Combining charge slots is usually fine for tariffs with longer periods of fixed rates but can limit the planning ability in some cases. The number of threads you use can change your performance, you can set threads in apps.yaml to 0 to disable threading if you don't have multiple CPUs available or set it to 'auto' (the default) to use one thread per CPU. It is recommended you don't set this to an odd number of threads.","title":"Performance related"},{"location":"customisation/#battery-loss-options","text":"input_number.predbat_battery_loss is an assumed percentage figure for energy lost when charging the battery, the default 0.05 is 5%. input_number.predbat_battery_loss_discharge is an assumed percentage figure for energy lost whilst discharging the battery, the default 0.05 is 5%. input_number.predbat_inverter_loss is an assumed percentage figure for energy lost during the conversion within the inverter from DC to AC or AC to DC, the default is 0% for legacy reasons but please adjust. TIP: Make sure you set the losses correctly, they are decimal percentages, so don't set them to '4' thinking it'll be 4%, Predbat will take this as being 400% and your plan will be very strange! switch.predbat_inverter_hybrid Set to True if you have a hybrid inverter so no inverter losses will be applied for DC charging from Solar generation. Set to False if you have an AC-coupled battery and inverter losses will be applied when charging from solar. NB: This switch only applies when Predbat is modelling solar charging. All grid charging (regardless of inverter type) has to undergo an AC to DC conversion so the inverter_loss % will be included in Predbat's model when charging from the grid. input_number.predbat_metric_battery_cycle ( expert mode ) This sets a 'virtual cost' in pence per kWh on using your battery for charging and discharging. Higher numbers will reduce battery cycles at the expense of using higher energy costs. In theory, if you have a 9.5kWh battery and think it will last say 6000 complete cycles and it cost you \u00a34000, then each full charge and discharge cycle is 19kWh and so the cost per complete cycle is \u00a34000 / 19 / 6000 = 3.5p. Taking the 3.5p per cycle example, if you set predbat_metric_battery_cycle to 1.75 (half of 3.5) then Predbat will apply the \"virtual cost\" of 1.75p to every kWh of charge and discharge of the battery. This cost will be included in Predbat's cost optimisation plan when it decides whether to charge, discharge the battery or let the house run on grid import. NB: For clarity and to re-emphasise, the \"virtual cost\" will be applied to BOTH the cost calculation for charging AND for discharging the battery. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. Note that the cycle cost will not be included in the cost predictions that Predbat produces such as the Predbat HTML plan or Apex charts, it's just a cost taken into account by Predbat at the planning stage when the plan is calculated. NB: Setting this to a non-zero value will increase your daily cost, but will reduce your home battery usage. Figures of around 0p-2p are recommended, the default is 0p per kWh. input_number.predbat_metric_battery_value_scaling ( expert mode ) A percentage value that can be used to scale the value of the energy in the battery at the end of the plan. The battery value is accounted for in the optimisations at the lowest future import rate including charging and inverter losses. A value of 1.0 means no change to this, while lower than 1.0 means to value future battery levels less, greater than 1.0 will value it more (and hence hold more charge at the end of the plan). input_number.metric_self_sufficiency ( expert mode ) A price in pence per kWh used to skew the calculations towards self-sufficiency. Effectively saying to Predbat to account for imports at a higher price than reality in the calculation and thus selecting plans with less import. If you want to be as self-sufficient as possible then set this to the difference between your lowest import rate and the highest export rate to take exports that require additional import appear unprofitable. This setting will not impact the real calculated costs and is only used for plan selection. Values of 5-10p may be worth trying if you prefer to avoid importing even if it saves you money.","title":"Battery loss options"},{"location":"customisation/#scaling-and-weight-options","text":"input_number.predbat_battery_rate_max_scaling is a percentage factor to adjust your maximum charge rate from that reported by the inverter. For example, a value of 0.95 would be 95% and indicate charging at 5% slower than reported. For GE inverters the charge rate reports the max AC rate and thus needs to be reduced by inverter losses. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. input_number.predbat_battery_rate_max_scaling_discharge is a percentage factor to adjust your maximum discharge rate from that reported by the inverter. For GE inverters the discharge rate is reported as the max AC rate and thus is fairly accurate. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. switch.predbat_battery_capacity_nominal - When enabled Predbat uses the reported battery size from the GivTCP 'Battery Nominal Capacity' field rather than from the normal GivTCP reported 'Battery Capacity kWh' size. If your battery size is reported wrongly maybe try turning this on and see if it helps. input_number.predbat_load_scaling is a percentage Scaling factor applied to the historical load, increase this if you want to be more pessimistic on future consumption. Use 1.0 to use exactly the previous load data. A value of 1.1 for example would add 10% to the historical load. Note that the output data entity predbat.load_energy_h0 will be scaled accordingly. input_number.predbat_load_scaling10 is a percentage Scaling factor applied to historical load only for the PV10% scenario (this is in addition to load_scaling above). This can be used to make the PV10% scenario take into account extra load usage and hence be more pessimistic while leaving the central scenario unchanged. The default is 1.1 meaning an extra 10% load is added. This will only have an impact if the PV 10% weighting is non-zero. input_number.predbat_load_scaling_saving is a percentage Scaling factor applied to historical load only during Octopus Saving sessions. This can be used to model your household cutting down on energy use inside a saving session (e.g. turning off a heat pump, deferring cooking until after the session, etc).","title":"Scaling and weight options"},{"location":"customisation/#solar-pv-adjustment-options","text":"See also PV configuration options in apps.yaml including an explanation of PV10, PV50 and PV90 terminology. input_number.predbat_pv_scaling is a percentage scaling factor applied to PV data, decrease this if you want to be more pessimistic on PV production vs Solcast. Use 1.0 to accurately apply the Solcast forecast generation data. A value of 0.9, for instance, would reduce 10% from the Solcast generation forecast. input_number.predbat_pv_metric10_weight is the percentage weighting given to the Solcast 10% PV scenario in calculating solar generation. Use 0.0 to disable using the PV 10% in Predbat's forecast of solar generation. A value of 0.1 assumes that 1 in every 10 times we will get the Solcast 10% scenario, and 9 in every 10 times we will get the 'median' Solcast forecast. Predbat estimates solar generation for each half-hour slot to be a pv_metric10_weight weighting of the Solcast 10% PV forecast to the Solcast Median forecast. A value of 0.15 is recommended.","title":"Solar PV adjustment options"},{"location":"customisation/#historical-load-data","text":"The historical load data is taken from the load sensor as configured in apps.yaml and the days are selected using days_previous and weighted using days_previous_weight in the same configuration file switch.predbat_load_filter_modal ( expert mode ) when enabled will automatically discard the lowest daily consumption day from the list of days to use (provided you have more than 1 day selected in days_previous). This can be used to ignore a single low usage day in your average calculation. By default is feature is enabled but can be disabled only in expert mode.","title":"Historical load data"},{"location":"customisation/#car-charging","text":"There are a number of configuration items in Home Assistant for Predbat to control your car charging. These are described in detail in Car Charging and are listed here just for completeness: switch.predbat_car_charging_hold - remove the historical car charging load from the house load input_number.predbat_car_charging_threshold - power threshold above which Predbat assumes the car is being charged input_number.predbat_car_charging_energy_scale - used to scale the car_charging_energy sensor in apps.yaml input_number.predbat_car_charging_rate - car's charging rate in kW per hour input_number.predbat_car_charging_loss - percentage energy lost when charging the car switch.predbat_octopus_intelligent_charging - controls whether Octopus Intelligent (via the Octopus Energy integration) controls the car charging or Predbat plans the car charging switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) - used with Octopus Intelligent to prevent Predbat from assuming the car will be charging when the car is unplugged binary_sensor.predbat_car_charging_slot - set to True by Predbat when the car should be charged (Predbat-led charging) select.predbat_car_charging_plan_time - the time you want the car to be charged by switch.predbat_car_charging_plan_smart - allows Predbat to allocate car charging slots to the cheapest times rather than all low-rate slots input_number.predbat_car_charging_plan_max_price - maximum price per kWh to pay when charging your car switch.predbat_car_charging_from_battery - prevent the car from draining the home battery when charging switch.predbat_car_charging_manual_soc - ignore the car_charging_soc car SoC sensor set in apps.yaml input_number.predbat_car_charging_manual_soc_kwh - manually maintained car SoC (used if car SoC sensor is not available)","title":"Car Charging"},{"location":"customisation/#calculation-options","text":"See the Predbat mode setting above for basic calculation options input_number.predbat_forecast_plan_hours is the minimum length of the Predbat charge plan, and is the number of hours after the first charge slot to include in the plan. The default of 24 hours is the recommended value (to match energy rate cycles). Note that the actual length of the Predbat plan will vary depending upon when the first charge slot is. switch.predbat_calculate_export_oncharge ( expert mode ) When True calculated export slots will disable or move charge slots, allowing them to intermix. When False export slots will never be placed into charge slots. switch.predbat_set_discharge_during_charge - If turned off disables inverter discharge during charge slots, useful for multi-inverter setups to avoid cross-charging when batteries are out of balance. switch.predbat_inverter_set_charge_before - ( expert_mode ) When True charge slots will be programmed before their start time, when False they will only be configured when the charging time starts. switch.predbat_calculate_tweak_plan ( expert mode ) When True causes Predbat to perform a second pass optimisation across the next 8 charge and export windows in time order. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs which you want to force export late. switch.predbat_calculate_second_pass ( expert mode ) When True causes Predbat to perform a second pass optimisation across all the charge and export windows in time order. NOTE: This feature is quite slow so may need a higher-performance machine. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs in which you want to force export late. switch.calculate_import_low_export ( expert_mode ) When True import slots of the same value are sorted by export price. When False they are sorted just by price and then time. The default is True. By default with this option enabled if there are multiple charge slots of the same price Predbat will try to charge when the export rates are the lowest thus leaving the higher export slots available. switch.calculate_export_high_import ( expert_mode ) When True export slots of the same value are sorted by import price (to avoid the low import slots for export). When False they are sorted just by price and then time. The default is True. By default with this option disabled the latest export slot of the same value will be picked, this is useful for fixed-price export tariffs where you want to export as late in the day as you can.","title":"Calculation options"},{"location":"customisation/#battery-margins-and-metrics-options","text":"input_number.predbat_best_soc_keep is the minimum battery level in kWh that Predbat will to try to keep the battery above for the Predbat plan. This is a soft constraint only that's used for longer-term planning and is ignored for the forthcoming first 4 hours of the plan. As this is not used for short-term planning your SoC can drop below this - use input_number.predbat_best_soc_min if you want to force all charges to be above a set level. It's usually good to have best_soc_keep set to 0 to use your entire battery, values above zero will end up costing more money but will ensure you have some spare battery kept back for emergency use. input_number.predbat_best_soc_keep_weight ( expert_mode ) Is used to tune how strongly you want the keep metric to apply. A value of 0 would essentially ignore keep while higher values will make it more important to always stay above your keep threshold even if it costs more money to do so. The default is 0.5 - this is the recommended setting. input_number.predbat_best_soc_min ( expert mode ) sets the minimum charge level (in kWh) for charging during each slot and the minimum force export level also (set to 0 if you want to skip some slots). If you set this to a non-zero value you will need to use the low rate threshold to control which slots you charge from or you may charge all the time. input_number.predbat_best_soc_max ( expert mode ) sets the maximum charge level (in kWh) for charging during each slot. A value of 0 disables this feature. input_number.combine_rate_threshold ( expert mode ) sets a threshold (in pence) to combine charge or export slots into a single larger average rate slot. The default is 0p which disables this feature and all rate changes result in a new slot. switch.predbat_combine_charge_slots Controls if charge slots of > 30 minutes can be combined. When disabled they will be split up, increasing run times but potentially more accurate for planning. Turn this off if you want to enable ad-hoc import during long periods of higher rates but you wouldn't charge normally in that period (e.g. pre-charge at the day rate before a saving session). The default is disabled (False) switch.predbat_combine_export_slots ( expert mode ) Controls if export slots of > 30 minute can be combined. When disabled they will be split up, increasing run times but potentially more accurate for planning. The default is disabled (False) input_number.predbat_metric_min_improvement ( expert mode ) sets the minimum cost improvement in pence that it's worth lowering the battery SOC % for. The default value is 0 which means this feature is disabled and the battery will be charged less if it's cost neutral. If you use input_number.predbat_pv_metric10_weight then you probably don't need to enable this as the 10% forecast does the same thing better Do not use it if you have multiple charge windows in a given period as it won't lead to good results (e.g. Agile) You could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10). input_number.predbat_metric_min_improvement_export ( expert mode ) Sets the minimum pence cost improvement it's worth doing a forced export for. A value of 0.1 is the default which prevents any marginal exports as they must be worth at least 0.1 pence for a 30-minute slot (less for shorter slots). If you increase this value (e.g. you only want to force export if very profitable), then exports will become less common. The value is in pence per 30 minutes of export time. input_number.predbat_metric_min_improvement_export_freeze ( expert mode ) Sets the minimum pence cost improvement it's worth doing an export freeze for. A value of 0.1 is the default which prevents any marginal freezes as they must be worth at least 0.1 pence for a 30-minute slot (less for shorter slots). If you increase this value (e.g. you only want to freeze export if very profitable), then freeze exports will become less common. The value is in pence per 30 minutes of export time. input_number.predbat_metric_min_improvement_swap ( expert mode ) Sets the minimum improvement in cost to swap an export slot to a later time in the day. The default for this setting is -0.25p, meaning that export will be moved later even if it costs up to an extra 0.25p on the plan. The advantage of having late exports means that you are less likely to run out of battery earlier in the day. Values of between -1p and 0p would be recommended. input_number.predbat_rate_low_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future import rates in the plan and determine the import rate threshold below which a slot will be considered to be a potential charging slot. If rate_low_threshold is set to a non-zero value this will set the threshold below future average import rates as the minimum to consider for a charge window, e.g. setting to 0.8 = 80% of the average rate. If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period which makes optimisation harder. input_number.predbat_rate_high_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future export rates in the plan and determine the threshold above which a slot can be considered a potential exporting slot. If rate_high_threshold is set to a non-zero value this will set the threshold above future average export rates as the minimum export rate to consider exporting for, e.g. setting to 1.2 = 20% above average rate. If you set this too high you might not get any export slots. If it's too low you might get too many in the 24-hour period. input_number.predbat_metric_future_rate_offset_import ( expert mode ) Sets an offset to apply to future import energy rates that are not yet published, best used for variable rate tariffs such as Agile import where the rates are not published until 4pm. If you set this to a positive value then Predbat will assume unpublished import rates are higher by the given amount. Setting this to 1 to 1.5p for example results in Predbat being a little more aggressive in the charging calculation for today - Predbat will charge the battery to a higher percentage than it would otherwise as it expects a cost-benefit of using today's lower rates. NB: this can lead to higher costs and to some export if solar generation is better than forecast. input_number.predbat_metric_future_rate_offset_export ( expert mode ) Sets an offset to apply to future export energy rates that are not yet published, best used for variable rate tariffs such as Agile export where the rates are not published until 4pm. If you set this to a negative value then Predbat will assume unpublished export rates are lower by the given amount. switch.predbat_calculate_inday_adjustment ( expert mode ) Enabled by default with damping of 0.95. When enabled will calculate the difference between today's actual load and today's predicated load and adjust the rest of the day's usage prediction accordingly. A scale factor can be set with input_number.predbat_metric_inday_adjust_damping ( expert mode ) to either scale up or down the impact of the in-day adjustment (lower numbers scale down its impact). The in-day adjustment factor can be seen in predbat.load_inday_adjustment and charted with the In-Day Adjustment chart (template can be found in the charts template in Github). switch.predbat_metric_pv_calibration_enable When enabled allows Predbat to use historical data to calibrate your PV production estimates on a 30 minute basis based on actual data. This can be useful to adjust for your systems real performance. Default is Off. input_number.predbat_carbon_metric ( carbon enable ) When Carbon footprint tracking is enabled ( switch.predbat_carbon_enable ) you can specify a cost per Kg of CO2 used to weight the selection of plans. Values of around 10-200 will give varying outcomes to trade off cost vs carbon footprint of your system. Note: Carbon footprint tracking can only be enabled if apps.yaml is configured to point to the correct CO2 cost sensor","title":"Battery margins and metrics options"},{"location":"customisation/#inverter-control-options","text":"switch.predbat_set_status_notify Enables mobile notification about changes to the Predbat state (e.g. Charge, Export etc). On by default. switch.predbat_set_inverter_notify Enables mobile notification about all changes to inverter registers (e.g. setting window, turning discharge on/off). Off by default. switch.predbat_set_charge_low_power Enables low-power charging mode where the max charge rate will be automatically determined by Predbat to be the lowest possible rate to meet the charge target. This is only really effective for charge windows longer than 30 minutes. If this setting is turned on, it is strongly recommended that you create a battery_power_charge_curve in apps.yaml as otherwise the low power charge may not reach the charge target in time. This setting is off by default. The YouTube video low power charging and charging curve explains how the low-power charging works and shows how Predbat automatically creates it. input_number.predbat_charge_low_power_margin (requires switch.predbat_set_charge_low_power to be enabled) Controls how many minutes before the completion time to target finishing charging, this defaults to 10 but can be changed between 0 and 30. switch.predbat_set_reserve_enable ( expert_mode ) When enabled the reserve setting is used to hold the battery charge level once it has been reached or to protect against discharging beyond the set limit. Enabled by default. switch.predbat_set_export_freeze When enabled will allow Predbat to export Solar to the grid rather than charging the battery. Enabled by default on those inverters that have this support. switch.predbat_set_charge_freeze ( expert mode ) When enabled will allow Predbat to hold the current battery level while drawing from the grid/solar as an alternative to charging. Enabled by default. switch.predbat_set_export_freeze_only ( expert mode ) When enabled forced export is prevented, but export freeze can be used (if enabled) to export excess solar rather than charging the battery. This is useful with tariffs that pay you for solar exports but don't allow forced export (brown energy). If you have switch.predbat_inverter_hybrid set to False then if switch.predbat_inverter_soc_reset ( expert mode ) is set to True then the target SOC % will be reset to 100% outside of a charge window. This may be required for the AIO inverter to ensure it charges from solar. The default for this switch is True but it can be disabled in expert mode if need be. input_number.predbat_set_reserve_min Defines the battery reserve percentage, i.e. the minimum charge level that should be retained in the battery, a value of 4 is the minimum and recommended to make use of the full battery. When the battery level reaches the specified minimum level, your inverter will start importing from the grid to satisfy house load. If you want to pre-prepare the battery to retain extra charge in the event of a high likelihood of a grid power outage such as storms predicted, you can increase set_reserve_min to a higher value, and then change it back afterwards. (Obviously this is only any use if your inverter is wired to act as an Emergency Power Supply or whole-home backup 'island mode' on the GivEnergy AIO). Note that input_number.predbat_set_reserve_min is used by Predbat to stop the battery SoC dropping below the specified level but it is not used in planning battery charging. i.e. if you change the reserve min to a level higher than the current battery SoC then Predbat will not plan charging activity to increase the SoC to that level; you should set manual charges to increase the SoC level. switch.predbat_inverter_soc_reset ( expert mode ) When enabled the target SOC for the inverter(s) will be reset to 100% when a charge slot is not active, this can be used to workaround some firmware issues where the SOC target is used for solar charging as well as grid charging. When disabled the SOC % will not be changed after a charge slot. This is enabled by default.","title":"Inverter control options"},{"location":"customisation/#balance-inverters","text":"When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. The apps.yaml contains a setting balance_inverters_seconds which defines how often to run the balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Enable the switch.predbat_balance_inverters_enable switch in Home Assistant to enable this feature. switch.predbat_balance_inverters_charge - Is used to toggle on/off balancing while the batteries are charging switch.predbat_balance_inverters_discharge - Is used to toggle on/off balancing while the batteries are discharging switch.predbat_balance_inverters_crosscharge - Is used to toggle on/off balancing when the batteries are cross charging input_number.predbat_balance_inverters_threshold_charge - Sets the minimum percentage divergence of SoC during charge before balancing, default is 1% input_number.predbat_balance_inverters_threshold_discharge - Sets the minimum percentage divergence of SoC during discharge before balancing, default is 1%","title":"Balance Inverters"},{"location":"customisation/#cloud-coverage-and-load-variance","text":"Predbat tries to model passing clouds by modulating the PV forecast data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the difference between the PV50% (default) and PV10% scenario produced by Solcast. You can disable this feature ( expert mode only ) using switch.predbat_metric_cloud_enable Predbat tries to model changes in your household load by modulating the historical data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the standard deviation of your load predictions over the coming period (currently 4 hours). You can disable this feature ( expert mode only ) using switch.metric_load_divergence_enable","title":"Cloud coverage and load variance"},{"location":"customisation/#iboost-model-options","text":"Predbat has an 'iBoost model' that can be used to model using excess solar energy to heat hot water (or similar) instead of it being exported to the grid. This model can be used to control any solar diverter device, for example, an iBoost (e.g. using a Fingerbot or similar device to physically press the 'boost' button on the iBoost), a MyEnergy Eddi (using the MyEnergy integration), or it can be used with a high-power smart switch to turn on the hot water cylinder immersion heater when there is excess solar. So although Predbat refers to controlling an iBoost, you are not limited to just an iBoost device when using this model within Predbat. To turn the model on, switch.predbat_iboost_enable needs to be enabled. The predicted output from the iBoost solar diverter model is returned in predbat.iboost_best and is populated in the 'iBoost' column of the Predbat plan .","title":"iBoost model options"},{"location":"customisation/#iboost-basic-configuration","text":"When you turn on predbat_iBoost_enable the following additional Home Assistant entities are created by Predbat: input_number.predbat_iboost_max_energy Sets the maximum energy in kWh that the solar diverter can consume during a day before turning off - default 3kWh. input_number.predbat_iboost_max_power Sets the maximum power in watts that the solar diverter will consume - default 2400. input_number.predbat_iboost_min_power Sets the minimum power in watts that the solar diverter will consume - default 500. input_number.predbat_iboost_value_scaling Sets how to account for the value of iBoost units of energy. The default value of 0.75 means that each kWh of energy diverted is accounted for as 0.75 times The lowest future import rate. Higher values will generate plans with more solar diversion while lower values will generate less. A value of 0 means all diverted energy should be ignored in planning (assumed to be zero value). switch.predbat_iboost_energy_subtract When enabled (default) energy reported by the iboost_energy_today sensor configured in apps.yaml will be subtracted from your historical load data to improve the accuracy of predictions. If you are using PredAI you will also need to subtract this data inside PredAI configuration. Different boost modes can be selected:","title":"iBoost basic configuration"},{"location":"customisation/#iboost-modes","text":"","title":"iBoost modes"},{"location":"customisation/#solar","text":"switch.predbat_iboost_solar When enabled assume the diverter will use solar power to boost the hot water heating. switch.predbat_iboost_solar_excess When disabled will allow any solar power to be diverted while if enabled only excess power (power that would otherwise be exported) will be used. The default is Off. By default iboost will not run the battery is in force export mode unless you turn on switch.predbat_iboost_on_export input_number.predbat_iboost_min_soc sets the minimum home battery SoC percentage that must be in the battery before the solar diverter is turned on. The default is 0 meaning hot water heating can occur regardless of what SoC level the battery is at.","title":"Solar"},{"location":"customisation/#battery","text":"switch.predbat_iboost_charging If set to on, the diverter will operate when the battery is charging (can be combined with solar)","title":"Battery"},{"location":"customisation/#energy-rates-only","text":"If both of the above are off, but iBoost is enabled then boost will happen solely based on energy rates (see below). switch.predbat_iboost_smart Will pick the lowest import rate slots within 24 hours to achieve the desired energy as specified by input_number.predbat_iboost_max_energy . Only slots at or below the rate threshold will be selected. Note this option only applies when iboost_solar and iboost battery are both off. input_number.predbat_iboost_smart_min_length Sets the minimum slot length in minutes to iBoost (only applies for energy rate only modes). The default is 30 minutes but can be set in multiples of 30. Increasing this slot size could increase costs depending on your tariff. switch.predbat_iboost_on_export If set to on allows iBoost to run even if the battery is forced to export to the grid, otherwise it won't run in these circumstances. switch.iboost_prevent_discharge When set will stop your battery from discharging when iBoost is active and thus prevent your battery from draining to the diverter. This switch will work in all modes and is not recommended to be used when iBoost Solar is enabled as it will prevent your battery from discharging during excess solar periods which could cause additional imports due to passing clouds.","title":"Energy rates only"},{"location":"customisation/#iboost-energy-rate-filtering","text":"input_number.predbat_iboost_rate_threshold Sets the maximum import rate (in pence) that the diverter will trigger on, defaults to 100. input_number.predbat_iboost_rate_threshold_export Sets the maximum export rate (in pence) that the diverter will trigger on, defaults to 100. switch.predbat_iboost_gas When enabled will control the diverter to only operate when import electric rates are lower than gas rates. switch.predbat_iboost_gas_export When enabled will control the diverter to only operate when export electric rates are lower than gas rates. These can be useful if you have the choice to heat your hot water by immersion heater or by gas boiler. Note: Gas rates have to be configured in apps.yaml using metric_octopus_gas or rates_gas depending upon whether you are using the Octopus Integration or not. input_number.predbat_iboost_gas_scale Sets the scaling of the gas rates (set in apps.yaml )used before comparing with electric rates, to account for gas boiler losses and efficiency. It should be set to the reciprocal of the boiler efficiency, i.e. for an 80% efficient gas boiler, set to 1.25.","title":"iBoost energy rate filtering"},{"location":"customisation/#iboost-control","text":"","title":"iBoost control"},{"location":"customisation/#iboost-output-data","text":"You will see input_number.predbat_iboost_today entity which tracks the estimated kWh consumed by the solar diverter during the day, and resets at midnight every night. The binary_sensor.predbat_iboost_active entity will be enabled when the solar diverter should be active and can be used for automations to trigger the immersion heater boost. The attributes within this sensor include 'solar' which includes Solar diversion should be active and 'full' which indicates iBoost should run at maximum rate (could be during a charge cycle or grid import). Example template automation for controlling the solar diverter: alias: Solar Diverter description: \"Start/stop solar diverter based on Predbat-determined slots\" trigger: - platform: state entity_id: - binary_sensor.predbat_iboost_active action: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"True\" sequence: <commands to turn on your solar diverter> - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"False\" sequence: <commands to turn off your solar diverter> mode: single If you have an incrementing sensor that tracks the solar diverter energy usage then to make your predictions more accurate you should set the iboost_energy_today sensor in apps.yaml to point to it, and optionally set iboost_energy_scaling if the sensor isn't in kWh (e.g. set to 0.001 if the sensor is in Watts). The sensor should be an incrementing sensor which can reset at midnight or not.","title":"iBoost output data"},{"location":"customisation/#holiday-mode","text":"When you go away you are likely to use less electricity and so the previous load data will be quite pessimistic. Using the Home Assistant entity input_number.predbat_holiday_days_left you can set the number of full days that you will be away (including today). The number will count down by 1 day at midnight until it gets back to zero. Whilst the holiday days left are non-zero, Predbat's 'holiday mode' is active. When Predbat's 'holiday mode' is active the historical load data will be taken from yesterday's data (1 day ago) rather than from the days_previous setting in apps.yaml . This means Predbat will adjust more quickly to the new usage pattern. If you have been away for a longer period (more than your normal days_previous setting) then obviously it's going to take longer for the historical data to catch up, you could then enable holiday mode for another 7 days after your return. In summary: For short holidays set holiday_days_left to the number of full days you are away, including today but excluding the return day For longer holidays set holiday_days_left to the number of days you are away plus another 7 days until the data catches back up","title":"Holiday mode"},{"location":"customisation/#manual-control","text":"In some cases, you may want to override Predbat's planned behaviour and make a decision yourself. One way to achieve this is to put Predbat into read-only mode using switch.predbat_set_read_only . When going to read-only mode the inverter will be put back to the default settings and you should then control it yourself using GivTCP or the App appropriate to your inverter. A better alternative in some cases is to tell Predbat what you want it to do using the manual force features: You can force the battery to be charged within a 30-minute slot by using the select.predbat_manual_charge selector. Pick the 30-minute slot you wish to charge in, and Predbat will change the plan to charge in the selected slot. You can select multiple slots by using the drop-down menu more than once. When Predbat updates the plan you will see the slots picked to be charging slots in the current value of this selector, and annotated in the Predbat HTML plan with an upside down 'F' symbol. You can cancel a force slot by selecting the slot time again (it will be shown in square brackets to indicate it's already selected). The select.predbat_manual_export selector can be used to manually force an export within a 30-minute slot in the same way as the manual force charge feature. The force export takes priority over force charging. The select.predbat_manual_demand selector is used to force Predbat to demand mode during a 30-minute slot, this implies no forced grid charging or exporting of the battery. House load will be supplied from solar, or the battery if there is insufficient solar, or grid import if there is insufficient battery charge. This is described as 'ECO' Mode for GivEnergy inverters but other inverters use different terminology. The select.predbat_manual_freeze_charge selector is used to force Predbat to freeze charge during a 30-minute slot, this implies the battery will not discharge and hold at the current level. The grid may be used if solar is not enough to cover the load. The select.predbat_manual_freeze_export selector is used to force Predbat to freeze export during a 30-minute slot, this implies the battery will not charge but will still discharge for the house load. Any solar will be exported to the grid. When you use the manual override features you can only select times in the next 18 hours, the overrides will be removed once their time slot expires (they do not repeat). _NOTE: once you select a time slot from any of the select.predbat_manual_ selectors the selected time slot is immediately marked on the drop-down and you can then make another change. Predbat still has to update the plan which it will be doing so in the background, and this can take a few minutes to run (depending on the speed and power of the PC you are running Home Assistant on) so don't be surprised why the Predbat plan doesn't change immediately - remember you can see the date/time the plan was last updated on the first row of the plan. CAUTION: If you leave Predbat turned off for a long period of time then the override timeslots could end up repeating when you restart","title":"Manual control"},{"location":"customisation/#debug","text":"switch.predbat_debug_enable When on will create lots of debugging information to aid diagnosis of Predbat issues. By default this is turned off and its recommended that its only switched on when debug logs are requested. With the switch on: Firstly Predbat prints lots of extra debug information in the predbat logfile which means the logfile will fill and swap to a new file more rapidly Secondly Predbat will create a debug output file 'debug/predbat_debug_HH_MM_SS.yaml' in a subfolder of the Predbat installation directory. This file contains a full export of your current Predbat config and is extremely useful to enable recreating your setup to diagnose issues. Any sensitive information such as Solcast or GivEnergy Cloud API keys are automatically removed. The following automation might be useful to automatically turn off Predbat debug mode after turning it on to capture the debug logs: alias: \"Predbat: Auto turn-off debug mode\" description: \"\" triggers: - trigger: state entity_id: - switch.predbat_debug_enable to: \"on\" for: minutes: 10 conditions: [] actions: - action: script.notify_all_devices metadata: {} data: title: \"INFO: Turned off Predbat debug after 10 minutes\" critical: \"N\" url: \"\" message: switch.predbat_debug_enable turned off - action: switch.turn_off target: entity_id: switch.predbat_debug_enable data: {} mode: single switch.predbat_plan_debug ( expert mode ) when enabled adds some extra debug to the Predbat HTML plan - see Predbat Plan debug mode for more details.","title":"Debug"},{"location":"developing/","text":"Developing on Predbat Creating a fork Using GitHub, take a fork of Predbat - effectively, this creates a copy of the main repository, but in your personal space. There, you can create branches to develop on. Pull requests Once you've completed your work on your branch, you can create a pull request (PR) to merge your work back into the main branch of Predbat. This PR should describe the work you've done in a way that makes it easy for someone to review your work, and either add comments or approve it. Unit level testing Note you will need to install python_matplotlib (e.g. brew install python_matplotlib or pip install matplotlib) Predbat now has some unit-level tests, to run them on your local machine: Create a test directory somewhere Copy apps.yaml to your test area Copy the files from github https://github.com/springfall2008/batpred/tree/main/coverage to this area Extract cases.tgz Have /Volumes/add_configs/6adb4f0d_predbat point to your Predbat add-on directory or edit run_all to change the path Run run_all If the tests fail then debug them. For coverage analysis installed the 'coverage' library with Python run run_cov Open htmlcov/index.html in your web browser Editing the code There are at least a couple of ways of working on the code, outlined here. Using GitHub Codespaces What is GitHub Codespaces? Especially if you don't need to have a running Home Assistant system to make the changes you're interested in (e.g. for documentation, quick fixes etc.) a really easy way to work on the code is by using GitHub Codespaces. GitHub Codespaces gives you a full-featured development environment. This includes: A full IDE (a code editor), Visual Studio Code, which can be: Run in the browser, requiring no additional software to be installed Run in a virtual machine (VM) running in the cloud which can connect to a copy of VS Code installed on your own machine A terminal where you can run commands against your codebase e.g. running pre-commit to run the automatic code quality checks, linting files, etc. Software like mkdocs to re-generate the documentation files (and other software we may include) pre-installed in it The Codespaces environment is entirely separate from your HA installation, so does not require any modification to your HA setup to work with it. However, you are modifying code in an environment where you can't see HA running, so it's great for things like updating documentation, or writing automated tests, but not if you need to see your changes live within HA. Running GitHub Codespaces You may wish to first install VS Code on your machine, which does offer some benefits compared to running Codespaces in the cloud, but this is certainly not essential, and you'll see the same code editor and terminal, and you'll have the same commands and Python packages available in the terminal. The local installation is better in a small number of scenarios e.g. if you need to connect from your browser to a specific port on the VM, such as if you're working on the documentation. Importantly, even if you do a local install of VS Code and use that to edit your code within GitHub, the terminal, the code you're editing any commands that you run, and any processes like mkdocs that you may browse to are all running in the Codespaces VM. Your local VS Code is connected to the VM through SSH. It will appear as if the code, the terminal etc. are local, but they are not. Running a local VS Code install connected to Codespaces will not install Python, Python packages or anything else on your local machine. Now, from your fork or branch, click on the Code button, and select the Codespaces tab. You can create multiple environments, or use a single environment and swap between branches in it. Once you start your Codespaces environment, it will take a minute to create a VM for you, and to install the software we've asked it to install in there. It will also clone your repository and branch into it for you, and the VM will be authenticated with GitHub so you can commit and push straight back to your fork of Predbat on GitHub. You can choose between running the IDE in the browser or having your local installation of VS Code connects to the environment that GitHub Codespaces has created for you. The Codespaces will be already set up with Python, along with various Python packages (as defined in requirements.txt ). The environment is configured through the config in .devcontainer/devcontainer.json . Developing locally within Home Assistant To be documented later. Working on the documentation Overview of the Predbat documentation The documentation site at https://springfall2008.github.io/batpred/ is built from Markdown files in this repo. The Markdown files used to build the documentation are in the docs/ folder, with additional config for building the documentation site in mkdocs.yml . If you're making minor changes to the documentation e.g. fixing a spelling, you can just edit the Markdown files directly, and it will be pushed to the main documentation site as outlined in the documentation build process section below, once your changes are merged into main and released. However, if you're doing more than that, e.g. adding new sections, working with lists etc. we recommend you follow the instructions in working locally on the documentation below, as this will give you a live preview of what the documentation will look like once it's built and published. This will avoid any unexpected results appearing in the main documentation site. If you are adding a new file, please ensure you add that file to mkdocs.yml , so it will be linked from the menu in the sidebar. The documentation build process The documentation for the site is built using mkdocs , which will already be installed if you're using a GitHub Codespaces environment. For a detailed explanation of mkdocs features, please read the mkdocs documentation . As briefly covered above, mkdocs.yml contains the config for defining the documentation site, and the documentation is built by mkdocs reading the Markdown files in the docs/ folder, and creating HTML files from those files. mkdocs can be used locally for previewing, but is also used as part of the documentation build process that publishes the official documentation site. The publishing of the documentation is triggered by a GitHub action, as defined in .github/workflows/main.yml . In short, after configuring the build environment, mkdocs builds the site then pushes the HTML produced to the gh-pages branch, overwriting whatever was there previously. GitHub will then detect a new commit on the gh-pages branch, and that will trigger another action to run (as defined by GitHub). This action will take the HTML files on the gh-pages branch and will make them available at https://springfall2008.github.io/batpred/ . The documentation will be published as it is, with no further review process, so please ensure you check the documentation that will be built before merging it in. Working locally on the documentation If you are making changes to the documentation, you can see a live preview version of the documentation as it will be built and deployed. This preview version is local to your environment, is temporary, and does not impact the published version in any way. It's recommended for anything other than simple changes like fixing spelling, or adding a sentence or two. Things like new sections, lists, new pages etc. are best previewed due to the complications of various Markdown standards, as what works on GitHub READMEs, for example, does not necessarily work with the published documentation site (which follows a more strict Markdown standard). There are a number of terminal commands that you can use in the Codespaces environment. Open a terminal window in Codespaces by choosing Menu> Terminal > New Terminal. To run the live preview, enter mkdocs serve in the terminal window - this will cause mkdocs to build a local temporary version of the documentation site, and to temporarily publish it on port 8000 - it will show the link where you can access the documentation. Also, it will watch the docs/ folder, and any time you change the files, it will rebuild the site, allowing you to see changes to the Markdown files in your browser within a few seconds. The site will continue being served until you press CTRL-C to end the mkdocs serve command. Note, accessing the site published by mkdocs serve is not possible if you are using Codespaces to run VS Code in the browser, but it is possible if you're using it via VS Code running locally, due to how ports on your environment are shared. Coding standards Expected standards This section will be enhanced following discussions as we go. However, here's a starting point: Variable names should be lower_case_with_underscores - this fits with most existing variables, is a common standard for Python code, and also allows the spell checking to check individual words within the variable name. Enforced standards Certain coding standards are enforced within the repository. Some of them can be auto-fixed if you do a commit that fails one of those standards; other issues will need fixing first, as your pull request won't merge in GitHub until it passes. These standards are enforced by pre-commit , a tool which can run other tools to check, and potentially fix (for certain types of issues) any mistakes you've made. The .pre-commit-config.yaml file lists all checks that are currently carried out within the repository. Bear in mind that these checks are done according to the config within that file in the branch that you are working in, so if someone adds a new check, or changes some of the related settings, it won't apply on your branch until you've merged in their changes. Some of the tools have their own related config files: CSpell - .cspell.json and .cspell/custom-dictionary-workspace.txt Black - pyproject.toml Markdown Lint - .markdownlint.jsonc Additional notes on some of the standards: CSpell - if you have the spelling check failing due to a valid word which is not in the in-built dictionary, please add that word to the end of .cspell/custom-dictionary-workspace.txt and stage those changes. The spell-check should then pass. Note, that the dictionary file will get re-sorted alphabetically when you run pre-commit , so you'll need to re-stage the file after it's been sorted. Running the checks locally If you are using a Codespaces environment, you'll already have pre-commit installed automatically. You can run it manually, or automatically. Running pre-commit manually: In a terminal window, running pre-commit will run all the checks against any files that you have modified and staged. Alternatively, running pre-commit run --all-files will run all the checks against all files within the repository. Note that if pre-commit makes any changes to any files when it runs, those changes will not be staged. You will need to stage those changes too before committing. You may notice pre-commit mentioning about stashing changes - this is because when it runs, any changes that aren't staged are stashed (saved away temporarily) so it runs against only the staged changes; after it has run, it pulls back those stashed changes, so they appear again (still unstaged). Running pre-commit automatically: If you run pre-commit install in a terminal window it will install a pre-commit hook - this is a file which tells git to run some code for each type you do a particular action (a pre-commit hook runs at the start of processing a commit, but there are other hooks e.g. pre-push). Now, any time you perform a commit, pre-commit will run automatically on the staged files - this is a handy way of making sure that you don't accidentally commit code which will fail checks later. You can still run it manually as outlined above, in addition to the automated checks that it will do on commits. Running the checks from within GitHub When commits are done on pull requests, and in any other scenarios added to the on section of .github/workflows/linting.yml , the GitHub Actions in that file will run. In particular, the pre-commit.ci lite action will run. This uses the code here to run the same checks that get run locally (as described in the .pre-commit-config.yaml file). This will cause your commit, branch or pull request to get either a green tick or a red cross against it, to show whether the code passed the checks or not. This will happen automatically when you push code on a branch that has a pull request. In addition, if pre-commit finds any errors it can fix (e.g. a missing blank line at the end of a file, or trailing whitespace), it will make a commit of its own to fix those problems and will push that commit back to your branch on GitHub. This will then trigger another run, which should now pass. Note : This means that pre-commit will be adding commits to your branch - this will need you to be pulling changes from GitHub so you pick up the changes that have been added by pre-commit otherwise, you will hit a problem when you next try to push a commit on your branch. You can pull in those changes by running git pull , which is the equivalent of running git fetch and then git merge . This is no different to working on the same branch with another developer, but it will be different to the workflow most of us have when working on Predbat.","title":"Developing on Predbat"},{"location":"developing/#developing-on-predbat","text":"","title":"Developing on Predbat"},{"location":"developing/#creating-a-fork","text":"Using GitHub, take a fork of Predbat - effectively, this creates a copy of the main repository, but in your personal space. There, you can create branches to develop on.","title":"Creating a fork"},{"location":"developing/#pull-requests","text":"Once you've completed your work on your branch, you can create a pull request (PR) to merge your work back into the main branch of Predbat. This PR should describe the work you've done in a way that makes it easy for someone to review your work, and either add comments or approve it.","title":"Pull requests"},{"location":"developing/#unit-level-testing","text":"Note you will need to install python_matplotlib (e.g. brew install python_matplotlib or pip install matplotlib) Predbat now has some unit-level tests, to run them on your local machine: Create a test directory somewhere Copy apps.yaml to your test area Copy the files from github https://github.com/springfall2008/batpred/tree/main/coverage to this area Extract cases.tgz Have /Volumes/add_configs/6adb4f0d_predbat point to your Predbat add-on directory or edit run_all to change the path Run run_all If the tests fail then debug them. For coverage analysis installed the 'coverage' library with Python run run_cov Open htmlcov/index.html in your web browser","title":"Unit level testing"},{"location":"developing/#editing-the-code","text":"There are at least a couple of ways of working on the code, outlined here.","title":"Editing the code"},{"location":"developing/#using-github-codespaces","text":"","title":"Using GitHub Codespaces"},{"location":"developing/#what-is-github-codespaces","text":"Especially if you don't need to have a running Home Assistant system to make the changes you're interested in (e.g. for documentation, quick fixes etc.) a really easy way to work on the code is by using GitHub Codespaces. GitHub Codespaces gives you a full-featured development environment. This includes: A full IDE (a code editor), Visual Studio Code, which can be: Run in the browser, requiring no additional software to be installed Run in a virtual machine (VM) running in the cloud which can connect to a copy of VS Code installed on your own machine A terminal where you can run commands against your codebase e.g. running pre-commit to run the automatic code quality checks, linting files, etc. Software like mkdocs to re-generate the documentation files (and other software we may include) pre-installed in it The Codespaces environment is entirely separate from your HA installation, so does not require any modification to your HA setup to work with it. However, you are modifying code in an environment where you can't see HA running, so it's great for things like updating documentation, or writing automated tests, but not if you need to see your changes live within HA.","title":"What is GitHub Codespaces?"},{"location":"developing/#running-github-codespaces","text":"You may wish to first install VS Code on your machine, which does offer some benefits compared to running Codespaces in the cloud, but this is certainly not essential, and you'll see the same code editor and terminal, and you'll have the same commands and Python packages available in the terminal. The local installation is better in a small number of scenarios e.g. if you need to connect from your browser to a specific port on the VM, such as if you're working on the documentation. Importantly, even if you do a local install of VS Code and use that to edit your code within GitHub, the terminal, the code you're editing any commands that you run, and any processes like mkdocs that you may browse to are all running in the Codespaces VM. Your local VS Code is connected to the VM through SSH. It will appear as if the code, the terminal etc. are local, but they are not. Running a local VS Code install connected to Codespaces will not install Python, Python packages or anything else on your local machine. Now, from your fork or branch, click on the Code button, and select the Codespaces tab. You can create multiple environments, or use a single environment and swap between branches in it. Once you start your Codespaces environment, it will take a minute to create a VM for you, and to install the software we've asked it to install in there. It will also clone your repository and branch into it for you, and the VM will be authenticated with GitHub so you can commit and push straight back to your fork of Predbat on GitHub. You can choose between running the IDE in the browser or having your local installation of VS Code connects to the environment that GitHub Codespaces has created for you. The Codespaces will be already set up with Python, along with various Python packages (as defined in requirements.txt ). The environment is configured through the config in .devcontainer/devcontainer.json .","title":"Running GitHub Codespaces"},{"location":"developing/#developing-locally-within-home-assistant","text":"To be documented later.","title":"Developing locally within Home Assistant"},{"location":"developing/#working-on-the-documentation","text":"","title":"Working on the documentation"},{"location":"developing/#overview-of-the-predbat-documentation","text":"The documentation site at https://springfall2008.github.io/batpred/ is built from Markdown files in this repo. The Markdown files used to build the documentation are in the docs/ folder, with additional config for building the documentation site in mkdocs.yml . If you're making minor changes to the documentation e.g. fixing a spelling, you can just edit the Markdown files directly, and it will be pushed to the main documentation site as outlined in the documentation build process section below, once your changes are merged into main and released. However, if you're doing more than that, e.g. adding new sections, working with lists etc. we recommend you follow the instructions in working locally on the documentation below, as this will give you a live preview of what the documentation will look like once it's built and published. This will avoid any unexpected results appearing in the main documentation site. If you are adding a new file, please ensure you add that file to mkdocs.yml , so it will be linked from the menu in the sidebar.","title":"Overview of the Predbat documentation"},{"location":"developing/#the-documentation-build-process","text":"The documentation for the site is built using mkdocs , which will already be installed if you're using a GitHub Codespaces environment. For a detailed explanation of mkdocs features, please read the mkdocs documentation . As briefly covered above, mkdocs.yml contains the config for defining the documentation site, and the documentation is built by mkdocs reading the Markdown files in the docs/ folder, and creating HTML files from those files. mkdocs can be used locally for previewing, but is also used as part of the documentation build process that publishes the official documentation site. The publishing of the documentation is triggered by a GitHub action, as defined in .github/workflows/main.yml . In short, after configuring the build environment, mkdocs builds the site then pushes the HTML produced to the gh-pages branch, overwriting whatever was there previously. GitHub will then detect a new commit on the gh-pages branch, and that will trigger another action to run (as defined by GitHub). This action will take the HTML files on the gh-pages branch and will make them available at https://springfall2008.github.io/batpred/ . The documentation will be published as it is, with no further review process, so please ensure you check the documentation that will be built before merging it in.","title":"The documentation build process"},{"location":"developing/#working-locally-on-the-documentation","text":"If you are making changes to the documentation, you can see a live preview version of the documentation as it will be built and deployed. This preview version is local to your environment, is temporary, and does not impact the published version in any way. It's recommended for anything other than simple changes like fixing spelling, or adding a sentence or two. Things like new sections, lists, new pages etc. are best previewed due to the complications of various Markdown standards, as what works on GitHub READMEs, for example, does not necessarily work with the published documentation site (which follows a more strict Markdown standard). There are a number of terminal commands that you can use in the Codespaces environment. Open a terminal window in Codespaces by choosing Menu> Terminal > New Terminal. To run the live preview, enter mkdocs serve in the terminal window - this will cause mkdocs to build a local temporary version of the documentation site, and to temporarily publish it on port 8000 - it will show the link where you can access the documentation. Also, it will watch the docs/ folder, and any time you change the files, it will rebuild the site, allowing you to see changes to the Markdown files in your browser within a few seconds. The site will continue being served until you press CTRL-C to end the mkdocs serve command. Note, accessing the site published by mkdocs serve is not possible if you are using Codespaces to run VS Code in the browser, but it is possible if you're using it via VS Code running locally, due to how ports on your environment are shared.","title":"Working locally on the documentation"},{"location":"developing/#coding-standards","text":"","title":"Coding standards"},{"location":"developing/#expected-standards","text":"This section will be enhanced following discussions as we go. However, here's a starting point: Variable names should be lower_case_with_underscores - this fits with most existing variables, is a common standard for Python code, and also allows the spell checking to check individual words within the variable name.","title":"Expected standards"},{"location":"developing/#enforced-standards","text":"Certain coding standards are enforced within the repository. Some of them can be auto-fixed if you do a commit that fails one of those standards; other issues will need fixing first, as your pull request won't merge in GitHub until it passes. These standards are enforced by pre-commit , a tool which can run other tools to check, and potentially fix (for certain types of issues) any mistakes you've made. The .pre-commit-config.yaml file lists all checks that are currently carried out within the repository. Bear in mind that these checks are done according to the config within that file in the branch that you are working in, so if someone adds a new check, or changes some of the related settings, it won't apply on your branch until you've merged in their changes. Some of the tools have their own related config files: CSpell - .cspell.json and .cspell/custom-dictionary-workspace.txt Black - pyproject.toml Markdown Lint - .markdownlint.jsonc Additional notes on some of the standards: CSpell - if you have the spelling check failing due to a valid word which is not in the in-built dictionary, please add that word to the end of .cspell/custom-dictionary-workspace.txt and stage those changes. The spell-check should then pass. Note, that the dictionary file will get re-sorted alphabetically when you run pre-commit , so you'll need to re-stage the file after it's been sorted.","title":"Enforced standards"},{"location":"developing/#running-the-checks-locally","text":"If you are using a Codespaces environment, you'll already have pre-commit installed automatically. You can run it manually, or automatically. Running pre-commit manually: In a terminal window, running pre-commit will run all the checks against any files that you have modified and staged. Alternatively, running pre-commit run --all-files will run all the checks against all files within the repository. Note that if pre-commit makes any changes to any files when it runs, those changes will not be staged. You will need to stage those changes too before committing. You may notice pre-commit mentioning about stashing changes - this is because when it runs, any changes that aren't staged are stashed (saved away temporarily) so it runs against only the staged changes; after it has run, it pulls back those stashed changes, so they appear again (still unstaged). Running pre-commit automatically: If you run pre-commit install in a terminal window it will install a pre-commit hook - this is a file which tells git to run some code for each type you do a particular action (a pre-commit hook runs at the start of processing a commit, but there are other hooks e.g. pre-push). Now, any time you perform a commit, pre-commit will run automatically on the staged files - this is a handy way of making sure that you don't accidentally commit code which will fail checks later. You can still run it manually as outlined above, in addition to the automated checks that it will do on commits.","title":"Running the checks locally"},{"location":"developing/#running-the-checks-from-within-github","text":"When commits are done on pull requests, and in any other scenarios added to the on section of .github/workflows/linting.yml , the GitHub Actions in that file will run. In particular, the pre-commit.ci lite action will run. This uses the code here to run the same checks that get run locally (as described in the .pre-commit-config.yaml file). This will cause your commit, branch or pull request to get either a green tick or a red cross against it, to show whether the code passed the checks or not. This will happen automatically when you push code on a branch that has a pull request. In addition, if pre-commit finds any errors it can fix (e.g. a missing blank line at the end of a file, or trailing whitespace), it will make a commit of its own to fix those problems and will push that commit back to your branch on GitHub. This will then trigger another run, which should now pass. Note : This means that pre-commit will be adding commits to your branch - this will need you to be pulling changes from GitHub so you pick up the changes that have been added by pre-commit otherwise, you will hit a problem when you next try to push a commit on your branch. You can pull in those changes by running git pull , which is the equivalent of running git fetch and then git merge . This is no different to working on the same branch with another developer, but it will be different to the workflow most of us have when working on Predbat.","title":"Running the checks from within GitHub"},{"location":"devices/","text":"Support 3rd party devices/integrations This section of the documentation describes the configuration required for different 3rd party devices/integrations, typically EV chargers. If you have a device not listed then please raise a GitHub ticket with your configuration. Wallbox Pulsar https://www.home-assistant.io/integrations/wallbox/ Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.wallbox_portal_added_energy' car_charging_planned: - 're:sensor.wallbox_portal_status_description' Wallbox works with Octopus Intelligent GO and can be triggered via Octopus themselves or an HA automation linked to the Predbat slot sensor Zappi https://github.com/CJNE/ha-myenergi Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.myenergi_zappi_[0-9a-z]+_charge_added_session' car_charging_planned: - 're:sensor.myenergi_zappi_[0-9a-z]+_plug_status)' Tesla https://github.com/alandtse/tesla Can be used to extract the car's current SoC and Charge limit. Also can be used to control the cars charging with an automation linked to the Predbat slot sensor car_charging_limit: - 're:number.xxx_charge_limit' car_charging_soc: - 're:sensor.xxx_battery' Toyota https://github.com/DurgNomis-drol/ha_toyota - For Toyota EU cars only Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.toyota_XXX_battery_level' Example sensor name for BZ4X - sensor.toyota_bz4x_battery_level Renault https://www.home-assistant.io/integrations/renault Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.battery' New Ohme Integration https://www.home-assistant.io/integrations/ohme The in-built Home Assistant Ohme integration can be used with Predbat both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy ohme_name: 're:time.ohme_(.+)_target_time' car_charging_energy: 'sensor.ohme_{ohme_name}_energy' Car charging planned car_charging_planned: - \"sensor.ohme_{ohme_name}_status\" car_charging_planned_response: - \"yes\" - \"on\" - \"true\" - \"connected\" - \"ev connected\" - \"charging\" - \"paused\" - \"waiting for car demand\" - \"waiting for ev\" - \"scheduled\" - \"enabled\" - \"latched\" - \"locked\" - \"plugged in\" - \"plugged_in\" - \"Plugged in\" - \"pending_approval\" Octopus Intelligent GO Replace XXX with your device ID which can be found by going to 'Developer Tools', Selecting 'Actions', Selecting 'Ohme: List Charge Slots' then selecting your Device from the drop down menu. Then click on 'Go to YAML mode' and copy the long string after config_entry: octopus_intelligent_slot: 'ohme.list_charge_slots' octopus_intelligent_slot_action_config: 'XXX' octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Old Ohme HACS Integration https://github.com/dan-r/HomeAssistant-Ohme Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy car_charging_energy: 'sensor.ohme_session_energy' Octopus Intelligent GO octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percent' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Determine if the car is charging now Normally not recommended if you are on Intelligent GO, but can be useful for ad-hoc charging not planned via Predbat car_charging_now: - 'binary_sensor.ohme_car_charging' PodPoint https://github.com/mattrayner/pod-point-home-assistant-component Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. car_charging_energy: 're:(sensor.psl_[0-9]+_current_energy)' car_charging_planned: - 're:(sensor.psl_[0-9]+_status)' car_charging_planned_response: - 'plugged in' - 'connected-waiting-for-schedule' - 'suspended-evse' - 'pending' - 'charging' car_charging_now: - 're:(sensor.psl_[0-9]+_status)' car_charging_now_response: - 'charging' Also can be used to control the cars charging with an automation linked to the Predbat slot sensor. The device needs to be set to 'Smart' mode in the PodPoint app. Your automation trigger should then set the switch.psl_XXXXXX_charging_allowed to on. And off to stop charging. This uses the PodPoint schedule override setting to start/stop the charge. Hypervolt https://github.com/gndean/home-assistant-hypervolt-charger Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in (only V3 models). For plugged-in detection on V2 models, see guidance https://springfall2008.github.io/batpred/car-charging/#example-ev-and-charger-setup . car_charging_energy: 're:(sensor.hypervolt_session_energy_total_increasing)' car_charging_planned: - 're:(binary_sensor.hypervolt_car_plugged)' car_charging_planned_response: - 'on' car_charging_now: - 're:(sensor.hypervolt_charging_readiness)' car_charging_now_response: - 'charging' Note: sensor.hypervolt_session_energy_total_increasing defaults to 'unknown' between charging sessions. Agile Tariff To automate the schedule charging with Predbat, set up the automation to detect when there is a change to binary_sensor.predbat_car_charging_slot . Ensure that select.hypervolt_charge_mode is in 'Boost', when Predbat charging slot is 'on', set select.hypervolt_activation_mode to 'Plug and Charge', when it is 'off' set the 'Schedule', this is the recommended method for start/stop charging. Octopus Energy https://github.com/BottlecapDave/HomeAssistant-OctopusEnergy Can be used for energy rates, car charging and saving sessions For energy rate metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)' metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)' For Octopus Intelligent GO octopus_intelligent_slot: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_intelligent_dispatching)' octopus_ready_time: 're:(time.octopus_energy([0-9a-z_]+|)_intelligent_ready_time)' octopus_charge_limit: 're:(number.octopus_energy([0-9a-z_]+|)_intelligent_charge_limit)' For Octopus Saving sessions octopus_saving_session: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_saving_session(s|))' octopus_saving_session_octopoints_per_penny: 8 Nordpool For adjustment to Octopus Intelligent This is built into Predbat, see the apps.yaml configuration guide As your energy rates (e.g. for those in Norway) https://github.com/custom-components/nordpool/ Can be linked to Predbat to provide energy rates in your region e.g: metric_octopus_import: 'sensor.nordpool_kwh_oslo_eur_3_10_025' Solcast https://github.com/BJReplay/ha-solcast-solar For solar forecast data pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))","title":"Support 3rd party devices/integrations"},{"location":"devices/#support-3rd-party-devicesintegrations","text":"This section of the documentation describes the configuration required for different 3rd party devices/integrations, typically EV chargers. If you have a device not listed then please raise a GitHub ticket with your configuration.","title":"Support 3rd party devices/integrations"},{"location":"devices/#wallbox-pulsar","text":"https://www.home-assistant.io/integrations/wallbox/ Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.wallbox_portal_added_energy' car_charging_planned: - 're:sensor.wallbox_portal_status_description' Wallbox works with Octopus Intelligent GO and can be triggered via Octopus themselves or an HA automation linked to the Predbat slot sensor","title":"Wallbox Pulsar"},{"location":"devices/#zappi","text":"https://github.com/CJNE/ha-myenergi Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.myenergi_zappi_[0-9a-z]+_charge_added_session' car_charging_planned: - 're:sensor.myenergi_zappi_[0-9a-z]+_plug_status)'","title":"Zappi"},{"location":"devices/#tesla","text":"https://github.com/alandtse/tesla Can be used to extract the car's current SoC and Charge limit. Also can be used to control the cars charging with an automation linked to the Predbat slot sensor car_charging_limit: - 're:number.xxx_charge_limit' car_charging_soc: - 're:sensor.xxx_battery'","title":"Tesla"},{"location":"devices/#toyota","text":"https://github.com/DurgNomis-drol/ha_toyota - For Toyota EU cars only Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.toyota_XXX_battery_level' Example sensor name for BZ4X - sensor.toyota_bz4x_battery_level","title":"Toyota"},{"location":"devices/#renault","text":"https://www.home-assistant.io/integrations/renault Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.battery'","title":"Renault"},{"location":"devices/#new-ohme-integration","text":"https://www.home-assistant.io/integrations/ohme The in-built Home Assistant Ohme integration can be used with Predbat both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy ohme_name: 're:time.ohme_(.+)_target_time' car_charging_energy: 'sensor.ohme_{ohme_name}_energy' Car charging planned car_charging_planned: - \"sensor.ohme_{ohme_name}_status\" car_charging_planned_response: - \"yes\" - \"on\" - \"true\" - \"connected\" - \"ev connected\" - \"charging\" - \"paused\" - \"waiting for car demand\" - \"waiting for ev\" - \"scheduled\" - \"enabled\" - \"latched\" - \"locked\" - \"plugged in\" - \"plugged_in\" - \"Plugged in\" - \"pending_approval\" Octopus Intelligent GO Replace XXX with your device ID which can be found by going to 'Developer Tools', Selecting 'Actions', Selecting 'Ohme: List Charge Slots' then selecting your Device from the drop down menu. Then click on 'Go to YAML mode' and copy the long string after config_entry: octopus_intelligent_slot: 'ohme.list_charge_slots' octopus_intelligent_slot_action_config: 'XXX' octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged.","title":"New Ohme Integration"},{"location":"devices/#old-ohme-hacs-integration","text":"https://github.com/dan-r/HomeAssistant-Ohme Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy car_charging_energy: 'sensor.ohme_session_energy' Octopus Intelligent GO octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percent' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Determine if the car is charging now Normally not recommended if you are on Intelligent GO, but can be useful for ad-hoc charging not planned via Predbat car_charging_now: - 'binary_sensor.ohme_car_charging'","title":"Old Ohme HACS Integration"},{"location":"devices/#podpoint","text":"https://github.com/mattrayner/pod-point-home-assistant-component Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. car_charging_energy: 're:(sensor.psl_[0-9]+_current_energy)' car_charging_planned: - 're:(sensor.psl_[0-9]+_status)' car_charging_planned_response: - 'plugged in' - 'connected-waiting-for-schedule' - 'suspended-evse' - 'pending' - 'charging' car_charging_now: - 're:(sensor.psl_[0-9]+_status)' car_charging_now_response: - 'charging' Also can be used to control the cars charging with an automation linked to the Predbat slot sensor. The device needs to be set to 'Smart' mode in the PodPoint app. Your automation trigger should then set the switch.psl_XXXXXX_charging_allowed to on. And off to stop charging. This uses the PodPoint schedule override setting to start/stop the charge.","title":"PodPoint"},{"location":"devices/#hypervolt","text":"https://github.com/gndean/home-assistant-hypervolt-charger Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in (only V3 models). For plugged-in detection on V2 models, see guidance https://springfall2008.github.io/batpred/car-charging/#example-ev-and-charger-setup . car_charging_energy: 're:(sensor.hypervolt_session_energy_total_increasing)' car_charging_planned: - 're:(binary_sensor.hypervolt_car_plugged)' car_charging_planned_response: - 'on' car_charging_now: - 're:(sensor.hypervolt_charging_readiness)' car_charging_now_response: - 'charging' Note: sensor.hypervolt_session_energy_total_increasing defaults to 'unknown' between charging sessions. Agile Tariff To automate the schedule charging with Predbat, set up the automation to detect when there is a change to binary_sensor.predbat_car_charging_slot . Ensure that select.hypervolt_charge_mode is in 'Boost', when Predbat charging slot is 'on', set select.hypervolt_activation_mode to 'Plug and Charge', when it is 'off' set the 'Schedule', this is the recommended method for start/stop charging.","title":"Hypervolt"},{"location":"devices/#octopus-energy","text":"https://github.com/BottlecapDave/HomeAssistant-OctopusEnergy Can be used for energy rates, car charging and saving sessions For energy rate metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)' metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)' For Octopus Intelligent GO octopus_intelligent_slot: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_intelligent_dispatching)' octopus_ready_time: 're:(time.octopus_energy([0-9a-z_]+|)_intelligent_ready_time)' octopus_charge_limit: 're:(number.octopus_energy([0-9a-z_]+|)_intelligent_charge_limit)' For Octopus Saving sessions octopus_saving_session: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_saving_session(s|))' octopus_saving_session_octopoints_per_penny: 8","title":"Octopus Energy"},{"location":"devices/#nordpool","text":"","title":"Nordpool"},{"location":"devices/#for-adjustment-to-octopus-intelligent","text":"This is built into Predbat, see the apps.yaml configuration guide","title":"For adjustment to Octopus Intelligent"},{"location":"devices/#as-your-energy-rates-eg-for-those-in-norway","text":"https://github.com/custom-components/nordpool/ Can be linked to Predbat to provide energy rates in your region e.g: metric_octopus_import: 'sensor.nordpool_kwh_oslo_eur_3_10_025'","title":"As your energy rates (e.g. for those in Norway)"},{"location":"devices/#solcast","text":"https://github.com/BJReplay/ha-solcast-solar For solar forecast data pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))","title":"Solcast"},{"location":"energy-rates/","text":"Energy rates Predbat needs to know what your Import and (optionally) Export rates are so it can plan the optimal way to use your battery. Your Import and Export rates can be simple flat rates, more complex time-of-day tariffs (e.g. Economy 7, Octopus Flux), or daily/half-hourly rates that track electricity market prices (e.g. Octopus Agile or Tracker). Energy rates are all configured in the apps.yaml file that's stored in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/batpred/config/ directory depending on what type of Predbat installation method you have used . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to edit this file - see editing configuration files within Home Assistant if you need to install an editor. There are four different ways of configuring your Energy rates in apps.yaml , using Octopus Energy Direct , using the Octopus Energy Integration , using Octopus Rates URL's , or manually defining your rates and time periods . At least one of these methods must be used to define your import and export rates. If you don't then Predbat will assume zero for your energy rates. Octopus Energy direct If your electricity supplier is Octopus Energy then the simplest way to provide Predbat with your electricity pricing information is to connect Predbat directly to Octopus. This method will not work correctly if you have multiple import or export meters. A single Octopus Intelligent GO car charger or car is supported. Saving sessions are also support, including auto-enroll. You should first log into your Octopus account and go to the Accounts section and copy your account number e.g. A-1234567. Then go to the API Access page where you can copy your API key e.g. sk_live_1as12355... Put these both into your apps.yaml and you are done. octopus_api_account: 'XXXXXXXX' octopus_api_key: 'sk_live_yyyyyyyy' Free energy sessions: Predbat can scrape directly from the Octopus Web Site, this may have its own issues due to a change of format. If you enable this then sessions will be considered even if you forget to sign-up so be careful! octopus_free_url: 'http://octopus.energy/free-electricity' Octopus Energy Home Assistant Integration Octopus Energy integration setup Instead of using Octopus Energy Direct Predbat can also work with the Octopus Energy integration , this bring greater configurability than the direct method. The Octopus Energy integration connects to your Octopus Energy account and retrieves the tariffs you are on, and the current tariff rates. If you change tariff within Octopus the integration will automatically retrieve the updated tariff information, and as tariff prices change, again they are automatically retrieved. The integration also provides support for Intelligent Octopus charging to support car charging. Follow the instructions provided in the Octopus Energy integration documentation to install and set up the integration. Once installed, you will need to configure the integration (go to Settings / Devices & Services / Integrations / Octopus Energy then click 'Configure') and provide the integration with your 'Octopus API key' (that you obtain from your Octopus account: Personal Details / API access). CAUTION To get detailed energy rates needed by Predbat you need to go into Home Assistant and manually enable the following Octopus Energy events which are disabled by default when the integration is installed: event.octopus_energy_electricity_xxxxxxxx_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_current_day_rates event.octopus_energy_electricity_xxxxxxxx_next_day_rates event.octopus_energy_electricity_xxxxxxxx_export_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_export_current_day_rates event.octopus_energy_electricity_xxxxxxxx_export_next_day_rates event.octopus_energy_gas_xxxxxxxx_previous_day_rates event.octopus_energy_gas_xxxxxxxx_current_day_rates event.octopus_energy_gas_xxxxxxxx_next_day_rates To enable the above events: Go to Settings / Devices & Services / Integrations, choose Octopus Energy, then xx entities You will see a list of entities (and events) supplied by the Octopus integration Click the 'Filter' symbol on the top right-hand corner (a series of lines in a downwards pointing arrow) and make sure all the options are selected Then in the left-hand-side search entities box, type \"current_day\" Click on the first event that comes up, check the name is the right one Click the cog wheel, then you should see the option to enable the event Click the option to enable the event and press 'Update' to make the change Repeat this for the other events. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas. Verify that the integration is working correctly in Home Assistant by going to Developer Tools / States, and entering 'octopus' in the 'Filter entities' box. Confirm that the Octopus entities are being populated correctly. Configuring Predbat to use the Octopus Energy integration The following configuration items in apps.yaml are used to configure Predbat to use the Octopus Energy integration. They are set to a regular expression and should be auto-discovered so that Predbat automatically uses the Octopus Energy integration, but you can comment out the regular expression lines to disable, or you set them manually. metric_octopus_import - Import rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_current_rate metric_octopus_export - Export rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_export_current_rate metric_octopus_gas - Gas rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_gas_METER_NUMBER_current_rate octopus_intelligent_slot - If you have the Octopus Intelligent Go tariff this should point to the 'slot' sensor binary_sensor.octopus_energy_ACCOUNT_ID_intelligent_dispatching metric_octopus_gas is (as above) only required to be configured if you are using Predbat to determine whether to heat your hot water via your iBoost or gas. If you do not have an export rate or are not on the Octopus Go tariff, then the appropriate lines can be commented out in apps.yaml. Standing charge Predbat can also (optionally) include the daily standing charge in cost predictions. The following configuration item in apps.yaml defaults to obtaining the standing charge from the Octopus Energy integration: metric_standing_charge - Standing charge in pounds. By default points to the Octopus Energy integration sensor sensor.octopus_energy_electricity_METER_NUMBER_current_standing_charge You can manually change this to a standing charge in pounds, e.g. 0.50 is 50p, or delete this line from apps.yaml, or set it to zero if you don't want the standing charge (and only have consumption usage) to be included in Predbat charts and output data. Octopus Saving sessions Predbat can automatically join you to Octopus saving sessions and plan battery activity for the saving session period to maximise your income. For Predbat to automatically manage Octopus saving sessions the following additional configuration item in apps.yaml is used. Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_saving_session - Indicates if a saving session is active, should point to the sensor binary_sensor.octopus_energy_ACCOUNT_ID_octoplus_saving_sessions. When a saving session is available it will be automatically joined by Predbat and should then appear as a joined session within the next 30 minutes. NOTE: Predbat automatically joining the saving session relies upon the event being enabled and Predbat being able to find the saving session event as 'event.octopus_energy_ACCOUNT_ID_octoplus_saving_session_events' - there have been occasions with some Octopus Integration installations where the event name is different. If this is the case then the event must be renamed to the correct format that Predbat can function correctly. In the Predbat plan, for joined saving sessions the energy rates for import and export will be overridden by adding the assumed saving rate to your normal rate. The assumed rate will be taken from the Octopus Energy integration and converted into pence using the octopus_saving_session_octopoints_per_penny configuration item in apps.yaml (default is 8). If you normally cut back your house usage during a saving session then you can change input_number.predbat_load_scaling_saving to allow Predbat to assume an energy reduction in this period. E.g. setting to a value of 0.8 would indicate you will use 80% of the normal consumption in that period (a 20% reduction). As the saving session import and export rates are very high compared to normal Predbat will plan additional export during the saving session period. If necessary, a pre-charge may happen at some point during the day to maintain the battery right level for the session. Note that Predbat's operational mode select.predbat_mode must be set to either 'Control charge' or 'Control charge & discharge' for Predbat to be able to manage the battery for the saving session. If you do not have an export tariff then forced export will not apply and Predbat will just ensure you have enough battery charge to see you through the saving session period. If you do not want Predbat to automatically join Octopus saving sessions and manage your battery activity for the session, simply delete or comment out the octopus_saving_session entry in apps.yaml. Octopus free (power up) events Predbat can automatically detect Octopus free events and adjust your battery plan according. Note that this is derived from external sources, which do not verify your eligibility for free sessions. For Predbat to automatically manage Octopus free sessions the following additional configuration item in apps.yaml is used. Note: You must have signed up to Octoplus and eligible to benefit from these events Warning: Octopus Intelligent customers are not eligible for free energy, Intelligent customers should leave this line commented out Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_free_session - Will point to the free event sensor that is exposed by the Octopus Energy Integration. This event sensor contains the dates/times of all the free events. octopus_free_session: 're:(event.octopus_energy_([0-9a-z_]+|)_octoplus_free_electricity_session_events)' Note: This event may need to be enabled in Home Assistant first How to Enable Octopus events If you normally increase your house usage during a free session then you can change input_number.predbat_load_scaling_free to allow Predbat to assume an energy increase in this period. E.g. setting to a value of 1.2 would indicate you will use 20% more energy than normal during this period. (Default is 1.2) If you do not want Predbat to see these sessions then comment out the octopus_free_session setting. Note: If the above is not working due to a lack of data (via a 3rd party service) Predbat can scrape directly from the Octopus Web Site, this may have its own issues due to a change of format. If you enable this then sessions will be considered even if you forget to sign-up so be careful! octopus_free_url: 'http://octopus.energy/free-electricity' Octopus Rates URL If you do not wish to use the Octopus Energy integration and are an Octopus Energy customer then you can configure Predbat to get the electricity rates directly online from the Octopus website. In apps.yaml configure the following lines: rates_import_octopus_url to point to the appropriate import tariff URL on the Octopus website rates_export_octopus_url to point to the export tariff URL e.g. rates_import_octopus_url : \"https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates\" rates_import_octopus_url : \"https://api.octopus.energy/v1/products/AGILE-FLEX-BB-23-02-08/electricity-tariffs/E-1R-AGILE-FLEX-BB-23-02-08-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-A/standard-unit-rates/\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/OUTGOING-FIX-12M-BB-23-02-09/electricity-tariffs/E-1R-OUTGOING-FIX-12M-BB-23-02-09-A/standard-unit-rates/\" If you configure the rates_import_octopus_url then Predbat will use this instead of metric_octopus or rates_import. Similarly, rates_export_octopus_url takes precedence over metric_octopus_export or rates_export. Configuring the Octopus rates URL is an expert feature and for most users, the Octopus Energy integration is a simpler solution. Energidataservice Integration https://github.com/MTrab/energidataservice If your electricity supplier provides data through the Energi Data Service, you can use the Energidataservice integration to fetch real-time and future electricity pricing data. This integration allows you to automatically retrieve rates and apply them within your energy management system, including optional tariff adjustments for greater accuracy. The integration processes hourly pricing data and converts it into 30-minute intervals, making it ideal for scheduling and optimizing energy usage. Configuring Predbat to Use the Energidataservice Integration The following configuration items in apps.yaml are used to configure Predbat to use the Energidataservice integration. These items must be set explicitly to ensure that Predbat retrieves the correct import and export rates. metric_energidataservice_import - Import rates from the Energidataservice integration. This should point to the sensor that provides hourly import rates, such as sensor.energi_data_service. metric_energidataservice_export - Export rates from the Energidataservice integration. This should point to the sensor that provides hourly export rates (e.g., solar feed-in rates), such as sensor.energi_data_service_export. Rate Bands to manually configure Energy Rates If you are not an Octopus Energy customer, or you are but your energy rates repeat simply, you can configure your rate bands in apps.yaml using rates_import/rates_export/rates_gas. Add the following entries to apps.yaml to define the pattern of rates over 24 hours: rates_import: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_gas: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence start and end are in the time format of \"HH:MM:SS\" e.g. \"12:30:00\" and should be aligned to 30 minute slots normally, i.e. end with \":30:00\" or \":00:00\". Make sure the start and end times for the different rates cover the whole 24 hour period with no gaps! rate is in pence e.g. 4.2 day_of_week Can also be used to control rates on specific days. You can specify one day or multiple days split by a comma. Note: Day 1 = Monday, 2 = Tuesday .... 7 = Sunday e.g: rates_import: - rate: 15 day_of_week: \"1,2,3,4,5\" - rate: 10 day_of_week: \"6,7\" start and end can be omitted and Predbat will assume that you are on a single flat-rate tariff. If there are any gaps in the 24-hour period then a zero rate will be assumed. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas. Manually over-riding energy rates You can also override the import or export energy rates (regardless of whether they are set manually or via the Octopus Energy integration) by using the override feature in apps.yaml. Rate override is used to set the specific date and time period where your rates are different, e.g. an Octopus Power Up session (zero rate for an hour or two), or the British Gas half-price electricity on Sundays. Unfortunately, there aren't any API's available to feed this information automatically into Predbat so you will have to define your own input controls and use the Predbat manual API , or edit apps.yaml manually to set the appropriate rate over-ride dates and times: rates_import_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence Optionally you can add a predicted load scaling factor for these periods using load_scaling , for example: rates_import_override: - date: '2024-01-21' start: '17:30:00' end: '18:30:00' rate: 150 load_scaling: 0.8 This instructs Predbat that during a 1-hour period at 5:30-6:30pm on 21st of Jan set the import rate to 150p and assume our load will be 80% of normal (20% lower). You can also make relative adjustments to your energy rates, e.g. if you want to avoid exporting during peak periods to improve your energy saving session results you could make a relative adjustment to your export rates using rate_increment . The reason not to just set rate is that when an energy saving session is active you do not want to ignore the higher export rate that is automatically provided by Octopus. In this example we subtract 10p from our export rate during the period that saving sessions normally fall within and thus steer Predbat away from force exporting during that time. The saving session will still work correctly as a 10p adjustment on rates >100p will have little/no impact. rates_export_override: - start: '17:00:00' end: '19:00:00' rate_increment: -10 You can also use a similar but opposite approach of setting a positive export rate_increment to encourage Predbat to discharge the battery at certain time periods. If you have a very low overnight rate (such as Octopus Go) and want to ensure your battery is discharged just before the low rate period, but you don't want to risk the battery running out too early (and importing at a higher rate), you can add a rate export override for the period you want to discharge just before the low rate period: rates_export_override: - start: '22:30:00' end: '23:30:00' rate_increment: 10 You can also define an import_rate_override with start and end times and only load_scaling (without a rate_increment or rate), e.g. if you just want to apply load scaling to certain defined periods. date is optional and if specified must be in the date format of \"YYYY-MM-DD\" e.g. \"2023-09-09\". If a date is specified then the rate override applies to that specific date, otherwise, it applies to all dates start and end must be specified in \"HH:MM:SS\" time format e.g. \"12:30:00\" load_scaling is an optional percentage change factor in house load for the period - 1.0 would be no change, 0.8 is 80% of nominal house load, 2.0 would be a 100% increase (i.e. 2x) on normal historic house load rate is an optional figure in pence to override the rate for the specific period rate_increment is optional and is the number of pence to add (or subtract) to the reported energy rates during this period Rate offsets If you are on an Agile or Tracker tariff you can tune future unknown energy rates by adjusting the entities input_number.predbat_metric_future_rate_offset_import ( expert mode ) and input_number.predbat_metric_future_rate_offset_export ( expert mode ) inside Home Assistant to set the predicted offset for future unknown rates. Future Agile energy rates In the energy market, it's possible to calculate the Octopus Agile rates from around 10am UK time using public data, you can enable this in apps.yaml for Import, Export or both. This will approximate the next day's rates based on the spot prices. The approximation is only used until the real Octopus Agile rates are released around 4pm. futurerate_url - URL of future energy market prices; this should not normally need to be changed futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on energy market prices or not. Set these depending on whether you have an agile tariff for import, export or both futurerate_peak_start and futurerate_peak_end - during the peak period Octopus applies an additional peak-rate price adjustment. These configuration items enable the peak-rate hours to be adjusted CAUTION: You may violate the terms and conditions of the Nordpool site if you use this data and as such the authors of Predbat accepts no responsibility for any violations: https://www.nordpoolgroup.com/en/About-us/terms-and-conditions-for-useofwebsite/ futurerate_url: 'https://dataportal-api.nordpoolgroup.com/api/DayAheadPrices?date=DATE&market=N2EX_DayAhead&deliveryArea=UK&currency=GBP' futurerate_adjust_import: True futurerate_adjust_export: False futurerate_peak_start: \"16:00:00\" futurerate_peak_end: \"19:00:00\" Grid Carbon intensity Predbat can also track Carbon intensity by linking it to an integration which provides this data. UK Grid Carbon intensity The National Grid provides this data, please install this integration: https://github.com/jfparis/sensor.carbon_intensity_uk Once it is active update apps.yaml to link Predbat to the Sensor (if it's not already in your template): # Carbon Intensity data from National grid carbon_intensity: 're:(sensor.carbon_intensity_uk)' By enabling switch.predbat_carbon_enable you can view Carbon Intensity in the predbat plan . Predbat can also optimise your grid charging based on the Carbon footprint by setting input_number.predbat_carbon_metric .","title":"Energy rates"},{"location":"energy-rates/#energy-rates","text":"Predbat needs to know what your Import and (optionally) Export rates are so it can plan the optimal way to use your battery. Your Import and Export rates can be simple flat rates, more complex time-of-day tariffs (e.g. Economy 7, Octopus Flux), or daily/half-hourly rates that track electricity market prices (e.g. Octopus Agile or Tracker). Energy rates are all configured in the apps.yaml file that's stored in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/batpred/config/ directory depending on what type of Predbat installation method you have used . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to edit this file - see editing configuration files within Home Assistant if you need to install an editor. There are four different ways of configuring your Energy rates in apps.yaml , using Octopus Energy Direct , using the Octopus Energy Integration , using Octopus Rates URL's , or manually defining your rates and time periods . At least one of these methods must be used to define your import and export rates. If you don't then Predbat will assume zero for your energy rates.","title":"Energy rates"},{"location":"energy-rates/#octopus-energy-direct","text":"If your electricity supplier is Octopus Energy then the simplest way to provide Predbat with your electricity pricing information is to connect Predbat directly to Octopus. This method will not work correctly if you have multiple import or export meters. A single Octopus Intelligent GO car charger or car is supported. Saving sessions are also support, including auto-enroll. You should first log into your Octopus account and go to the Accounts section and copy your account number e.g. A-1234567. Then go to the API Access page where you can copy your API key e.g. sk_live_1as12355... Put these both into your apps.yaml and you are done. octopus_api_account: 'XXXXXXXX' octopus_api_key: 'sk_live_yyyyyyyy' Free energy sessions: Predbat can scrape directly from the Octopus Web Site, this may have its own issues due to a change of format. If you enable this then sessions will be considered even if you forget to sign-up so be careful! octopus_free_url: 'http://octopus.energy/free-electricity'","title":"Octopus Energy direct"},{"location":"energy-rates/#octopus-energy-home-assistant-integration","text":"","title":"Octopus Energy Home Assistant Integration"},{"location":"energy-rates/#octopus-energy-integration-setup","text":"Instead of using Octopus Energy Direct Predbat can also work with the Octopus Energy integration , this bring greater configurability than the direct method. The Octopus Energy integration connects to your Octopus Energy account and retrieves the tariffs you are on, and the current tariff rates. If you change tariff within Octopus the integration will automatically retrieve the updated tariff information, and as tariff prices change, again they are automatically retrieved. The integration also provides support for Intelligent Octopus charging to support car charging. Follow the instructions provided in the Octopus Energy integration documentation to install and set up the integration. Once installed, you will need to configure the integration (go to Settings / Devices & Services / Integrations / Octopus Energy then click 'Configure') and provide the integration with your 'Octopus API key' (that you obtain from your Octopus account: Personal Details / API access). CAUTION To get detailed energy rates needed by Predbat you need to go into Home Assistant and manually enable the following Octopus Energy events which are disabled by default when the integration is installed: event.octopus_energy_electricity_xxxxxxxx_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_current_day_rates event.octopus_energy_electricity_xxxxxxxx_next_day_rates event.octopus_energy_electricity_xxxxxxxx_export_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_export_current_day_rates event.octopus_energy_electricity_xxxxxxxx_export_next_day_rates event.octopus_energy_gas_xxxxxxxx_previous_day_rates event.octopus_energy_gas_xxxxxxxx_current_day_rates event.octopus_energy_gas_xxxxxxxx_next_day_rates To enable the above events: Go to Settings / Devices & Services / Integrations, choose Octopus Energy, then xx entities You will see a list of entities (and events) supplied by the Octopus integration Click the 'Filter' symbol on the top right-hand corner (a series of lines in a downwards pointing arrow) and make sure all the options are selected Then in the left-hand-side search entities box, type \"current_day\" Click on the first event that comes up, check the name is the right one Click the cog wheel, then you should see the option to enable the event Click the option to enable the event and press 'Update' to make the change Repeat this for the other events. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas. Verify that the integration is working correctly in Home Assistant by going to Developer Tools / States, and entering 'octopus' in the 'Filter entities' box. Confirm that the Octopus entities are being populated correctly.","title":"Octopus Energy integration setup"},{"location":"energy-rates/#configuring-predbat-to-use-the-octopus-energy-integration","text":"The following configuration items in apps.yaml are used to configure Predbat to use the Octopus Energy integration. They are set to a regular expression and should be auto-discovered so that Predbat automatically uses the Octopus Energy integration, but you can comment out the regular expression lines to disable, or you set them manually. metric_octopus_import - Import rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_current_rate metric_octopus_export - Export rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_export_current_rate metric_octopus_gas - Gas rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_gas_METER_NUMBER_current_rate octopus_intelligent_slot - If you have the Octopus Intelligent Go tariff this should point to the 'slot' sensor binary_sensor.octopus_energy_ACCOUNT_ID_intelligent_dispatching metric_octopus_gas is (as above) only required to be configured if you are using Predbat to determine whether to heat your hot water via your iBoost or gas. If you do not have an export rate or are not on the Octopus Go tariff, then the appropriate lines can be commented out in apps.yaml.","title":"Configuring Predbat to use the Octopus Energy integration"},{"location":"energy-rates/#standing-charge","text":"Predbat can also (optionally) include the daily standing charge in cost predictions. The following configuration item in apps.yaml defaults to obtaining the standing charge from the Octopus Energy integration: metric_standing_charge - Standing charge in pounds. By default points to the Octopus Energy integration sensor sensor.octopus_energy_electricity_METER_NUMBER_current_standing_charge You can manually change this to a standing charge in pounds, e.g. 0.50 is 50p, or delete this line from apps.yaml, or set it to zero if you don't want the standing charge (and only have consumption usage) to be included in Predbat charts and output data.","title":"Standing charge"},{"location":"energy-rates/#octopus-saving-sessions","text":"Predbat can automatically join you to Octopus saving sessions and plan battery activity for the saving session period to maximise your income. For Predbat to automatically manage Octopus saving sessions the following additional configuration item in apps.yaml is used. Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_saving_session - Indicates if a saving session is active, should point to the sensor binary_sensor.octopus_energy_ACCOUNT_ID_octoplus_saving_sessions. When a saving session is available it will be automatically joined by Predbat and should then appear as a joined session within the next 30 minutes. NOTE: Predbat automatically joining the saving session relies upon the event being enabled and Predbat being able to find the saving session event as 'event.octopus_energy_ACCOUNT_ID_octoplus_saving_session_events' - there have been occasions with some Octopus Integration installations where the event name is different. If this is the case then the event must be renamed to the correct format that Predbat can function correctly. In the Predbat plan, for joined saving sessions the energy rates for import and export will be overridden by adding the assumed saving rate to your normal rate. The assumed rate will be taken from the Octopus Energy integration and converted into pence using the octopus_saving_session_octopoints_per_penny configuration item in apps.yaml (default is 8). If you normally cut back your house usage during a saving session then you can change input_number.predbat_load_scaling_saving to allow Predbat to assume an energy reduction in this period. E.g. setting to a value of 0.8 would indicate you will use 80% of the normal consumption in that period (a 20% reduction). As the saving session import and export rates are very high compared to normal Predbat will plan additional export during the saving session period. If necessary, a pre-charge may happen at some point during the day to maintain the battery right level for the session. Note that Predbat's operational mode select.predbat_mode must be set to either 'Control charge' or 'Control charge & discharge' for Predbat to be able to manage the battery for the saving session. If you do not have an export tariff then forced export will not apply and Predbat will just ensure you have enough battery charge to see you through the saving session period. If you do not want Predbat to automatically join Octopus saving sessions and manage your battery activity for the session, simply delete or comment out the octopus_saving_session entry in apps.yaml.","title":"Octopus Saving sessions"},{"location":"energy-rates/#octopus-free-power-up-events","text":"Predbat can automatically detect Octopus free events and adjust your battery plan according. Note that this is derived from external sources, which do not verify your eligibility for free sessions. For Predbat to automatically manage Octopus free sessions the following additional configuration item in apps.yaml is used. Note: You must have signed up to Octoplus and eligible to benefit from these events Warning: Octopus Intelligent customers are not eligible for free energy, Intelligent customers should leave this line commented out Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_free_session - Will point to the free event sensor that is exposed by the Octopus Energy Integration. This event sensor contains the dates/times of all the free events. octopus_free_session: 're:(event.octopus_energy_([0-9a-z_]+|)_octoplus_free_electricity_session_events)' Note: This event may need to be enabled in Home Assistant first How to Enable Octopus events If you normally increase your house usage during a free session then you can change input_number.predbat_load_scaling_free to allow Predbat to assume an energy increase in this period. E.g. setting to a value of 1.2 would indicate you will use 20% more energy than normal during this period. (Default is 1.2) If you do not want Predbat to see these sessions then comment out the octopus_free_session setting. Note: If the above is not working due to a lack of data (via a 3rd party service) Predbat can scrape directly from the Octopus Web Site, this may have its own issues due to a change of format. If you enable this then sessions will be considered even if you forget to sign-up so be careful! octopus_free_url: 'http://octopus.energy/free-electricity'","title":"Octopus free (power up) events"},{"location":"energy-rates/#octopus-rates-url","text":"If you do not wish to use the Octopus Energy integration and are an Octopus Energy customer then you can configure Predbat to get the electricity rates directly online from the Octopus website. In apps.yaml configure the following lines: rates_import_octopus_url to point to the appropriate import tariff URL on the Octopus website rates_export_octopus_url to point to the export tariff URL e.g. rates_import_octopus_url : \"https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates\" rates_import_octopus_url : \"https://api.octopus.energy/v1/products/AGILE-FLEX-BB-23-02-08/electricity-tariffs/E-1R-AGILE-FLEX-BB-23-02-08-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-A/standard-unit-rates/\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/OUTGOING-FIX-12M-BB-23-02-09/electricity-tariffs/E-1R-OUTGOING-FIX-12M-BB-23-02-09-A/standard-unit-rates/\" If you configure the rates_import_octopus_url then Predbat will use this instead of metric_octopus or rates_import. Similarly, rates_export_octopus_url takes precedence over metric_octopus_export or rates_export. Configuring the Octopus rates URL is an expert feature and for most users, the Octopus Energy integration is a simpler solution.","title":"Octopus Rates URL"},{"location":"energy-rates/#energidataservice-integration","text":"https://github.com/MTrab/energidataservice If your electricity supplier provides data through the Energi Data Service, you can use the Energidataservice integration to fetch real-time and future electricity pricing data. This integration allows you to automatically retrieve rates and apply them within your energy management system, including optional tariff adjustments for greater accuracy. The integration processes hourly pricing data and converts it into 30-minute intervals, making it ideal for scheduling and optimizing energy usage.","title":"Energidataservice Integration"},{"location":"energy-rates/#configuring-predbat-to-use-the-energidataservice-integration","text":"The following configuration items in apps.yaml are used to configure Predbat to use the Energidataservice integration. These items must be set explicitly to ensure that Predbat retrieves the correct import and export rates. metric_energidataservice_import - Import rates from the Energidataservice integration. This should point to the sensor that provides hourly import rates, such as sensor.energi_data_service. metric_energidataservice_export - Export rates from the Energidataservice integration. This should point to the sensor that provides hourly export rates (e.g., solar feed-in rates), such as sensor.energi_data_service_export.","title":"Configuring Predbat to Use the Energidataservice Integration"},{"location":"energy-rates/#rate-bands-to-manually-configure-energy-rates","text":"If you are not an Octopus Energy customer, or you are but your energy rates repeat simply, you can configure your rate bands in apps.yaml using rates_import/rates_export/rates_gas. Add the following entries to apps.yaml to define the pattern of rates over 24 hours: rates_import: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_gas: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence start and end are in the time format of \"HH:MM:SS\" e.g. \"12:30:00\" and should be aligned to 30 minute slots normally, i.e. end with \":30:00\" or \":00:00\". Make sure the start and end times for the different rates cover the whole 24 hour period with no gaps! rate is in pence e.g. 4.2 day_of_week Can also be used to control rates on specific days. You can specify one day or multiple days split by a comma. Note: Day 1 = Monday, 2 = Tuesday .... 7 = Sunday e.g: rates_import: - rate: 15 day_of_week: \"1,2,3,4,5\" - rate: 10 day_of_week: \"6,7\" start and end can be omitted and Predbat will assume that you are on a single flat-rate tariff. If there are any gaps in the 24-hour period then a zero rate will be assumed. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas.","title":"Rate Bands to manually configure Energy Rates"},{"location":"energy-rates/#manually-over-riding-energy-rates","text":"You can also override the import or export energy rates (regardless of whether they are set manually or via the Octopus Energy integration) by using the override feature in apps.yaml. Rate override is used to set the specific date and time period where your rates are different, e.g. an Octopus Power Up session (zero rate for an hour or two), or the British Gas half-price electricity on Sundays. Unfortunately, there aren't any API's available to feed this information automatically into Predbat so you will have to define your own input controls and use the Predbat manual API , or edit apps.yaml manually to set the appropriate rate over-ride dates and times: rates_import_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence Optionally you can add a predicted load scaling factor for these periods using load_scaling , for example: rates_import_override: - date: '2024-01-21' start: '17:30:00' end: '18:30:00' rate: 150 load_scaling: 0.8 This instructs Predbat that during a 1-hour period at 5:30-6:30pm on 21st of Jan set the import rate to 150p and assume our load will be 80% of normal (20% lower). You can also make relative adjustments to your energy rates, e.g. if you want to avoid exporting during peak periods to improve your energy saving session results you could make a relative adjustment to your export rates using rate_increment . The reason not to just set rate is that when an energy saving session is active you do not want to ignore the higher export rate that is automatically provided by Octopus. In this example we subtract 10p from our export rate during the period that saving sessions normally fall within and thus steer Predbat away from force exporting during that time. The saving session will still work correctly as a 10p adjustment on rates >100p will have little/no impact. rates_export_override: - start: '17:00:00' end: '19:00:00' rate_increment: -10 You can also use a similar but opposite approach of setting a positive export rate_increment to encourage Predbat to discharge the battery at certain time periods. If you have a very low overnight rate (such as Octopus Go) and want to ensure your battery is discharged just before the low rate period, but you don't want to risk the battery running out too early (and importing at a higher rate), you can add a rate export override for the period you want to discharge just before the low rate period: rates_export_override: - start: '22:30:00' end: '23:30:00' rate_increment: 10 You can also define an import_rate_override with start and end times and only load_scaling (without a rate_increment or rate), e.g. if you just want to apply load scaling to certain defined periods. date is optional and if specified must be in the date format of \"YYYY-MM-DD\" e.g. \"2023-09-09\". If a date is specified then the rate override applies to that specific date, otherwise, it applies to all dates start and end must be specified in \"HH:MM:SS\" time format e.g. \"12:30:00\" load_scaling is an optional percentage change factor in house load for the period - 1.0 would be no change, 0.8 is 80% of nominal house load, 2.0 would be a 100% increase (i.e. 2x) on normal historic house load rate is an optional figure in pence to override the rate for the specific period rate_increment is optional and is the number of pence to add (or subtract) to the reported energy rates during this period","title":"Manually over-riding energy rates"},{"location":"energy-rates/#rate-offsets","text":"If you are on an Agile or Tracker tariff you can tune future unknown energy rates by adjusting the entities input_number.predbat_metric_future_rate_offset_import ( expert mode ) and input_number.predbat_metric_future_rate_offset_export ( expert mode ) inside Home Assistant to set the predicted offset for future unknown rates.","title":"Rate offsets"},{"location":"energy-rates/#future-agile-energy-rates","text":"In the energy market, it's possible to calculate the Octopus Agile rates from around 10am UK time using public data, you can enable this in apps.yaml for Import, Export or both. This will approximate the next day's rates based on the spot prices. The approximation is only used until the real Octopus Agile rates are released around 4pm. futurerate_url - URL of future energy market prices; this should not normally need to be changed futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on energy market prices or not. Set these depending on whether you have an agile tariff for import, export or both futurerate_peak_start and futurerate_peak_end - during the peak period Octopus applies an additional peak-rate price adjustment. These configuration items enable the peak-rate hours to be adjusted CAUTION: You may violate the terms and conditions of the Nordpool site if you use this data and as such the authors of Predbat accepts no responsibility for any violations: https://www.nordpoolgroup.com/en/About-us/terms-and-conditions-for-useofwebsite/ futurerate_url: 'https://dataportal-api.nordpoolgroup.com/api/DayAheadPrices?date=DATE&market=N2EX_DayAhead&deliveryArea=UK&currency=GBP' futurerate_adjust_import: True futurerate_adjust_export: False futurerate_peak_start: \"16:00:00\" futurerate_peak_end: \"19:00:00\"","title":"Future Agile energy rates"},{"location":"energy-rates/#grid-carbon-intensity","text":"Predbat can also track Carbon intensity by linking it to an integration which provides this data.","title":"Grid Carbon intensity"},{"location":"energy-rates/#uk-grid-carbon-intensity","text":"The National Grid provides this data, please install this integration: https://github.com/jfparis/sensor.carbon_intensity_uk Once it is active update apps.yaml to link Predbat to the Sensor (if it's not already in your template): # Carbon Intensity data from National grid carbon_intensity: 're:(sensor.carbon_intensity_uk)' By enabling switch.predbat_carbon_enable you can view Carbon Intensity in the predbat plan . Predbat can also optimise your grid charging based on the Carbon footprint by setting input_number.predbat_carbon_metric .","title":"UK Grid Carbon intensity"},{"location":"faq/","text":"FAQ I've installed Predbat but I don't see the correct entities First look at predbat.status in Home Assistant and the Predbat/AppDaemon add-on log (which can be found in the list of log files in the System/Log area of the GUI). See if any errors are warnings are found. If you see an error something is likely configured incorrectly, check your entity settings are correct. Make sure Solcast is installed and it's auto-updated at least a couple of times a day (see the Solcast instructions ). The default Solcast sensor names may be wrong, you might need to update the apps.yaml config to match your own names (some people don't have the solcast_ bit in their names) Did you configure AppDaemon apps_dir correctly in appdaemon.yaml ? Why is my predicted charge % higher or lower than I might expect? Predbat is based on cost, so it will try to save you money. If you have the PV 10% option enabled it will also take into account the worst-case scenario and how often it might happen, so if the forecast is a bit unreliable it's better to charge more and not risk getting stung importing. Have you checked your energy rates for import and export are correct, maybe check the rates graph and confirm. If you do something like have export>import then Predbat will try to export as much as possible. Have you tuned Solcast to match your output accurately? Have you tuned predbat_best_soc_keep settings ? Do you have predicted car charging during the time period? You can also tune predbat_load_scaling and predbat_pv_scaling to adjust predictions up and down a bit Maybe your historical data includes car charging, you might want to filter this out using car_charging_hold in apps.yaml Why didn't the slot get configured? Are you in read-only mode? My plan doesn't include any charging? Do you have the predbat_mode set to Control charge (or Control charge & discharge)? The charge limit keeps increasing/decreasing in the charge window or is unstable Check you don't have any other automations running that adjust GivTCP settings during this time. Some people had a script that changes the reserve %, this will cause problems - please disable other automations and retry. I changed a config item but it made no difference? You might have to wait a few minutes until the next update cycle. Depending on the speed of the computer that Predbat is running on, it can take 1-5 minutes for Predbat to run through. You can see the date/time that Predbat last completed a run at the start of the Predbat HTML plan . It's all running but I'm not getting very good results You might want to tune input_number.predbat_best_soc_keep to set a minimum target battery level, e.g. I use 2.0 (for 2kWh, which is just over 20% on a 9.5kWh battery). If you set input_number.predbat_best_soc_keep too high then Predbat could need to charge the battery at unfavourable import rates, so try to set it to a fairly low value, especially if you have a small battery. If you set it to zero then Predbat may not charge at all, so use 0.1 as a minimum. Have a read of the energy rates configuration guide as depending on your tariff different settings may be required Check your solar production is well calibrated (you can compare Solcast vs actually in the Home Assistant energy tab or on the GivEnergy portal) Make sure your inverter max AC rate has been set correctly If you have an EV that you charge then you will want some sort of car charging sensor or use the basic car charging hold feature or your load predictions may be unreliable - see Car charging Do you have a solar diverter? If so maybe you want to try using the iBoost model settings . Perhaps set up the calibration chart and let it run for 24 hours to see how things line up If your export slots are too small compared to expected check your inverter_limit is set correctly (see below) In my power flow diagram my grid power is the wrong way around You may need to set ' grid_power_invert to True if your grid_power is positive when importing. My plan is freeze charging or holding at 100% battery a lot Round trip losses Round trip losses for charging the battery and then using it for your home are: charge loss x inverter loss x inverter loss x discharge loss The default is therefore: $0.97 * 0.96 * 0.96 * 0.97 \\approx 0.87$ (13%) If you freeze charge or hold at 100% then you will be using the grid which is 13% cheaper than using the battery at the same import rate. If you start increasing these losses to say 5% and 6% then you are getting to around 20% round trip losses. This means charging the battery at 20p is the same cost as using the grid at 25p. However, if you start setting metric_self_sufficiency then you are telling Predbat to try to import less when possible. If your round trip losses are 20% then using the grid directly will import 20% less energy than charging your battery. Therefore a 5p metric self-sufficiency will effectively add another 1p to this difference i.e. using the grid at 26p is now the same as charging the battery at 20p! If you set metric_battery_cycle to say 2p then that would add another 4p to using the battery so now charging at 20p would equate to using the grid at 30p! Bottom line, be careful how you configure things. When my battery is charging to 100% it fluctuates between 98% and 100%, and/or gives an error setting reserve Some inverters e.g. GE AIO inverter won't allow the reserve to be set to 100, in which case set in apps.yaml inverter_reserve_max : 98 And this should prevent the issue The plan doesn't charge or discharge when I expect it to Predbat can only work on the information it's given, although it does run every 5 minutes when it re-evaluates the plan and adjusts if necessary. The plan Predbat produces assumes that your average load and PV forecasts are accurate and Predbat will aim to give you the maximum return. Make sure you have set up your Solcast solar forecast correctly with the number of panels, orientation, output, etc. Projected daily load is determined from historical load information so make sure you have set days_previous and days_previous_weight in apps.yaml to give appropriately representative load history to Predbat, and read the longer explanation of how days_previous works . You could adjust input_number.predbat_load_scaling to 1.2 so the plan will incorporate 20% more expected load if you want to be more pessimistic about historical load, and input_number.predbat_pv_scaling to similarly adjust the PV forecast - these and other adjustment options are described in the Scaling and Weight options . It is very important to correctly set Predbat's Battery Loss Options and Battery Margins as these can have a huge and critical impact on the plan that Predbat generates. Predbat's default configuration values are the recommended starting values for most users but there is no single right set of configuration values for every user of Predbat, it depends on many factors and your personal preferences. Many users will need to customise and tweak their Predbat configuration to suit their needs. The SoC level that Predbat aims to keep in the battery input_number.predbat_best_soc_keep and the absolute minimum SoC level input_number.predbat_best_soc_min are the first things to check. If these are set too high then Predbat will charge at unfavourable rates to maintain the battery SoC. Conversely, if you find Predbat is letting the battery exhaust too early, set predbat_best_soc_keep to 1.0 so Predbat will aim to keep 1kWh available for unexpected load. Predbat performs a lowest-cost battery optimisation so a key part of deciding whether to charge, discharge or feed the house from the battery are the loss rates input_number.predbat_battery_loss , input_number.predbat_battery_loss_discharge and input_number.predbat_inverter_loss . Typical values could be 4, 4, 4 or 5, 5, 5. It is tempting to set these inverter loss figures lower to encourage Predbat to use the battery more, but this should be resisted as experience from the GivEnergy community forum suggests total energy conversion losses are in the range of 10-20%. Putting these losses into context and assuming you have an AC-coupled battery and have set the losses to 4, 4 and 4; then for every kWh charged from the grid, you will only get 0.92kWh stored in the battery (4% charge + 4% inverter conversion loss) and similarly when that 0.92kWh is discharged to the home you will only receive 0.85kWh (0.92 x 0.92). These loss percentages also impact the Predbat plan. Consider an import rate of 20p/kWh; after conversion losses are considered, each 1kWh of stored battery charge will in effect have cost 21.7p (20 / 0.92) to import. Then for discharging, the same applies. Each kWh of stored battery charge (that costs 21.7p to charge) will in effect have cost 23.6p (21.7 / 0.92) to discharge. Predbat makes cost optimisation decisions so unless the current import rate is more than 23.6p, it will be cheaper to let the home run off grid import rather than to discharge the battery. If you turn debug mode on for the Predbat plan then you can see the effective import and export rates after losses that Predbat calculates in the Predbat plan. Predbat also uses input_number.predbat_metric_battery_cycle ( expert mode setting) to apply a 'virtual cost' in pence per kWh for charging and discharging the battery. The default value is 1p but this this can be changed to a different value to recognise the 'cost of using the battery', or set to zero to disable this feature. So if the metric battery cycle is set to 1p, and continuing the example above, each kWh of battery charge will be costed at 22.7p (21.7p + 1p battery metric to charge), and the battery will not be discharged to support the home unless the current import rate is more than 25.6p (23.6p + 1p cost of charging + 1p cost to discharge). input_number.predbat_metric_min_improvement and input_number.predbat_metric_min_improvement_discharge (both expert mode settings) also affect Predbat's cost optimisation decisions as to whether it is cost beneficial to charge or discharge the battery so could be tweaked if you feel Predbat is charging or discharging with marginal benefits. The defaults (0p and 0.1p respectively) should however give good results for most users. Finally, it could be worth considering adding import or export rate increments to apps.yaml if you want to direct Predbat to avoid or encourage charging or discharging in certain time periods - e.g. avoiding exporting in the time period saving sessions normally fall in, or to encourage discharging just before import rates fall overnight. Predbat is causing warning messages about 'exceed maximum size' in the Home Assistant Core log If you have a large input_number.predbat_forecast_plan_hours then you may see warning messages in the Home Assistant Core log about the size of a number of Predbat entities, the message will be \"State attributes for predbat. XXXX exceed maximum size of 16384 bytes\". This is just a warning, the Predbat entity attributes aren't stored in the database anyway, but you can suppress these warnings by adding the following to your configuration.yaml file: # Filter out 'message too large' warnings from Predbat entities logger: default: warning filters: homeassistant.components.recorder.db_schema: - \"State attributes for predbat.base10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_charge_limit exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_export exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_import exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_actual exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_adjusted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_predicted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.plan_html exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.rates exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_base10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" Error - metric_octopus_import not set correctly or no energy rates can be read If you get this error in the Predbat log file: Check that the Octopus integration is working and that event.octopus_energy_electricity_METER_NUMBER_current_day_rates and sensor.octopus_electricity_energy_METER_NUMBER_current_rate are both populated by the integration. Ensure that you have followed the Octopus Integration Installation instructions , including enabling the Octopus Integration events. If you have been using an older version of the Octopus integration and have upgraded to version 9 or above, then you may find that your energy sensors are named sensor.electricity_METER_NUMBER_current_rate (i.e. no 'octopus_energy_' prefix) but the 'event' entities have the 'octopus_energy' prefix. If the 'event' and 'sensor' entities are not consistently named then Predbat will not be able to find the event entities if the sensor names don't match what's expected. To fix this, uninstall the Octopus integration, reboot Home Assistant, delete all the old Octopus sensors, and re-install the Octopus Integration . WARN: No solar data has been configured If you get this warning message in the Predbat log file or you see that the 'PV kWh' column in the Predbat plan card is completely blank: Ensure that you have installed and configured Solcast correctly Check the Solcast integration in Home Assistant is configured and enabled (go to Settings / Integrations / Solcast ) Check that there are no errors relating to Solcast in the Home Assistant log (go to Settings / System / Logs and view the 'Home Assistant Core' log). If you see an error 429 message in the log then this is as a result of Solcast's rate limiting for Hobbyist accounts. The only fix is to re-run the 'Solcast update' automation and hope that Solcast isn't as busy when you re-run. Verify the solar forecast has been populated in Home Assistant by going to Developer Tools / States, filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities If you can see the Solcast entities but there are no forecast PV figures, try running the 'Solcast update' automation you created, and check again the Solcast entities If the Solcast entities are still not populated, try reloading the Solcast integration (go to System / Devices & Services / Integrations tab, click on 'Solcast PV Forecast', click the three vertical dots beside 'Configure' and choose 'Reload' from the dropdown menu) Check sensor.solcast_pv_api_limit (it's normally 10 for new Solcast accounts) meaning you can call the Solcast API 10 times a day (but if you have two solar arrays, e.g. East/West) then retrieving the forecast will count as two API calls. Compare this to sensor.solcast_pv_api_used to see how many Solcast API calls you have made today (alternatively, you can confirm how many API calls you have made today by logging into your Solcast account). If you've run out of API calls you will have to wait until midnight GMT for the API count to reset. It's recommended that you don't include the Solcast forecast within your GivEnergy portal to avoid running out of API calls. Check the Solcast server API status is OK Note: Can not find battery charge curve If you get the message \"Note: Can not find battery charge curve, one of the required settings for soc_kw, battery_power and charge_rate are missing from apps.yaml\" in the logfile then Predbat tries to create a battery charge curve but does not have access to the required history information in Home Assistant. Creating the battery charge curve is described in the apps.yaml document. The most likely cause of the above message appearing in the logfile is that you are controlling the inverter in REST mode but have not uncommented the following entities in apps.yaml that Predbat needs to obtain history from to create the battery charge curve: charge_rate: - number.givtcp_{geserial}_battery_charge_rate discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh WARN: Inverter is in calibration mode If you see the message \"WARN: Inverter is in calibration mode, Predbat will not function correctly and will be disabled\" in the logfile, then Predbat has identified that your inverter is currently calibrating your battery. Predbat's status will also be set to 'Calibration'. Predbat will set the inverter charge and discharge rates to maximum (if they are not already), SoC target to 100% and battery reserve to minimum (usually 4%), and will not execute the plan nor enable battery charge or discharge. Once the inverter finishes calibrating the battery, Predbat will resume normal operations. Inverter time is xxx, Predbat computer time is xxx, this is xxx minutes skewed, Predbat may not function correctly If the predbat.status gives a warning error about the inverter time: Then it indicates that there is a mismatch between the clock that Predbat is using and the inverter time clock, and clearly with a clock mismatch, charging and discharging your battery at specific times may not work as expected. There are several potential causes of this problem: Check that the inverter time is correctly set, especially that it is set to GMT (even if it's summertime). In the GivEnergy portal, go to My Inverters / Remote Control (cog symbol) / click SEND next to 'Set Date and Time' Check that the time_zone in appdaemon.yaml is correctly set for your location (e.g. Europe/London) The time zone for Predbat in apps.yaml needs to be set to the same value Finally, check how often your inverter integration is polling your inverter for new data. For GivTCP the Self Run Loop Timer is recommended to be set to a value of between 20 and 60 seconds. If you have checked the above and keep getting \u201ctime is skewed\u201d warnings then it means Home Assistant/predbat isn\u2019t getting the same time from the inverter as it is expecting. Either GivTCP has lost communications with the inverter or the inverter has stopped talking to the world. If you look at the Logbook in Home Assistant you should see a steady stream of entities changing in HA. In particular, you will see the GivTCP inverter time entity changing every polling period, e.g. every 20 seconds. Possible fixes: restart the GivTCP add-on restart Home Assistant (although usually restarting GivTCP is enough) power the inverter off, turn off the panels and battery first, then the inverter, then follow the reverse sequence to power the inverter back on again. This forces the inverter to reconnect to your wifi do a \u2018reset to defaults\u2019 in the portal If you keep getting the warning message, even sporadically, then this points to an underlying issue in your home network between Home Assistant and the inverter. You may need to add a Wi-Fi repeater or ideally a fixed Ethernet connection to your inverter to improve signal strength if this keeps happening. There is a Home Assistant automation that will alert you if GivTCP stops sending data to predbat . I have another problem not listed above If you are still having trouble feel free to raise a Github ticket for support","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#ive-installed-predbat-but-i-dont-see-the-correct-entities","text":"First look at predbat.status in Home Assistant and the Predbat/AppDaemon add-on log (which can be found in the list of log files in the System/Log area of the GUI). See if any errors are warnings are found. If you see an error something is likely configured incorrectly, check your entity settings are correct. Make sure Solcast is installed and it's auto-updated at least a couple of times a day (see the Solcast instructions ). The default Solcast sensor names may be wrong, you might need to update the apps.yaml config to match your own names (some people don't have the solcast_ bit in their names) Did you configure AppDaemon apps_dir correctly in appdaemon.yaml ?","title":"I've installed Predbat but I don't see the correct entities"},{"location":"faq/#why-is-my-predicted-charge-higher-or-lower-than-i-might-expect","text":"Predbat is based on cost, so it will try to save you money. If you have the PV 10% option enabled it will also take into account the worst-case scenario and how often it might happen, so if the forecast is a bit unreliable it's better to charge more and not risk getting stung importing. Have you checked your energy rates for import and export are correct, maybe check the rates graph and confirm. If you do something like have export>import then Predbat will try to export as much as possible. Have you tuned Solcast to match your output accurately? Have you tuned predbat_best_soc_keep settings ? Do you have predicted car charging during the time period? You can also tune predbat_load_scaling and predbat_pv_scaling to adjust predictions up and down a bit Maybe your historical data includes car charging, you might want to filter this out using car_charging_hold in apps.yaml","title":"Why is my predicted charge % higher or lower than I might expect?"},{"location":"faq/#why-didnt-the-slot-get-configured","text":"Are you in read-only mode?","title":"Why didn't the slot get configured?"},{"location":"faq/#my-plan-doesnt-include-any-charging","text":"Do you have the predbat_mode set to Control charge (or Control charge & discharge)?","title":"My plan doesn't include any charging?"},{"location":"faq/#the-charge-limit-keeps-increasingdecreasing-in-the-charge-window-or-is-unstable","text":"Check you don't have any other automations running that adjust GivTCP settings during this time. Some people had a script that changes the reserve %, this will cause problems - please disable other automations and retry.","title":"The charge limit keeps increasing/decreasing in the charge window or is unstable"},{"location":"faq/#i-changed-a-config-item-but-it-made-no-difference","text":"You might have to wait a few minutes until the next update cycle. Depending on the speed of the computer that Predbat is running on, it can take 1-5 minutes for Predbat to run through. You can see the date/time that Predbat last completed a run at the start of the Predbat HTML plan .","title":"I changed a config item but it made no difference?"},{"location":"faq/#its-all-running-but-im-not-getting-very-good-results","text":"You might want to tune input_number.predbat_best_soc_keep to set a minimum target battery level, e.g. I use 2.0 (for 2kWh, which is just over 20% on a 9.5kWh battery). If you set input_number.predbat_best_soc_keep too high then Predbat could need to charge the battery at unfavourable import rates, so try to set it to a fairly low value, especially if you have a small battery. If you set it to zero then Predbat may not charge at all, so use 0.1 as a minimum. Have a read of the energy rates configuration guide as depending on your tariff different settings may be required Check your solar production is well calibrated (you can compare Solcast vs actually in the Home Assistant energy tab or on the GivEnergy portal) Make sure your inverter max AC rate has been set correctly If you have an EV that you charge then you will want some sort of car charging sensor or use the basic car charging hold feature or your load predictions may be unreliable - see Car charging Do you have a solar diverter? If so maybe you want to try using the iBoost model settings . Perhaps set up the calibration chart and let it run for 24 hours to see how things line up If your export slots are too small compared to expected check your inverter_limit is set correctly (see below)","title":"It's all running but I'm not getting very good results"},{"location":"faq/#in-my-power-flow-diagram-my-grid-power-is-the-wrong-way-around","text":"You may need to set ' grid_power_invert to True if your grid_power is positive when importing.","title":"In my power flow diagram my grid power is the wrong way around"},{"location":"faq/#my-plan-is-freeze-charging-or-holding-at-100-battery-a-lot","text":"Round trip losses Round trip losses for charging the battery and then using it for your home are: charge loss x inverter loss x inverter loss x discharge loss The default is therefore: $0.97 * 0.96 * 0.96 * 0.97 \\approx 0.87$ (13%) If you freeze charge or hold at 100% then you will be using the grid which is 13% cheaper than using the battery at the same import rate. If you start increasing these losses to say 5% and 6% then you are getting to around 20% round trip losses. This means charging the battery at 20p is the same cost as using the grid at 25p. However, if you start setting metric_self_sufficiency then you are telling Predbat to try to import less when possible. If your round trip losses are 20% then using the grid directly will import 20% less energy than charging your battery. Therefore a 5p metric self-sufficiency will effectively add another 1p to this difference i.e. using the grid at 26p is now the same as charging the battery at 20p! If you set metric_battery_cycle to say 2p then that would add another 4p to using the battery so now charging at 20p would equate to using the grid at 30p! Bottom line, be careful how you configure things.","title":"My plan is freeze charging or holding at 100% battery a lot"},{"location":"faq/#when-my-battery-is-charging-to-100-it-fluctuates-between-98-and-100-andor-gives-an-error-setting-reserve","text":"Some inverters e.g. GE AIO inverter won't allow the reserve to be set to 100, in which case set in apps.yaml inverter_reserve_max : 98 And this should prevent the issue","title":"When my battery is charging to 100% it fluctuates between 98% and 100%, and/or gives an error setting reserve"},{"location":"faq/#the-plan-doesnt-charge-or-discharge-when-i-expect-it-to","text":"Predbat can only work on the information it's given, although it does run every 5 minutes when it re-evaluates the plan and adjusts if necessary. The plan Predbat produces assumes that your average load and PV forecasts are accurate and Predbat will aim to give you the maximum return. Make sure you have set up your Solcast solar forecast correctly with the number of panels, orientation, output, etc. Projected daily load is determined from historical load information so make sure you have set days_previous and days_previous_weight in apps.yaml to give appropriately representative load history to Predbat, and read the longer explanation of how days_previous works . You could adjust input_number.predbat_load_scaling to 1.2 so the plan will incorporate 20% more expected load if you want to be more pessimistic about historical load, and input_number.predbat_pv_scaling to similarly adjust the PV forecast - these and other adjustment options are described in the Scaling and Weight options . It is very important to correctly set Predbat's Battery Loss Options and Battery Margins as these can have a huge and critical impact on the plan that Predbat generates. Predbat's default configuration values are the recommended starting values for most users but there is no single right set of configuration values for every user of Predbat, it depends on many factors and your personal preferences. Many users will need to customise and tweak their Predbat configuration to suit their needs. The SoC level that Predbat aims to keep in the battery input_number.predbat_best_soc_keep and the absolute minimum SoC level input_number.predbat_best_soc_min are the first things to check. If these are set too high then Predbat will charge at unfavourable rates to maintain the battery SoC. Conversely, if you find Predbat is letting the battery exhaust too early, set predbat_best_soc_keep to 1.0 so Predbat will aim to keep 1kWh available for unexpected load. Predbat performs a lowest-cost battery optimisation so a key part of deciding whether to charge, discharge or feed the house from the battery are the loss rates input_number.predbat_battery_loss , input_number.predbat_battery_loss_discharge and input_number.predbat_inverter_loss . Typical values could be 4, 4, 4 or 5, 5, 5. It is tempting to set these inverter loss figures lower to encourage Predbat to use the battery more, but this should be resisted as experience from the GivEnergy community forum suggests total energy conversion losses are in the range of 10-20%. Putting these losses into context and assuming you have an AC-coupled battery and have set the losses to 4, 4 and 4; then for every kWh charged from the grid, you will only get 0.92kWh stored in the battery (4% charge + 4% inverter conversion loss) and similarly when that 0.92kWh is discharged to the home you will only receive 0.85kWh (0.92 x 0.92). These loss percentages also impact the Predbat plan. Consider an import rate of 20p/kWh; after conversion losses are considered, each 1kWh of stored battery charge will in effect have cost 21.7p (20 / 0.92) to import. Then for discharging, the same applies. Each kWh of stored battery charge (that costs 21.7p to charge) will in effect have cost 23.6p (21.7 / 0.92) to discharge. Predbat makes cost optimisation decisions so unless the current import rate is more than 23.6p, it will be cheaper to let the home run off grid import rather than to discharge the battery. If you turn debug mode on for the Predbat plan then you can see the effective import and export rates after losses that Predbat calculates in the Predbat plan. Predbat also uses input_number.predbat_metric_battery_cycle ( expert mode setting) to apply a 'virtual cost' in pence per kWh for charging and discharging the battery. The default value is 1p but this this can be changed to a different value to recognise the 'cost of using the battery', or set to zero to disable this feature. So if the metric battery cycle is set to 1p, and continuing the example above, each kWh of battery charge will be costed at 22.7p (21.7p + 1p battery metric to charge), and the battery will not be discharged to support the home unless the current import rate is more than 25.6p (23.6p + 1p cost of charging + 1p cost to discharge). input_number.predbat_metric_min_improvement and input_number.predbat_metric_min_improvement_discharge (both expert mode settings) also affect Predbat's cost optimisation decisions as to whether it is cost beneficial to charge or discharge the battery so could be tweaked if you feel Predbat is charging or discharging with marginal benefits. The defaults (0p and 0.1p respectively) should however give good results for most users. Finally, it could be worth considering adding import or export rate increments to apps.yaml if you want to direct Predbat to avoid or encourage charging or discharging in certain time periods - e.g. avoiding exporting in the time period saving sessions normally fall in, or to encourage discharging just before import rates fall overnight.","title":"The plan doesn't charge or discharge when I expect it to"},{"location":"faq/#predbat-is-causing-warning-messages-about-exceed-maximum-size-in-the-home-assistant-core-log","text":"If you have a large input_number.predbat_forecast_plan_hours then you may see warning messages in the Home Assistant Core log about the size of a number of Predbat entities, the message will be \"State attributes for predbat. XXXX exceed maximum size of 16384 bytes\". This is just a warning, the Predbat entity attributes aren't stored in the database anyway, but you can suppress these warnings by adding the following to your configuration.yaml file: # Filter out 'message too large' warnings from Predbat entities logger: default: warning filters: homeassistant.components.recorder.db_schema: - \"State attributes for predbat.base10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_charge_limit exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_export exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_import exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_actual exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_adjusted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_predicted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.plan_html exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.rates exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_base10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\"","title":"Predbat is causing warning messages about 'exceed maximum size' in the Home Assistant Core log"},{"location":"faq/#error-metric_octopus_import-not-set-correctly-or-no-energy-rates-can-be-read","text":"If you get this error in the Predbat log file: Check that the Octopus integration is working and that event.octopus_energy_electricity_METER_NUMBER_current_day_rates and sensor.octopus_electricity_energy_METER_NUMBER_current_rate are both populated by the integration. Ensure that you have followed the Octopus Integration Installation instructions , including enabling the Octopus Integration events. If you have been using an older version of the Octopus integration and have upgraded to version 9 or above, then you may find that your energy sensors are named sensor.electricity_METER_NUMBER_current_rate (i.e. no 'octopus_energy_' prefix) but the 'event' entities have the 'octopus_energy' prefix. If the 'event' and 'sensor' entities are not consistently named then Predbat will not be able to find the event entities if the sensor names don't match what's expected. To fix this, uninstall the Octopus integration, reboot Home Assistant, delete all the old Octopus sensors, and re-install the Octopus Integration .","title":"Error - metric_octopus_import not set correctly or no energy rates can be read"},{"location":"faq/#warn-no-solar-data-has-been-configured","text":"If you get this warning message in the Predbat log file or you see that the 'PV kWh' column in the Predbat plan card is completely blank: Ensure that you have installed and configured Solcast correctly Check the Solcast integration in Home Assistant is configured and enabled (go to Settings / Integrations / Solcast ) Check that there are no errors relating to Solcast in the Home Assistant log (go to Settings / System / Logs and view the 'Home Assistant Core' log). If you see an error 429 message in the log then this is as a result of Solcast's rate limiting for Hobbyist accounts. The only fix is to re-run the 'Solcast update' automation and hope that Solcast isn't as busy when you re-run. Verify the solar forecast has been populated in Home Assistant by going to Developer Tools / States, filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities If you can see the Solcast entities but there are no forecast PV figures, try running the 'Solcast update' automation you created, and check again the Solcast entities If the Solcast entities are still not populated, try reloading the Solcast integration (go to System / Devices & Services / Integrations tab, click on 'Solcast PV Forecast', click the three vertical dots beside 'Configure' and choose 'Reload' from the dropdown menu) Check sensor.solcast_pv_api_limit (it's normally 10 for new Solcast accounts) meaning you can call the Solcast API 10 times a day (but if you have two solar arrays, e.g. East/West) then retrieving the forecast will count as two API calls. Compare this to sensor.solcast_pv_api_used to see how many Solcast API calls you have made today (alternatively, you can confirm how many API calls you have made today by logging into your Solcast account). If you've run out of API calls you will have to wait until midnight GMT for the API count to reset. It's recommended that you don't include the Solcast forecast within your GivEnergy portal to avoid running out of API calls. Check the Solcast server API status is OK","title":"WARN: No solar data has been configured"},{"location":"faq/#note-can-not-find-battery-charge-curve","text":"If you get the message \"Note: Can not find battery charge curve, one of the required settings for soc_kw, battery_power and charge_rate are missing from apps.yaml\" in the logfile then Predbat tries to create a battery charge curve but does not have access to the required history information in Home Assistant. Creating the battery charge curve is described in the apps.yaml document. The most likely cause of the above message appearing in the logfile is that you are controlling the inverter in REST mode but have not uncommented the following entities in apps.yaml that Predbat needs to obtain history from to create the battery charge curve: charge_rate: - number.givtcp_{geserial}_battery_charge_rate discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh","title":"Note: Can not find battery charge curve"},{"location":"faq/#warn-inverter-is-in-calibration-mode","text":"If you see the message \"WARN: Inverter is in calibration mode, Predbat will not function correctly and will be disabled\" in the logfile, then Predbat has identified that your inverter is currently calibrating your battery. Predbat's status will also be set to 'Calibration'. Predbat will set the inverter charge and discharge rates to maximum (if they are not already), SoC target to 100% and battery reserve to minimum (usually 4%), and will not execute the plan nor enable battery charge or discharge. Once the inverter finishes calibrating the battery, Predbat will resume normal operations.","title":"WARN: Inverter is in calibration mode"},{"location":"faq/#inverter-time-is-xxx-predbat-computer-time-is-xxx-this-is-xxx-minutes-skewed-predbat-may-not-function-correctly","text":"If the predbat.status gives a warning error about the inverter time: Then it indicates that there is a mismatch between the clock that Predbat is using and the inverter time clock, and clearly with a clock mismatch, charging and discharging your battery at specific times may not work as expected. There are several potential causes of this problem: Check that the inverter time is correctly set, especially that it is set to GMT (even if it's summertime). In the GivEnergy portal, go to My Inverters / Remote Control (cog symbol) / click SEND next to 'Set Date and Time' Check that the time_zone in appdaemon.yaml is correctly set for your location (e.g. Europe/London) The time zone for Predbat in apps.yaml needs to be set to the same value Finally, check how often your inverter integration is polling your inverter for new data. For GivTCP the Self Run Loop Timer is recommended to be set to a value of between 20 and 60 seconds. If you have checked the above and keep getting \u201ctime is skewed\u201d warnings then it means Home Assistant/predbat isn\u2019t getting the same time from the inverter as it is expecting. Either GivTCP has lost communications with the inverter or the inverter has stopped talking to the world. If you look at the Logbook in Home Assistant you should see a steady stream of entities changing in HA. In particular, you will see the GivTCP inverter time entity changing every polling period, e.g. every 20 seconds. Possible fixes: restart the GivTCP add-on restart Home Assistant (although usually restarting GivTCP is enough) power the inverter off, turn off the panels and battery first, then the inverter, then follow the reverse sequence to power the inverter back on again. This forces the inverter to reconnect to your wifi do a \u2018reset to defaults\u2019 in the portal If you keep getting the warning message, even sporadically, then this points to an underlying issue in your home network between Home Assistant and the inverter. You may need to add a Wi-Fi repeater or ideally a fixed Ethernet connection to your inverter to improve signal strength if this keeps happening. There is a Home Assistant automation that will alert you if GivTCP stops sending data to predbat .","title":"Inverter time is xxx, Predbat computer time is xxx, this is xxx minutes skewed, Predbat may not function correctly"},{"location":"faq/#i-have-another-problem-not-listed-above","text":"If you are still having trouble feel free to raise a Github ticket for support","title":"I have another problem not listed above"},{"location":"install/","text":"Install These instructions will take you through the process of installing and configuring Predbat for first-time use. If you have a working Predbat installation using AppDaemon and are changing to use the Predbat add-on, the AppDaemon to Predbat add-on upgrade process is described below. It's recommended that you watch the Predbat Video Guides before you start. We have tried to make the documentation as comprehensive as possible but a level of familiarity with the basics of Home Assistant, Add-ons, Integrations, Entities, File Editing and YAML is assumed. There are plenty of \"Home Assistant basics\" tutorials on YouTube, but here are a few useful videos to introduce you to Home Assistant and displaying inverter data: What is Home Assistant from Smart Home Junkie YAML Basics from This Smart Home Installing HACS from Speak to the Geek Setting up the Energy dashboard for GivEnergy inverters from Speak to the Geek Power Flow Card Plus from Speak to the Geek If you get stuck, please read the FAQs and if necessary raise a Github ticket for support. Inverter Control install You will need to install an integration to communicate with and control your inverter. The specific integration you need will depend on the brand of inverter you have: Brand Integration GitHub Link GivEnergy GivTCP https://github.com/britkat1980/ha-addons GivEnergy GivEnergy Cloud https://github.com/springfall2008/ge_cloud GivEnergy EMS GivEnergy Cloud https://github.com/springfall2008/ge_cloud Solis SolaX ModBus https://github.com/wills106/homeassistant-solax-modbus Solax Gen4 Solax Modbus https://github.com/wills106/homeassistant-solax-modbus Sofar Sofar MQTT https://github.com/cmcgerty/Sofar2mqtt Huawei Huawei Modbus https://github.com/wlcrs/huawei_solar SolarEdge SolarEdge Modbus https://github.com/WillCodeForCats/solaredge-modbus-multi SunSynk SunSynk Modbus https://github.com/kellerza/sunsynk Fox Fox Modbus https://github.com/nathanmarlor/foxess_modbus LuxPower LuxPython https://github.com/guybw/LuxPython_DEV Predbat was originally written for GivEnergy inverters controlled by the GivTCP add-on but has been extended for other inverter types. Please see Inverter Setup for details on installing and configuring the appropriate inverter control software so that Home Assistant is able to 'see' and manage your inverter. You will need at least 24 hours of history in Home Assistant for Predbat to work correctly, the default is 7 days (but you configure this back to 1 day if you need to). NB: If you have multiple GivEnergy AIOs or a 3-phase inverter, GivTCP version 3 is required. Editing Configuration Files in Home Assistant The basic configuration for Predbat is stored in a configuration file called apps.yaml . A standard template apps.yaml file will be installed as part of the Predbat installation and you will need to edit and customise this configuration file for your own system setup. You will therefore need a method of editing configuration files within your Home Assistant environment. There are several ways to achieve this in Home Assistant, but two of the simplest are to use either the File Editor or Studio Code Server add-ons. Whichever you use is a personal preference. File Editor is a bit simpler, Studio Code Server is more powerful but does require HACS (the Home Assistant Community Store) to be installed first. If you do not have one of these file editors already installed in Home Assistant: For Studio Code Server you will need to install HACS first. Go to Settings / Add-ons / Add-on Store (bottom right) Scroll down the add-on store list, to find either 'File editor' or 'Studio Code Server' as appropriate, click on the add-on, click 'INSTALL' Once the editor has been installed, ensure that the 'Start on boot' option is turned on, and click 'START' to start the add-on Thereafter whenever you need to edit a configuration file in Home Assistant you can navigate to Settings / Add-ons / editor_you_chose_to_use / 'OPEN WEB UI'. You can also turn the 'Show in sidebar' option on to give a quicker way to directly access the editor. If you are using the File Editor to edit Predbat's configuration files, you will need to turn OFF the Enforce Basepath option to access files in different directories (i.e. within the add-ons directory): From the File editor add-on page, click on the 'Configuration' tab to change this setting). It is set to 'On' by default: If you are using Studio Code Server it will default to showing just files and folders in the /config directory. To access the entire HA directory structure, click the three horizontal bars to the left of 'Explorer', File, Open Folder, type '/' (root) and click OK. Predbat add-on install Recommended The simplest way to install Predbat now is with the Predbat add-on. Go to settings, add-ons, select Add-on Store, three dots on the top right, Repositories, then add the following repo ' https://github.com/springfall2008/predbat_addon ' to the list and click close. Now refresh the list and find Predbat, click on it and click 'install'. Ensure 'start on boot' is enabled and click 'start'. NOTE: Throughout the rest of the Predbat documentation you will find reference to the Predbat configuration file apps.yaml and the Predbat logfile. These are located under the Home Assistant directory /addon_configs/6adb4f0d_predbat which contains: predbat.log - Predbat's active logfile that reports details of what Predbat is doing, and details of any errors apps.yaml - Predbat's configuration file which will need to be customised to your system and requirements. This configuration process is described below. You can use your file editor (i.e. 'File editor' or 'Studio Code Server' add-on) to open the directory /addon_configs/6adb4f0d_predbat and view these files. The Predbat web interface will work through the Predbat add-on, you can click on the 'Web UI' button to open it once Predbat is running. If you wish to use Docker with Predbat it is recommended you read the Docker installation instructions inside the Predbat. Solcast Install Predbat needs a solar forecast to predict solar generation and battery charging. If you do have solar panels it's recommended to use the Solcast integration to retrieve your forecast solar generation. If you do not want to use Solcast you can also use Forecast.solar (less accurate) - see below. If you don't have one already, register for a free Solcast hobbyist account and enter the details of your system. You can create 2 sites maximum under one (free hobbyist) account, if you have more aspects then it suggests you average the angle based on the number of panels e.g. $7/10 * 240^\\circ + 3/10 * 120^\\circ$. Hybrid inverters only : If your hybrid inverter capacity is smaller than your array peak capacity, tell Solcast that your AC capacity is equal to your DC capacity (both equal to your array peak kW). Otherwise, Solcast will provide forecast data clipped at your inverter capacity. Let Predbat handle any necessary clipping instead. When supplied with the unclipped Solcast forecast data, Predbat can allow in its model for PV over the inverter capacity going to battery charging (bypassing the hybrid inverter). You will need your API key for the next steps: Predbat direct Solcast method Predbat can obtain the solar forecast directly from Solcast and the Solcast integration described below is not required. First, get your API key from the Solcast website, then as described in the Solcast apps.yaml documentation , uncomment the Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NB: If you use Predbat to obtain your Solcast solar forecast then you can't include the Solar Forecast within the Home Assistant Energy dashboard as you can with the Solcast integration described below. The Solcast integration also contains a 'solar dampening' feature that may be useful to reduce the solar forecast that Predbat receives at certain times of day, e.g. if your panels are shaded by trees or buildings. Predbat direct to forecast.solar The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality. Solcast Home Assistant integration method Install the Solcast integration ( https://github.com/BJReplay/ha-solcast-solar ), create a free Solcast account , configure details of your solar arrays, and request an API key that you enter into the Solcast integration in Home Assistant. Predbat is configured in apps.yaml to automatically discover the Solcast forecast entities created by the Solcast integration in Home Assistant. If you don't have any solar generation then use a file editor to comment out the following lines from the Solar forecast part of the apps.yaml configuration: pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4)) Note that Predbat does not update Solcast integration for you so you will need to create your own Home Assistant automation that updates the solar forecast a few times a day (e.g. dawn, dusk, and just before your nightly charge slot). Keep in mind hobbyist accounts only have 10 polls per day so the refresh period needs to be less than this. If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. Due to the popularity of the Solcast Hobbyist service, Solcast has introduced rate limiting for Hobbyist (free) accounts. If your update gets a 429 error then this is due to rate limiting. Solcast recommends that you poll for updated solar forecasts at random times, i.e. don't poll at precisely X o'clock and zero seconds. The Solcast integration will auto-retry if it gets a 429 error, but to minimise the potential rate limiting the sample Solcast automation below contains non-precise poll times for just this reason. Example Solcast update automation script: alias: Solcast update description: \"Update Solcast solar forecast\" triggers: - trigger: time at: - \"06:02:34\" - \"12:07:47\" - \"18:09:56\" - \"23:11:18\" conditions: [] actions: - action: solcast_solar.update_forecasts data: {} mode: single Manually run the automation and then make sure the Solcast integration is working in Home Assistant by going to Developer Tools / States, filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities. Energy Rates Predbat needs to know what your electricity import and export rates are to optimise battery charging and discharging to minimise your expenditure. These rates are configured in Predbat's apps.yaml configuration file. Follow the instructions in the Energy Rates document. Note: that if you are using the Octopus integration the 'sensor.octopus_xxx' and 'event.octopus_xxx' entities must have a similar pattern of names for Predbat to work correctly - see the FAQ's if they are not. Configuring Predbat You will need to use a file editor (either the File editor or Studio Code Server add-on) to edit the apps.yaml file in Home Assistant to configure Predbat - see Configuring apps.yaml . When Predbat starts up initially it will perform a sanity check of itself and the configuration and confirm the right files are present. You will see this check in the log, should it fail a warning will be issued and predbat.status will also reflect the warning. While the above warning might not prevent Predbat from starting up, you should fix the issue ASAP as it may cause future problems. Note: If you are running the Predbat through the Predbat add-on or via Docker you will get a logfile warning message Predbat Output and Configuration Controls As described above, the basic configuration of Predbat is held in the apps.yaml configuration file. When Predbat first runs it will create a number of output and configuration control entities in Home Assistant which are used to fine-tune how Predbat operates. The entities are all prefixed predbat and can be seen (and changed) from the Settings / Devices & Services / Entities list in Home Assistant. It is recommended that you create a dashboard page with all the required entities to control Predbat and another page to display Predbat's charging and discharging plan for your battery. The Output Data section describes these points in more detail including using the auto-generated predbat_dashboard.yaml dashboard file. The Home Assistant entity predbat.status contains details of what status Predbat is currently in (e.g. Idle, Charging, Error). Detailed progress messages and error logging are written to the Predbat logfile which you can view within Home Assistant using a file editor . The Predbat Configuration Guide gives an overview of the main Predbat configuration items and detail of 'standard Predbat configuration' settings for different electricity tariff types - e.g. a cheap overnight rate, multiple import rates during the day, and variable tariffs such as Agile, etc. The detailed Predbat Customisation Guide details all the Predbat configuration items (switches, input numbers, etc) in Home Assistant, and what each of them does. The Predbat Web Interface provides an easy way to view all of the Predbat configuration items, check apps.yaml for errors, and view the logfile. Ready to light the touch-paper By now you should have successfully installed and configured Predbat and the other components it is dependent upon (e.g. an inverter controller such as GivTCP, Solcast solar forecast, Octopus Energy integration, etc). You have checked the Predbat log file doesn't have any errors (there is a lot of output in the logfile, this is normal). You have configured Predbat's control entities , checked for apps.yaml errors , created some dashboard pages to control and monitor Predbat , and are ready to start Predbat generating your plan. You may initially want to set select.predbat_mode to Monitor to see how Predbat operates, e.g. by studying the Predbat Plan . In Monitor mode Predbat will monitor (but not change) the current inverter settings and predict the battery SoC based on predicted Solar Generation and House Load. NB: In Monitor mode Predbat will NOT plan any battery charge or discharge activity of its own, it will report on the predicted battery charge level based on the current inverter charge & discharge settings, predicted house load and predicted solar generation. In order to enable Predbat to start generating your plan you must delete the 'template: True' line in apps.yaml once you are happy with your configuration. Predbat will automatically run, analyse your house load, battery status, solar prediction, etc and produce a plan based on the current battery settings. Check the Predbat logfile again for errors. Voluminous output is quite normal but any errors or warnings should be investigated. Read the Predbat FAQ's for answers to common questions you may have. Also, check the Predbat status predbat.status - major errors will also be flagged here. Once Predbat is running successfully the recommended next step is to start Predbat planning your inverter charging and discharging activity, but not (yet) make any changes to the inverter. This enables you to get a feel for the Predbat plan and further customise Predbat's settings to meet your needs. Set select.predbat_mode to the correct mode of operation for your system - usually 'Control charge' or 'Control charge & discharge'. Also, you should set switch.predbat_set_read_only to True to stop Predbat from making any changes to your inverter. You can see the planned solar and grid charging and discharging activity in the Predbat Plan . Another set of views can be seen in the detailed Apex Charts showing Predbat's predictions . Once you are happy with the plan Predbat is producing, and are ready to let Predbat start controlling your inverter charging and discharging, set the switch switch.predbat_set_read_only to False and Predbat will start controlling your inverter. Updating Predbat Note that any future updates to Predbat will not overwrite the apps.yaml configuration file that you have tailored to your setup. If new Predbat releases introduce new features to apps.yaml you may therefore need to manually copy across the new apps.yaml settings from the Template apps.yaml . Update via Home Assistant Recommended Predbat can now be updated using the Home Assistant update feature. When a new release is available you should see it in the Home Assistant settings: Click on the update and select Install: Predbat built-in update Recommended for manual selection of versions or automatic updates Predbat can now update itself, just select the version of Predbat you want to install from the select.predbat_update drop-down menu, the latest version will be at the top of the list. Predbat will update itself and automatically restart. Alternatively, if you turn on switch.predbat_auto_update , Predbat will automatically update itself as new releases are published on GitHub. Once Predbat has been installed and configured you should update Predbat to the latest version by selecting the latest version in the select.predbat_update selector, or by enabling the switch.predbat_auto_update to auto-update Predbat. Upgrading from AppDaemon to Predbat add-on These steps assume you already have a working Predbat system and want to upgrade to using the Predbat add-on instead of using either the AppDaemon or the AppDaemon-predbat add-on. Using the Predbat add-on is the strategic direction for Predbat and resolves some performance and data load issues that can occur with AppDaemon. The Predbat code that runs is the same and the configuration is exactly the same, it is just changing the 'container' that Predbat runs within. Before starting, watch the installing Predbat add-on video Although the upgrade steps are low risk, take a full backup of Home Assistant before starting Install the Predbat add-on : Add the Predbat add-on to the list of Repositories in the add-on store Install the Predbat add-on But do not start it - yet Install a file editor if you don't have one already installed - either File Editor or Studio Code Server, it doesn't matter Shutdown your existing AppDaemon or AppDaemon-predbat add-on: Go to Settings/Add-ons Click on the existing AppDaemon/AppDaemon-predbat add-on Click STOP, and untick 'Start on boot' Briefly start the new Predbat add-on so that it creates the addon_config folder and the template apps.yaml file: Go to Settings/Add-ons Click on the Predbat add-on Click START, wait a minute for the add-on to initialise itself, then click STOP. A predbat status warning that you have a template apps.yaml file is normal and can be ignored Open your file editor and open your existing apps.yaml file: If you are using the old 'combined AppDaemon/Predbat add-on installation method' it's in the directory /addon_configs/46f69597_appdaemon-predbat/apps , or with the old HACS Appdaemon add-on then Predbat installation method it's in /config/appdaemon/apps/batpred/config/ Select all the contents of the apps.yaml file and 'copy' (control-C, command-C, etc as appropriate) Now open the template apps.yaml file that's supplied with the Predbat add-on and has been created in the directory /addon_configs/6adb4f0d_predbat , select all the contents of the template apps.yaml file, and paste in the contents of your existing apps.yaml, overwriting the template with your specific configuration Now you are ready to swap from running the AppDaemon or AppDaemon-predbat add-on to the Predbat add-on: Go to Settings/Add-ons Click on the existing AppDaemon/AppDaemon-predbat add-on Make sure it is not running and 'Start on boot' is not ticked Click the back arrow Click on the Predbat add-on Click START, and tick 'Start on boot' If you are using the Predbat automatic monitor then you will need to enable the predbat_running binary sensor and change the automation, replacing the AppDaemon add-on id (a0d7b954_appdaemon) with 'a06adb4f0d_predbat', and 'binary_sensor.appdaemon_running' with 'binary_sensor.predbat_running'. And that's it. You should check the Log tab to ensure it all starts properly, but it should do as you've copied over your existing configuration. Note that if you are using the Predbat direct connection to Solcast then the Predbat add-on will need to download your solar forecast so will use up one or two of your daily API calls (hobbyist accounts have a 10 API calls a day limit). If you are using the Solcast integration then this won't be required. You may find that the Predbat add-on installed with an older version of Predbat than you were previously using, which might require you to update Predbat to the correct version . When you are happily running the Predbat add-on you can delete the AppDaemon or AppDaemon-predbat add-on. Backing up Home Assistant and Predbat It's strongly recommended that you implement an automatic mechanism to back up your Home Assistant and Predbat system. There are several ways of backing up Home Assistant but one of the simplest is the Home Assistant Google Drive Backup which is an add-on that runs every night, automatically makes a backup of Home Assistant (including Predbat), and copies that backup to a Google Drive for safekeeping. If you create a new Google account specifically for your Home Assistant backups you will automatically get 15Gb of free Google Drive storage, enough for a couple of weeks of backups. As well as the full Home Assistant backup you manually copy the contents of Predbat's apps.yaml configuration file to somewhere safe so that if you accidentally mis-edit it, you can get Predbat working quickly again by copying it back again. Uninstalling Predbat Incredible though it may be to imagine, its possible you may want to uninstall Predbat. Removing the Predbat add-on is easy, System / Add-ons / Predbat then select 'Uninstall'. Its recommended that you do a full restart of Home Assistant and all add-on's after removing Predbat. You will find that entities created by Predbat unfortunately don't get removed when you remove the Predbat add-on, and as they do not have unique Home Assistant id's, they can't be removed from the Devices & Services / Entities list. To remove the Predbat entities you will need to use a different mechanism and purge them from Home Assistant: Developer Tools / Actions Search for 'Recorder: Purge Entities' Tick 'Domains to remove' and enter 'predbat' as the domain Tick 'Entity globs to remove' and enter ' .predbat_ ' Tick 'Days to keep' and set to zero days Then click 'Perform Action' This will remove the Predbat entities. Then do another full reboot of Home Assistant all the add-on's.","title":"Install details"},{"location":"install/#install","text":"These instructions will take you through the process of installing and configuring Predbat for first-time use. If you have a working Predbat installation using AppDaemon and are changing to use the Predbat add-on, the AppDaemon to Predbat add-on upgrade process is described below. It's recommended that you watch the Predbat Video Guides before you start. We have tried to make the documentation as comprehensive as possible but a level of familiarity with the basics of Home Assistant, Add-ons, Integrations, Entities, File Editing and YAML is assumed. There are plenty of \"Home Assistant basics\" tutorials on YouTube, but here are a few useful videos to introduce you to Home Assistant and displaying inverter data: What is Home Assistant from Smart Home Junkie YAML Basics from This Smart Home Installing HACS from Speak to the Geek Setting up the Energy dashboard for GivEnergy inverters from Speak to the Geek Power Flow Card Plus from Speak to the Geek If you get stuck, please read the FAQs and if necessary raise a Github ticket for support.","title":"Install"},{"location":"install/#inverter-control-install","text":"You will need to install an integration to communicate with and control your inverter. The specific integration you need will depend on the brand of inverter you have: Brand Integration GitHub Link GivEnergy GivTCP https://github.com/britkat1980/ha-addons GivEnergy GivEnergy Cloud https://github.com/springfall2008/ge_cloud GivEnergy EMS GivEnergy Cloud https://github.com/springfall2008/ge_cloud Solis SolaX ModBus https://github.com/wills106/homeassistant-solax-modbus Solax Gen4 Solax Modbus https://github.com/wills106/homeassistant-solax-modbus Sofar Sofar MQTT https://github.com/cmcgerty/Sofar2mqtt Huawei Huawei Modbus https://github.com/wlcrs/huawei_solar SolarEdge SolarEdge Modbus https://github.com/WillCodeForCats/solaredge-modbus-multi SunSynk SunSynk Modbus https://github.com/kellerza/sunsynk Fox Fox Modbus https://github.com/nathanmarlor/foxess_modbus LuxPower LuxPython https://github.com/guybw/LuxPython_DEV Predbat was originally written for GivEnergy inverters controlled by the GivTCP add-on but has been extended for other inverter types. Please see Inverter Setup for details on installing and configuring the appropriate inverter control software so that Home Assistant is able to 'see' and manage your inverter. You will need at least 24 hours of history in Home Assistant for Predbat to work correctly, the default is 7 days (but you configure this back to 1 day if you need to). NB: If you have multiple GivEnergy AIOs or a 3-phase inverter, GivTCP version 3 is required.","title":"Inverter Control install"},{"location":"install/#editing-configuration-files-in-home-assistant","text":"The basic configuration for Predbat is stored in a configuration file called apps.yaml . A standard template apps.yaml file will be installed as part of the Predbat installation and you will need to edit and customise this configuration file for your own system setup. You will therefore need a method of editing configuration files within your Home Assistant environment. There are several ways to achieve this in Home Assistant, but two of the simplest are to use either the File Editor or Studio Code Server add-ons. Whichever you use is a personal preference. File Editor is a bit simpler, Studio Code Server is more powerful but does require HACS (the Home Assistant Community Store) to be installed first. If you do not have one of these file editors already installed in Home Assistant: For Studio Code Server you will need to install HACS first. Go to Settings / Add-ons / Add-on Store (bottom right) Scroll down the add-on store list, to find either 'File editor' or 'Studio Code Server' as appropriate, click on the add-on, click 'INSTALL' Once the editor has been installed, ensure that the 'Start on boot' option is turned on, and click 'START' to start the add-on Thereafter whenever you need to edit a configuration file in Home Assistant you can navigate to Settings / Add-ons / editor_you_chose_to_use / 'OPEN WEB UI'. You can also turn the 'Show in sidebar' option on to give a quicker way to directly access the editor. If you are using the File Editor to edit Predbat's configuration files, you will need to turn OFF the Enforce Basepath option to access files in different directories (i.e. within the add-ons directory): From the File editor add-on page, click on the 'Configuration' tab to change this setting). It is set to 'On' by default: If you are using Studio Code Server it will default to showing just files and folders in the /config directory. To access the entire HA directory structure, click the three horizontal bars to the left of 'Explorer', File, Open Folder, type '/' (root) and click OK.","title":"Editing Configuration Files in Home Assistant"},{"location":"install/#predbat-add-on-install","text":"Recommended The simplest way to install Predbat now is with the Predbat add-on. Go to settings, add-ons, select Add-on Store, three dots on the top right, Repositories, then add the following repo ' https://github.com/springfall2008/predbat_addon ' to the list and click close. Now refresh the list and find Predbat, click on it and click 'install'. Ensure 'start on boot' is enabled and click 'start'. NOTE: Throughout the rest of the Predbat documentation you will find reference to the Predbat configuration file apps.yaml and the Predbat logfile. These are located under the Home Assistant directory /addon_configs/6adb4f0d_predbat which contains: predbat.log - Predbat's active logfile that reports details of what Predbat is doing, and details of any errors apps.yaml - Predbat's configuration file which will need to be customised to your system and requirements. This configuration process is described below. You can use your file editor (i.e. 'File editor' or 'Studio Code Server' add-on) to open the directory /addon_configs/6adb4f0d_predbat and view these files. The Predbat web interface will work through the Predbat add-on, you can click on the 'Web UI' button to open it once Predbat is running. If you wish to use Docker with Predbat it is recommended you read the Docker installation instructions inside the Predbat.","title":"Predbat add-on install"},{"location":"install/#solcast-install","text":"Predbat needs a solar forecast to predict solar generation and battery charging. If you do have solar panels it's recommended to use the Solcast integration to retrieve your forecast solar generation. If you do not want to use Solcast you can also use Forecast.solar (less accurate) - see below. If you don't have one already, register for a free Solcast hobbyist account and enter the details of your system. You can create 2 sites maximum under one (free hobbyist) account, if you have more aspects then it suggests you average the angle based on the number of panels e.g. $7/10 * 240^\\circ + 3/10 * 120^\\circ$. Hybrid inverters only : If your hybrid inverter capacity is smaller than your array peak capacity, tell Solcast that your AC capacity is equal to your DC capacity (both equal to your array peak kW). Otherwise, Solcast will provide forecast data clipped at your inverter capacity. Let Predbat handle any necessary clipping instead. When supplied with the unclipped Solcast forecast data, Predbat can allow in its model for PV over the inverter capacity going to battery charging (bypassing the hybrid inverter). You will need your API key for the next steps:","title":"Solcast Install"},{"location":"install/#predbat-direct-solcast-method","text":"Predbat can obtain the solar forecast directly from Solcast and the Solcast integration described below is not required. First, get your API key from the Solcast website, then as described in the Solcast apps.yaml documentation , uncomment the Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NB: If you use Predbat to obtain your Solcast solar forecast then you can't include the Solar Forecast within the Home Assistant Energy dashboard as you can with the Solcast integration described below. The Solcast integration also contains a 'solar dampening' feature that may be useful to reduce the solar forecast that Predbat receives at certain times of day, e.g. if your panels are shaded by trees or buildings.","title":"Predbat direct Solcast method"},{"location":"install/#predbat-direct-to-forecastsolar","text":"The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality.","title":"Predbat direct to forecast.solar"},{"location":"install/#solcast-home-assistant-integration-method","text":"Install the Solcast integration ( https://github.com/BJReplay/ha-solcast-solar ), create a free Solcast account , configure details of your solar arrays, and request an API key that you enter into the Solcast integration in Home Assistant. Predbat is configured in apps.yaml to automatically discover the Solcast forecast entities created by the Solcast integration in Home Assistant. If you don't have any solar generation then use a file editor to comment out the following lines from the Solar forecast part of the apps.yaml configuration: pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4)) Note that Predbat does not update Solcast integration for you so you will need to create your own Home Assistant automation that updates the solar forecast a few times a day (e.g. dawn, dusk, and just before your nightly charge slot). Keep in mind hobbyist accounts only have 10 polls per day so the refresh period needs to be less than this. If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. Due to the popularity of the Solcast Hobbyist service, Solcast has introduced rate limiting for Hobbyist (free) accounts. If your update gets a 429 error then this is due to rate limiting. Solcast recommends that you poll for updated solar forecasts at random times, i.e. don't poll at precisely X o'clock and zero seconds. The Solcast integration will auto-retry if it gets a 429 error, but to minimise the potential rate limiting the sample Solcast automation below contains non-precise poll times for just this reason. Example Solcast update automation script: alias: Solcast update description: \"Update Solcast solar forecast\" triggers: - trigger: time at: - \"06:02:34\" - \"12:07:47\" - \"18:09:56\" - \"23:11:18\" conditions: [] actions: - action: solcast_solar.update_forecasts data: {} mode: single Manually run the automation and then make sure the Solcast integration is working in Home Assistant by going to Developer Tools / States, filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities.","title":"Solcast Home Assistant integration method"},{"location":"install/#energy-rates","text":"Predbat needs to know what your electricity import and export rates are to optimise battery charging and discharging to minimise your expenditure. These rates are configured in Predbat's apps.yaml configuration file. Follow the instructions in the Energy Rates document. Note: that if you are using the Octopus integration the 'sensor.octopus_xxx' and 'event.octopus_xxx' entities must have a similar pattern of names for Predbat to work correctly - see the FAQ's if they are not.","title":"Energy Rates"},{"location":"install/#configuring-predbat","text":"You will need to use a file editor (either the File editor or Studio Code Server add-on) to edit the apps.yaml file in Home Assistant to configure Predbat - see Configuring apps.yaml . When Predbat starts up initially it will perform a sanity check of itself and the configuration and confirm the right files are present. You will see this check in the log, should it fail a warning will be issued and predbat.status will also reflect the warning. While the above warning might not prevent Predbat from starting up, you should fix the issue ASAP as it may cause future problems. Note: If you are running the Predbat through the Predbat add-on or via Docker you will get a logfile warning message","title":"Configuring Predbat"},{"location":"install/#predbat-output-and-configuration-controls","text":"As described above, the basic configuration of Predbat is held in the apps.yaml configuration file. When Predbat first runs it will create a number of output and configuration control entities in Home Assistant which are used to fine-tune how Predbat operates. The entities are all prefixed predbat and can be seen (and changed) from the Settings / Devices & Services / Entities list in Home Assistant. It is recommended that you create a dashboard page with all the required entities to control Predbat and another page to display Predbat's charging and discharging plan for your battery. The Output Data section describes these points in more detail including using the auto-generated predbat_dashboard.yaml dashboard file. The Home Assistant entity predbat.status contains details of what status Predbat is currently in (e.g. Idle, Charging, Error). Detailed progress messages and error logging are written to the Predbat logfile which you can view within Home Assistant using a file editor . The Predbat Configuration Guide gives an overview of the main Predbat configuration items and detail of 'standard Predbat configuration' settings for different electricity tariff types - e.g. a cheap overnight rate, multiple import rates during the day, and variable tariffs such as Agile, etc. The detailed Predbat Customisation Guide details all the Predbat configuration items (switches, input numbers, etc) in Home Assistant, and what each of them does. The Predbat Web Interface provides an easy way to view all of the Predbat configuration items, check apps.yaml for errors, and view the logfile.","title":"Predbat Output and Configuration Controls"},{"location":"install/#ready-to-light-the-touch-paper","text":"By now you should have successfully installed and configured Predbat and the other components it is dependent upon (e.g. an inverter controller such as GivTCP, Solcast solar forecast, Octopus Energy integration, etc). You have checked the Predbat log file doesn't have any errors (there is a lot of output in the logfile, this is normal). You have configured Predbat's control entities , checked for apps.yaml errors , created some dashboard pages to control and monitor Predbat , and are ready to start Predbat generating your plan. You may initially want to set select.predbat_mode to Monitor to see how Predbat operates, e.g. by studying the Predbat Plan . In Monitor mode Predbat will monitor (but not change) the current inverter settings and predict the battery SoC based on predicted Solar Generation and House Load. NB: In Monitor mode Predbat will NOT plan any battery charge or discharge activity of its own, it will report on the predicted battery charge level based on the current inverter charge & discharge settings, predicted house load and predicted solar generation. In order to enable Predbat to start generating your plan you must delete the 'template: True' line in apps.yaml once you are happy with your configuration. Predbat will automatically run, analyse your house load, battery status, solar prediction, etc and produce a plan based on the current battery settings. Check the Predbat logfile again for errors. Voluminous output is quite normal but any errors or warnings should be investigated. Read the Predbat FAQ's for answers to common questions you may have. Also, check the Predbat status predbat.status - major errors will also be flagged here. Once Predbat is running successfully the recommended next step is to start Predbat planning your inverter charging and discharging activity, but not (yet) make any changes to the inverter. This enables you to get a feel for the Predbat plan and further customise Predbat's settings to meet your needs. Set select.predbat_mode to the correct mode of operation for your system - usually 'Control charge' or 'Control charge & discharge'. Also, you should set switch.predbat_set_read_only to True to stop Predbat from making any changes to your inverter. You can see the planned solar and grid charging and discharging activity in the Predbat Plan . Another set of views can be seen in the detailed Apex Charts showing Predbat's predictions . Once you are happy with the plan Predbat is producing, and are ready to let Predbat start controlling your inverter charging and discharging, set the switch switch.predbat_set_read_only to False and Predbat will start controlling your inverter.","title":"Ready to light the touch-paper"},{"location":"install/#updating-predbat","text":"Note that any future updates to Predbat will not overwrite the apps.yaml configuration file that you have tailored to your setup. If new Predbat releases introduce new features to apps.yaml you may therefore need to manually copy across the new apps.yaml settings from the Template apps.yaml .","title":"Updating Predbat"},{"location":"install/#update-via-home-assistant","text":"Recommended Predbat can now be updated using the Home Assistant update feature. When a new release is available you should see it in the Home Assistant settings: Click on the update and select Install:","title":"Update via Home Assistant"},{"location":"install/#predbat-built-in-update","text":"Recommended for manual selection of versions or automatic updates Predbat can now update itself, just select the version of Predbat you want to install from the select.predbat_update drop-down menu, the latest version will be at the top of the list. Predbat will update itself and automatically restart. Alternatively, if you turn on switch.predbat_auto_update , Predbat will automatically update itself as new releases are published on GitHub. Once Predbat has been installed and configured you should update Predbat to the latest version by selecting the latest version in the select.predbat_update selector, or by enabling the switch.predbat_auto_update to auto-update Predbat.","title":"Predbat built-in update"},{"location":"install/#upgrading-from-appdaemon-to-predbat-add-on","text":"These steps assume you already have a working Predbat system and want to upgrade to using the Predbat add-on instead of using either the AppDaemon or the AppDaemon-predbat add-on. Using the Predbat add-on is the strategic direction for Predbat and resolves some performance and data load issues that can occur with AppDaemon. The Predbat code that runs is the same and the configuration is exactly the same, it is just changing the 'container' that Predbat runs within. Before starting, watch the installing Predbat add-on video Although the upgrade steps are low risk, take a full backup of Home Assistant before starting Install the Predbat add-on : Add the Predbat add-on to the list of Repositories in the add-on store Install the Predbat add-on But do not start it - yet Install a file editor if you don't have one already installed - either File Editor or Studio Code Server, it doesn't matter Shutdown your existing AppDaemon or AppDaemon-predbat add-on: Go to Settings/Add-ons Click on the existing AppDaemon/AppDaemon-predbat add-on Click STOP, and untick 'Start on boot' Briefly start the new Predbat add-on so that it creates the addon_config folder and the template apps.yaml file: Go to Settings/Add-ons Click on the Predbat add-on Click START, wait a minute for the add-on to initialise itself, then click STOP. A predbat status warning that you have a template apps.yaml file is normal and can be ignored Open your file editor and open your existing apps.yaml file: If you are using the old 'combined AppDaemon/Predbat add-on installation method' it's in the directory /addon_configs/46f69597_appdaemon-predbat/apps , or with the old HACS Appdaemon add-on then Predbat installation method it's in /config/appdaemon/apps/batpred/config/ Select all the contents of the apps.yaml file and 'copy' (control-C, command-C, etc as appropriate) Now open the template apps.yaml file that's supplied with the Predbat add-on and has been created in the directory /addon_configs/6adb4f0d_predbat , select all the contents of the template apps.yaml file, and paste in the contents of your existing apps.yaml, overwriting the template with your specific configuration Now you are ready to swap from running the AppDaemon or AppDaemon-predbat add-on to the Predbat add-on: Go to Settings/Add-ons Click on the existing AppDaemon/AppDaemon-predbat add-on Make sure it is not running and 'Start on boot' is not ticked Click the back arrow Click on the Predbat add-on Click START, and tick 'Start on boot' If you are using the Predbat automatic monitor then you will need to enable the predbat_running binary sensor and change the automation, replacing the AppDaemon add-on id (a0d7b954_appdaemon) with 'a06adb4f0d_predbat', and 'binary_sensor.appdaemon_running' with 'binary_sensor.predbat_running'. And that's it. You should check the Log tab to ensure it all starts properly, but it should do as you've copied over your existing configuration. Note that if you are using the Predbat direct connection to Solcast then the Predbat add-on will need to download your solar forecast so will use up one or two of your daily API calls (hobbyist accounts have a 10 API calls a day limit). If you are using the Solcast integration then this won't be required. You may find that the Predbat add-on installed with an older version of Predbat than you were previously using, which might require you to update Predbat to the correct version . When you are happily running the Predbat add-on you can delete the AppDaemon or AppDaemon-predbat add-on.","title":"Upgrading from AppDaemon to Predbat add-on"},{"location":"install/#backing-up-home-assistant-and-predbat","text":"It's strongly recommended that you implement an automatic mechanism to back up your Home Assistant and Predbat system. There are several ways of backing up Home Assistant but one of the simplest is the Home Assistant Google Drive Backup which is an add-on that runs every night, automatically makes a backup of Home Assistant (including Predbat), and copies that backup to a Google Drive for safekeeping. If you create a new Google account specifically for your Home Assistant backups you will automatically get 15Gb of free Google Drive storage, enough for a couple of weeks of backups. As well as the full Home Assistant backup you manually copy the contents of Predbat's apps.yaml configuration file to somewhere safe so that if you accidentally mis-edit it, you can get Predbat working quickly again by copying it back again.","title":"Backing up Home Assistant and Predbat"},{"location":"install/#uninstalling-predbat","text":"Incredible though it may be to imagine, its possible you may want to uninstall Predbat. Removing the Predbat add-on is easy, System / Add-ons / Predbat then select 'Uninstall'. Its recommended that you do a full restart of Home Assistant and all add-on's after removing Predbat. You will find that entities created by Predbat unfortunately don't get removed when you remove the Predbat add-on, and as they do not have unique Home Assistant id's, they can't be removed from the Devices & Services / Entities list. To remove the Predbat entities you will need to use a different mechanism and purge them from Home Assistant: Developer Tools / Actions Search for 'Recorder: Purge Entities' Tick 'Domains to remove' and enter 'predbat' as the domain Tick 'Entity globs to remove' and enter ' .predbat_ ' Tick 'Days to keep' and set to zero days Then click 'Perform Action' This will remove the Predbat entities. Then do another full reboot of Home Assistant all the add-on's.","title":"Uninstalling Predbat"},{"location":"installation-summary/","text":"Installation summary Please see the sections below for how to achieve each step. This is just a checklist of things: Before you start, it is recommended that you watch the step-by-step installation videos, see the video guides section for those and other videos Make sure the right inverter control module is installed and running Install a file editor (either the File editor or Studio Code Server add-on) to enable you to edit configuration files if you haven't already - Editing configuration files Install Predbat, either: a) Install the Predbat add-on - Predbat add-on install , or b) Complete the separate installation steps: i) Install HACS if you haven't already - HACS install ii) Install AppDaemon if you haven't already - AppDaemon install iii) Install Predbat using HACS - Predbat install Register for a Solcast hobbyist account if you haven't already Solcast install and either: a) Configure Predbat to call Solcast for the Solar forecast, or b) Install and configure the Solcast integration , create an automation to update Solcast a times a day, and check that you see the Solcast data in Home Assistant Follow the Energy Rates instructions to tell Predbat what your import and export energy rates are. If you use Octopus Energy then this includes installing the Octopus Energy integration (if you haven't already) - Octopus Energy Edit Predbat's apps.yaml configuration file to to match your system - apps.yaml settings The apps.yaml file will be in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/predbat/config/ depending on which Predbat install method you used. Inverter settings match the names in GivTCP - should be automatic (but if you have 2 names you will have to edit apps.yaml) You have set the right number of inverters ( num_inverters ) Adjust your inverter_limit and export_limit as required You have your energy rates set correctly either using Octopus Energy integration or entered manually That the Solcast integration (if being used) is matching the configuration correctly - should be automatic If you have an electric car you have set up the Car Charging configuration Add the Predbat entities to your dashboard - Output data Follow the Configuration Guide to set 'standard' Predbat configuration settings depending on your import and export tariffs The detailed Customisation Guide lists all Predbat's controls and settings in Home Assistant that can be tuned for your system Set up the Predbat Plan card so you can check what Predbat is planning to do - Create the Predbat Plan card Set up the Apex Charts for other views on what Predbat is doing - Creating the charts Then check that Predbat is working correctly: Look at the Predbat log file and make sure you have no errors or warnings that are unexpected Check that there are no errors in apps.yaml Comment out or delete the 'template: True' line in apps.yaml when you are ready to start Predbat The predbat.status in Home Assistant should be 'Idle' (if there are any errors then they are reported here too) Start with select.predbat_mode set to 'Monitor' but remember to change it later to enable Predbat to control your inverter Look at the FAQ for help Overview of the key configuration elements:","title":"Install summary"},{"location":"installation-summary/#installation-summary","text":"Please see the sections below for how to achieve each step. This is just a checklist of things: Before you start, it is recommended that you watch the step-by-step installation videos, see the video guides section for those and other videos Make sure the right inverter control module is installed and running Install a file editor (either the File editor or Studio Code Server add-on) to enable you to edit configuration files if you haven't already - Editing configuration files Install Predbat, either: a) Install the Predbat add-on - Predbat add-on install , or b) Complete the separate installation steps: i) Install HACS if you haven't already - HACS install ii) Install AppDaemon if you haven't already - AppDaemon install iii) Install Predbat using HACS - Predbat install Register for a Solcast hobbyist account if you haven't already Solcast install and either: a) Configure Predbat to call Solcast for the Solar forecast, or b) Install and configure the Solcast integration , create an automation to update Solcast a times a day, and check that you see the Solcast data in Home Assistant Follow the Energy Rates instructions to tell Predbat what your import and export energy rates are. If you use Octopus Energy then this includes installing the Octopus Energy integration (if you haven't already) - Octopus Energy Edit Predbat's apps.yaml configuration file to to match your system - apps.yaml settings The apps.yaml file will be in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/predbat/config/ depending on which Predbat install method you used. Inverter settings match the names in GivTCP - should be automatic (but if you have 2 names you will have to edit apps.yaml) You have set the right number of inverters ( num_inverters ) Adjust your inverter_limit and export_limit as required You have your energy rates set correctly either using Octopus Energy integration or entered manually That the Solcast integration (if being used) is matching the configuration correctly - should be automatic If you have an electric car you have set up the Car Charging configuration Add the Predbat entities to your dashboard - Output data Follow the Configuration Guide to set 'standard' Predbat configuration settings depending on your import and export tariffs The detailed Customisation Guide lists all Predbat's controls and settings in Home Assistant that can be tuned for your system Set up the Predbat Plan card so you can check what Predbat is planning to do - Create the Predbat Plan card Set up the Apex Charts for other views on what Predbat is doing - Creating the charts Then check that Predbat is working correctly: Look at the Predbat log file and make sure you have no errors or warnings that are unexpected Check that there are no errors in apps.yaml Comment out or delete the 'template: True' line in apps.yaml when you are ready to start Predbat The predbat.status in Home Assistant should be 'Idle' (if there are any errors then they are reported here too) Start with select.predbat_mode set to 'Monitor' but remember to change it later to enable Predbat to control your inverter Look at the FAQ for help Overview of the key configuration elements:","title":"Installation summary"},{"location":"inverter-setup/","text":"Inverter setup PredBat was originally written for GivEnergy inverters using the GivTCP integration but this is now being extended to other inverter models: Name Integration Template GivEnergy with GivTCP GivTCP givenergy_givtcp.yaml Solis Hybrid inverters Solax Modbus integration ginlong_solis.yaml Solax Gen4 inverters Solax Modbus integration in Modbus Power Control Mode solax_sx4.yaml Sofar inverters Sofar MQTT integration sofar.yaml Huawei inverters Huawei Solar huawei.yaml SolarEdge inverters Solaredge Modbus Multi solaredge.yaml Givenergy with GE Cloud ge_cloud givenergy_cloud.yaml Givenergy with GE Cloud EMS ge_cloud EMS givenergy_ems.yaml Givenergy/Octopus No Home Assistant n/a ge_cloud_octopus_standalone.yaml SunSynk Sunsynk sunsynk.yaml Fox Foxess fox.yaml LuxPower LuxPython luxpower.yaml Growatt with Solar Assistant Solar Assistant spa.yaml sph.yaml SigEnergy SigEnergy sigenergy_sigenstor.yaml Note that support for all these inverters is in various stages of development. Please expect things to fail and report them as Issues on GitHub. NB: By default the apps.yaml template for GivTCP is installed with Predbat. If you are using a different inverter then you will need to copy the appropriate apps.yaml template from the above list and use it to replace the GivTCP apps.yaml - if you copy but don't replace the standard template then Predbat will not function correctly. GivEnergy with GivTCP It's recommended that you first watch the Installing GivTCP and Mosquitto Add-on's video from Speak to the Geek . Although the video covers GivTCP v2 and v3 has been recently released, the installation and setup process are very similar. The below instructions assume you are installing GivTCP v3, with changes highlighted against GivTCP v2 as covered in the video. Install Mosquitto Broker add-on: Go to Settings / Add-ons / Add-on Store (bottom right) Scroll down the add-on store list, to find 'Mosquitto broker', click on the add-on, then click 'INSTALL' Once the Mosquitto broker has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on, and click 'START' to start the add-on Next, configure Mosquitto broker by going to Settings / Devices and Services / Integrations. Mosquitto broker should appear as a Discovered integration so click the blue 'CONFIGURE' button, then SUBMIT to complete configuring Mosquitto broker With GivTCP v3 you no longer need to create a dedicated Home Assistant user for MQTT so this part of the video can be skipped over Install the GivTCP add-on: Go to Settings / Add-ons / Add-on Store Click the three dots in the top right corner, then Repositories You'll need to add the GivTCP repository as an additional custom repository so paste/type ' https://github.com/britkat1980/ha-addons ' into the text box and click 'Add' the 'Close' NB: this URL is for GivTCP v3, not v2 as covered in the video. Click the back button and then re-navigate to Settings / Add-ons / Add-on Store so Home Assistant picks up the GivTCP add-on from the custom repository Scroll down the add-on store list, to find 'GivTCP-V3', you should see the three addons; the production version, the latest beta and the latest dev versions. Click on the 'GivTCP' add-on, then click 'INSTALL' Once GivTCP has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on Configure GivTCP: The configuration process for GivTCP in v3 has changed from that shown in the video, the Configuration tab is no longer used and all configuration is now done via the add-on's Web interface On the GivTCP add-on, click 'START' to start the add-on Once the add-on has started, click 'Open Web UI' or go to http://homeassistant.local:8099/ , then click 'Go to Config Page' to configure GivTCP GivTCP will auto-discover your inverters and batteries so you shouldn't need to manually enter these, but check the IP address(s) it finds are correct If you have a single AIO then for Predbat to be able to communicate via REST to the AIO, it MUST be the first device configured in GivTCP. Conversely if you have a gateway and multiple AIO's then the gateway MUST be the first device in GivTCP If you have multiple inverters you may wish to change the default device prefixes that GivTCP assigns ('givtcp', 'givtcp2', 'givtcp3', etc) to make it easier to identify your devices within Home Assistant. For example, if you have a gateway and two AIOs you could use the prefixes 'GW', 'AIO-1' and 'AIO-2'. The prefixes should be set before you start using GivTCP in anger as changing the prefixes later on will result in both the old and new sensor names appearing in Home Assistant with the 'old' sensors being \"unavailable\". Note that if you do change the givtcp prefixes then you will also have to edit the apps.yaml configuration file to match, and change the sensor names that Predbat is looking for (by default prefixed 'givtcp_xxx') to your new sensor naming structure Click Next and Next to get to the Selfrun page, and turn on Self Run. The Self Run Loop Timer is how often GivTCP will retrieve data from your inverters - it's recommended that set this to a value between 20 and 60, but not less than 15 seconds as otherwise the inverter will then spend all its time talking to GivTCP and won't communicate with the GivEnergy portal and app GivTCP now auto-populates the MQTT page so as long as you're using Mosquitto broker within Home Assistant; you won't need to create a dedicated MQTT user or enter the details on the MQTT page You don't need to configure the Influx page. Tariff and Palm pages can also be skipped as these functions are done by Predbat (Optional) On the Web page, you can turn the Dashboard on to see a simple power flow diagram for your inverters (similar to the GivEnergy mobile app) On the 'Misc' page check that 'Print Raw' is set to on for added monitoring Finally, click 'Save and Restart' and GivTCP should start communicating with your inverters and will automatically create a set of 'givtcp_xxx' entities in Home Assistant for your inverter data, inverter controls and battery data Check the GivTCP Log tab that there aren't any errors; it should end with 'Publishing Home Assistant Discovery messages' Before you start using GivTCP to control your inverter Verify in the GivEnergy portal settings the following inverter settings are set correctly as these are settings that Predbat doesn't control, and if not set correctly could affect your battery activity: \"Inverter Charge Power Percentage\" is set to 100 (Predbat has its own low-rate charge control you can use if you wish) \"Inverter Discharge Power Percentage\" is set to 100. If you do wish to set a lower discharge rate then its recommended that instead you set inverter_limit_discharge in apps.yaml to the rate \"Battery Cutoff % Limit\" is set to 4 \"Enable AC Charge Upper Limit' is enabled (if you have this option) That charge slot 2 (or more) are disabled (as Predbat only uses slot1) That discharge slot 2 (or more) are disabled (as Predbat only uses slot1) Specific Predbat configuration requirements for certain GivEnergy equipment The rest of the Predbat installation instructions should now be followed, but its worth highlighting that there are a few specific settings that should be set for certain GivEnergy equipment. These settings are documented in the appropriate place in the documentation, but for ease of identification, are repeated here: If you are using GivTCP v3 and have an AIO or 3-phase inverter then you will need to manually set geserial in apps.yaml to your inverter serial number as the auto-detect doesn't work for this setup If you have a single AIO then control is directly to the AIO. Ensure geserial in apps.yaml is correctly picking the AIO and comment out geserial2 lines If you have multiple AIOs then all control of the AIOs is done through the Gateway so geserial in apps.yaml should be set to the Gateway serial number If you have multiple AIOs you might want to consider setting inverter charge and discharge limits unless you want to charge and discharge at the full 12kWh! If you have a 2.6kWh, 5.2kWh or AIO battery then you will need to set battery_scaling in apps.yaml as the battery size is incorrectly reported to GivTCP If you have an older inverter (AC3 or Gen 1 hybrid) with firmware that has battery pause support you may need to comment out pause start and end time controls in apps.yaml If you have a Gen 2, Gen 3 or AIO then you may need to set inverter_reserve_max in apps.yaml to 98. If you have a Gen 1 or a firmware version that allows the reserve being set to 100 then you can change the default from 98 to 100 If your inverter has been wired as an EPS (Emergency Power Supply) or AIO 'whole home backup', consider setting input_number.predbat_set_reserve_min to reserve some battery power for use in emergencies. NB: GivTCP and Predbat do not currently yet work together for 3-phase inverters . This is being worked on by the author of GivTCP, e.g. see GivTCP issue: unable to charge or discharge 3 phase inverters with predbat Solis Inverters To run PredBat with Solis hybrid inverters, follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solisx_rtc Real Time Clock sensor.solisx_battery_power Battery Power Instead of apps.yaml use ginlong_solis.yaml from this Repo as your starting template. The majority of settings should be correct but please check. You will need to un-comment the template line to enable it. Save it to the appropriate Predbat software directory . Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Your inverter will require a \"button press\" triggered by Predbat to update the schedules. Some Solis inverter integrations feature a combined charge/discharge update button, in which case a single entry of: charge_discharge_update_button: - button.solis_charge_discharge is sufficient. For other configurations (for example using the \"solis_fb00\" plugin) where separate buttons are used for charging and discharging, provide both: charge_update_button: - button.solis_charge discharge_update_button: - button.solis_discharge Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration. Solax Gen4 Inverters Use the template configuration from: solax.sx4.yaml Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Please see this ticket in Github for ongoing discussion: https://github.com/springfall2008/batpred/issues/259 Sofar Inverters For this integration, the key elements are: Hardware - sofar2mqtt EPS board - Relatively easy to solder and flash, or can be bought pre-made. Software - Sofar MQTT integration - MQTT integration Home Assistant configuration - sofar_inverter.yaml (in templates directory), defines the custom HA entities and should be added to HA's configuration.yaml . This is the default Sofar HA configuration with a couple of additional inputs to support battery capacity. Predbat configuration - sofar.yaml template for Predbat (in templates directory). This file should be copied to apps.yaml Please note that the inverter needs to be put into \"Passive Mode\" for the sofar2mqtt to control the inverter. This integration has various limitations, it can charge and discharge the battery but does not have finer control over reserve and target SOC% Note: You will need to change the min reserve in Home Assistant to match your minimum battery level ( input_number.predbat_set_reserve_min ). Please see this ticket in Github for ongoing discussions: https://github.com/springfall2008/batpred/issues/395 Huawei Inverters The discussion ticket is here: https://github.com/springfall2008/batpred/issues/684 Please copy the template apps.yaml from https://github.com/springfall2008/batpred/blob/main/templates/huawei.yaml and modify them for your system Ensure you set input_number.predbat_set_reserve_min to the minimum value for your system which may be 12% SolarEdge Inverters The discussion ticket is here: https://github.com/springfall2008/batpred/issues/181 Please copy the template apps.yaml from https://github.com/springfall2008/batpred/blob/main/templates/solaredge.yaml and modify them for your system The default entity name prefix for the integration is 'solaredge' but if you have changed this on installation then you will need to amend the apps.yaml template and the template sensors to match your new prefix Ensure that number.solaredge_i1_storage_command_timeout is set to a reasonably high value e.g. 3600 seconds to avoid the commands issued being cancelled Power Control Options, as well as Enable Battery Control, must be enabled in the Solaredge Modbus Multi integration configuration, and switch.solaredge_i1_advanced_power_control must be on. For pv_today , pv_power and load_power sensors to work you need to create these as a template within your Home Assistant configuration.yaml . Please see: https://gist.github.com/Ashpork/f80fb0d3cb22356a12ed24734065061c . These sensors are not critical so you can just comment it out in apps.yaml if you can't get it to work template: - sensor: - name: \"Solar Panel Production W\" unique_id: solar_panel_production_w unit_of_measurement: \"W\" icon: mdi:solar-power state: > {% set i1_dc_power = states('sensor.solaredge_i1_dc_power') | float(0) %} {% set b1_dc_power = states('sensor.solaredge_b1_dc_power') | float(0) %} {% if (i1_dc_power + b1_dc_power <= 0) %} 0 {% else %} {{ (i1_dc_power + b1_dc_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_dc_power') | is_number and states('sensor.solaredge_b1_dc_power') | is_number }} - name: \"Solar House Consumption W\" unique_id: solar_house_consumption_w unit_of_measurement: \"W\" icon: mdi:home state: > {% set i1_ac_power = states('sensor.solaredge_i1_ac_power') | float(0) %} {% set m1_ac_power = states('sensor.solaredge_m1_ac_power') | float(0) %} {% if (i1_ac_power - m1_ac_power <= 0) %} 0 {% else %} {{ (i1_ac_power - m1_ac_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_ac_power') | is_number and states('sensor.solaredge_m1_ac_power') | is_number }} sensor: - platform: integration source: sensor.solar_panel_production_w method: left unit_prefix: k name: solar_panel_production_kwh If you have multiple batteries connected to your SolarEdge inverter and are using the SolarEdge Modbus Multi integration, this enumerates the multiple batteries as b1, b2, b3, etc with separate entities per battery. You will need to make a number of changes to the solaredge apps.yaml, replacing the following entries: battery_rate_max: - sensor.calc_power_batteries_max_charge_power # maximum charge power of all the batteries battery_power: - sensor.calc_power_batteries_dc_power soc_percent: - sensor.calc_battery_all_state # average SoC of the batteries soc_max: - sensor.calc_battery_total_capacity # combined kWh maximum value of all the batteries soc_kw: - sensor.calc_battery_current_capacity set charge_rate and discharge_rate to the SolarEdge inverter values, e.g. 5000 And add the following additional template sensors to configuration.yaml: - sensor: # Template sensor for Max Battery Charge rate # This is the sum of all three batteries charge rate as the max charge rate can be higher than inverter capacity (e.g. 8k) when charging from AC+Solar # Returns 5000W as the minimum max value, the single battery charge/discharge limit to ensure at least one battery can always be charged if one or more batteries have 'gone offline' to modbus - name: \"Calc Power - Batteries Max Charge Power\" unique_id: calc_power_batteries_max_charge_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_max_charge_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_max_charge_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_max_charge_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) | int %} {{ (myValue if (myValue) > 5000 else 5000) }} # Calculate Total Battery Power Value - name: \"Calc Power - Batteries DC Power\" unique_id: calc_power_batteries_dc_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_dc_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_dc_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_dc_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Average state of charge across the batteries - name: \"Calc Battery All State\" unique_id: calc_battery_all_state unit_of_measurement: \"%\" state: > {% set myB1 = float(states('sensor.solaredge_b1_state_of_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_state_of_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_state_of_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3) / 3) | round(0) %} {{ myValue }} # Total Energy Stored in the Batteries - name: \"Calc Battery Total Capacity\" unique_id: calc_battery_total_capacity unit_of_measurement: kWh state: > {% set myB1 = float(states('sensor.solaredge_b1_maximum_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_maximum_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_maximum_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Current Energy Stored in the Batteries - name: \"Calc Battery Current Capacity\" unique_id: calc_battery_current_capacity unit_of_measurement: kWh state: > {% set myValue = (float(states('sensor.calc_battery_all_state'),0) / 100) * float(states('sensor.calc_battery_total_capacity'),0) %} {{ myValue }} GivEnergy with ge_cloud This is an experimental system, please discuss it on the ticket: https://github.com/springfall2008/batpred/issues/905 First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_cloud.yaml from templates into your apps.yaml and edit Set geserial to your inverter serial number Make sure that the 'discharge down to' registers are set to 4% and slots 2, 3 and 4 for charge and discharge are disabled in the portal (if you have them) GivEnergy with EMS First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_ems.yaml from templates into your apps.yaml and edit Set geserial to your first inverter serial and geserial2 to the second (look in HA for entity names) Set geseriale to the EMS inverter serial number (look in HA for the entity names) Turn off charge, export and discharge slots 2, 3 and 4 as Predbat will only use slot 1 - set the start and end times for these to 00:00 GivEnergy/Octopus Cloud Direct - No Home Assistant Take the template and enter your GivEnergy API key directly into apps.yaml Set your Octopus API key in apps.yaml Set your Solcast API key in apps.yaml Review any other configuration settings Launch Predbat with hass.py (from the Predbat-addon repository) either via a Docker or just on a Linux/MAC/WSL command line shell. Fox Experimental I've managed to get Batpred working on my Fox ESS inverter, connected via an Elfin EW11 modbus and using Nathan's Fox ESS Modbus tool. See: https://github.com/springfall2008/batpred/issues/1401 The template is in the templates area, give it a try Lux Power This requires the LuxPython component which integrates with your Lux Power inverter Copy the template luxpower.yaml from templates into your apps.yaml and edit inverter and battery settings as required LuxPower does not have a SoC max entity in kWh and the SoC percentage entity never reports the battery reaching 100%, so create the following template helper sensors: name: Lux SoC Max kWh template: {{ (states(\"sensor.lux_battery_capacity_ah\") |float) * (states(\"sensor.lux_battery_voltage_live\") | float) / 1000}} unit of measurement: kWh device class: Energy state class: Total name: Lux Battery SoC Corrected template: {% set soc = states('sensor.lux_battery')|int %} {% set charging_stopped = states('sensor.lux_bms_limit_charge_live')|float == 0 %} {% if charging_stopped and soc > 97 %} 100 {% else %} {{ soc }} {% endif %} unit of measurement: % device class: Battery state class: Measurement Growatt with Solar Assistant You need to have a Solar Assistant installation https://solar-assistant.io Growatt has two popular series of inverters, SPA and SPH. Copy the template that matches your model from templates into your apps.yaml and edit inverter and battery settings as required. Yours may have different entity IDs on Home Assistant. Sunsynk Copy the Sunsynk apps.yaml template and edit for your system. Create the following Home Assistant automations: alias: Predbat Charge / Discharge Control description: \"Turn SunSynk charge/discharge on/off to mirror Predbat\" trigger: - platform: state entity_id: - binary_sensor.predbat_charging to: \"on\" id: predbat_charge_on - platform: state entity_id: - binary_sensor.predbat_charging to: \"off\" id: predbat_charge_off - platform: state entity_id: - binary_sensor.predbat_exporting to: \"on\" id: predbat_discharge_on - platform: state entity_id: - binary_sensor.predbat_exporting to: \"off\" id: predbat_discharge_off condition: [] action: - choose: - conditions: - condition: trigger id: - predbat_charge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_grid_charge_timezone1 - conditions: - condition: trigger id: - predbat_charge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_grid_charge_timezone1 data: {} - conditions: - condition: trigger id: - predbat_discharge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_solar_sell - conditions: - condition: trigger id: - predbat_discharge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_solar_sell data: {} mode: single alias: PredBat - Copy Charge Limit description: Copy Battery SOC to all timezone (time) slots trigger: - platform: state entity_id: - number.sunsynk_set_soc_timezone1 to: null condition: [] action: - service: number.set_value data_template: entity_id: - number.sunsynk_set_soc_timezone2 - number.sunsynk_set_soc_timezone3 - number.sunsynk_set_soc_timezone4 - number.sunsynk_set_soc_timezone5 - number.sunsynk_set_soc_timezone6 value: \"{{ states('number.sunsynk_set_soc_timezone1')|int(20) }}\" mode: single Create the following templates sensors in your configuration.yaml: template: sensor: - name: \"sunsynk_max_battery_charge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_charge_current_limit')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_max_battery_discharge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_discharge_current_limit')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_charge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_charge_current')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_discharge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_discharge_current')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} Sigenergy Sigenstor To integrate your Sigenergy Sigenstor inverter with Predbat, you will need to follow the steps below: make sure the inverter is already integrated into Home Assistant. Here is a ( repo ) with full integration (this is the Python version of the Sigenergy Home Assistant integration). Copy the template sigenergy_sigenstor.yaml template over your apps.yaml and edit for your system. The following additions are needed to facilitate integration with Predbat and need to put put in Home Assistant configuration.yaml or a package yaml: input_select: predbat_requested_mode: name: \"Predbat Requested Mode\" options: - \"Demand\" - \"Charging\" - \"Freeze Charging\" - \"Discharging\" - \"Freeze Discharging\" initial: \"Demand\" icon: mdi:battery-unknown automation: - id: predbat_requested_mode_action alias: \"Predbat Requested Mode Action\" description: \"Acts as a mapper for the input_select.predbat_requested_mode to the select.sigen_plant_remote_ems_control_mode\" mode: single triggers: - trigger: state entity_id: - input_select.predbat_requested_mode conditions: [] actions: - action: select.select_option metadata: {} target: entity_id: select.sigen_plant_remote_ems_control_mode data: option: > {% if is_state('input_select.predbat_requested_mode', \"Demand\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Discharging\") %}Command Discharging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Discharging\") %}Command Discharging (ESS First) {% endif %} - choose: # Set charging limit to 0 when requested mode is Freeze Charging - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_charging_limit value: 0 # Set discharging limit to 0 when requested mode is Freeze Discharging - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_discharging_limit value: 0 # If neither of the above conditions are met, set the limits to the input numbers - conditions: - condition: not conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_charging_limit value: \"{{ [(states('input_number.charge_rate') | float / 1000) | round(2), states('sensor.sigen_inverter_ess_rated_charge_power') | float] | min}}\" - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_discharging_limit value: \"{{ [(states('input_number.discharge_rate') | float / 1000) | round(2), states('sensor.sigen_inverter_ess_rated_discharge_power') | float] | min}}\" - id: \"automation_sigen_ess_max_charging_limit_input_number_action\" alias: \"Predbat max charging limit action\" description: \"Mapper from input_number.charge_rate to number.sigen_plant_ess_max_charging_limit\" triggers: - trigger: state entity_id: input_number.charge_rate action: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_charging_limit data: value: \"{{ (states('input_number.charge_rate')| float / 1000) | round(2) }}\" mode: single - id: \"automation_sigen_ess_max_discharging_limit_input_number_action\" alias: \"Predbat max discharging limit action\" description: \"Mapper from input_number.discharge_rate to number.sigen_plant_ess_max_discharging_limit\" triggers: - trigger: state entity_id: input_number.discharge_rate action: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_discharging_limit data: value: \"{{ (states('input_number.discharge_rate')| float / 1000) | round(2) | int }}\" mode: single input_number: charge_rate: name: Battery charge rate initial: 6950 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W discharge_rate: name: Battery discharge rate initial: 8000 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W I want to add an unsupported inverter to Predbat First copy one of the template configurations that is close to your system and try to configure it to match the sensors you have Create a GitHub ticket for support and add what you know to the ticket Then find out how to control your inverter inside Home Assistant, ideally share any automation you have to control the inverter You can create a new inverter type in apps.yaml and change the options as to which controls it has Set inverter_type in apps.yaml to match the custom inverter definition ('MINE' in the example below) The easy way to integrate using Home Assistant services to start charges and discharges, edit the template below: inverter_type: MINE inverter: name: \"My Shiny new Inverter\" has_rest_api: False has_mqtt_api: False output_charge_control: \"power\" has_charge_enable_time: False has_discharge_enable_time: False has_target_soc: False has_reserve_soc: False charge_time_format: \"S\" charge_time_entity_is_option: False soc_units: \"%\" num_load_entities: 1 has_ge_inverter_mode\": False time_button_press: False clock_time_format: \"%Y-%m-%d %H:%M:%S\" write_and_poll_sleep: 2 has_time_window: False support_charge_freeze: False support_discharge_freeze\": False # Services to control charging/discharging charge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power and Grid\" charge_stop_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power\" discharge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Maximize Self Consumption\" Inverter control option The following options are supported per inverter: has_rest_api When True the REST API will be used to fetch data/control the inverter. This is currently only for GivEnergy inverters with GivTCP and givtcp_rest must be set in apps.yaml has_mqtt_api When True the MQTT API to Home Assistant will be used to issue control messages for the inverter The MQTT/publish service is used with the topic as defined by mqtt_topic in apps.yaml Messages will be sent through these controls: Values that are updated: topic /set/reserve - payload=reserve topic /set/charge_rate - payload=new_rate topic /set/discharge_rate - payload=new_rate topic /set/target_soc - payload=target_soc These three change between battery charge/discharge and auto (idle) mode: topic /set/charge - payload=charge_rate topic /set/discharge - payload=discharge_rate topic /set/auto - payload=true Service API When True a Home Assistant service will be used to issue control messages for the inverter For each service you wish to use it must be defined in apps.yaml. There are two ways to define a service, the basic mode: charge_start_service: my_service_name_charge Will call my_service_name_charge for the charge start service. Or the custom method: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" charge_start_time: \"{charge_start_time}\" charge_end_time: \"{charge_end_time}\" Here you can define all the values passed to the service and use the default values from the template or define your own. You can also call more than one service e.g: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" - service: switch.turn_off entity_id: switch.tsunami_charger Note: By default the service will only be called once until things change, e.g. charge_start_service will be called once and then won't be called again until charge_stop_service stops the charge. If however, you want the service to be called on each Predbat run then you should set repeat to True for the given service e.g: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" repeat: True charge_start_service Called to start a charge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SOC to charge to power - The charge power to use charge_start_time - Start time for the charge charge_end_time - End time for the charge charge_freeze_service If defined will be called for freeze charge, otherwise, charge_start_service is used for freeze charge also. discharge_start_service Called to start a discharge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SOC to discharge to power - The discharge power to use discharge_freeze_service If defined will be called for Discharge freeze, otherwise, discharge_start_service is used for freeze discharge also. charge_stop_service Called to stop a charge device_id - as defined in apps.yaml by device_id discharge_stop_service Called to stop a discharge, if not set then charge_stop_service will be used instead device_id - as defined in apps.yaml by device_id output_charge_control Set to power, current or none When power the inverter has a charge_rate and discharge_rate setting in watts defined in apps.yaml When current the inverter has timed_charge_current and timed_discharge_current setting in amps defined in apps.yaml charge_control_immediate When True the inverter timed_charge_current or timed_discharge_current is used to control charging or discharging as/when it starts and stops rather than using a timed method. current_dp Sets the number of decimal places when setting the current in Amps, which should be 0 or 1 has_charge_enable_time When True the inverter has a setting defined in apps.yaml called scheduled_charge_enable when can be used to enable/disable timed charging. has_discharge_enable_time When True the inverter has a setting defined in apps.yaml called scheduled_discharge_enable when can be used to enable/disable timed discharging. has_target_soc When True the inverter has a target charge SoC setting in apps.yaml called charge_limit . When False charging must be turned on and off by Predbat rather than the inverter doing it based on the target SoC %. has_reserve_soc When True the inverter has a discharge reserve SoC setting in apps.yaml called reserve which is the target % to discharge the battery down to. When False discharging must be turned on and off by Predbat rather than the inverter doing it based on discharge Soc %. has_timed_pause When True the inverter has a setting in apps.yaml called pause_mode and settings pause_start_time and pause_end_time which can be used to pause the inverter from charging and discharging the battery - this is for GivEnergy systems only right now. charge_time_format When set to \"HH:MM:SS\" the inverter has: charge_start_time charge_end_time discharge_start_time discharge_end_time Which are option selectors in the format HH:MM:SS (e.g. 12:23:00) where seconds are always 00. When set to \"H M\" the inverter has: charge_start_hour charge_end_hour charge_start_minute charge_end_minute discharge_start_hour discharge_end_hour discharge_start_minute discharge_end_minute Settings in apps.yaml which can be used to set the start and end times of charges and discharges charge_time_entity_is_option When True charge_start_time charge_end_time discharge_start_time and discharge_end_time are all Options, when false they are number values. clock_time_format Defines the time format of the inverter clock setting inverter_time in apps.yaml soc_units Defines the units of the SOC setting (currently not used) time_button_press When true the inverter has a button press which is needed to update the inverter registers from the Home Assistant values. The apps.yaml setting charge_discharge_update_button is the entity name of the button that must be pressed and polled until it updates after each inverter register change. support_charge_freeze When True the inverter supports charge freeze modes support_discharge_freeze When True the inverter supports discharge freeze modes has_ge_inverter_mode When True the inverter as the GivEnergy inverter modes (ECO, Timed Export etc). num_load_entities Sets the number of load_power_n settings in apps.yaml are present in addition to load_power (the default) write_and_poll_sleep Sets the number of seconds between polls of inverter settings has_idle_time When True the inverter has an idle time register which must be set to the start and end times for ECO mode (GivEnergy EMS) can_span_midnight When True start and end times for charge and discharge can span midnight e.g. 23:00:00 - 01:00:00 is a 2-hour slot. charge_discharge_with_rate When True when charging discharge rate must be 0 and visa-versa. When false the rate does not have to change.","title":"Inverter setup"},{"location":"inverter-setup/#inverter-setup","text":"PredBat was originally written for GivEnergy inverters using the GivTCP integration but this is now being extended to other inverter models: Name Integration Template GivEnergy with GivTCP GivTCP givenergy_givtcp.yaml Solis Hybrid inverters Solax Modbus integration ginlong_solis.yaml Solax Gen4 inverters Solax Modbus integration in Modbus Power Control Mode solax_sx4.yaml Sofar inverters Sofar MQTT integration sofar.yaml Huawei inverters Huawei Solar huawei.yaml SolarEdge inverters Solaredge Modbus Multi solaredge.yaml Givenergy with GE Cloud ge_cloud givenergy_cloud.yaml Givenergy with GE Cloud EMS ge_cloud EMS givenergy_ems.yaml Givenergy/Octopus No Home Assistant n/a ge_cloud_octopus_standalone.yaml SunSynk Sunsynk sunsynk.yaml Fox Foxess fox.yaml LuxPower LuxPython luxpower.yaml Growatt with Solar Assistant Solar Assistant spa.yaml sph.yaml SigEnergy SigEnergy sigenergy_sigenstor.yaml Note that support for all these inverters is in various stages of development. Please expect things to fail and report them as Issues on GitHub. NB: By default the apps.yaml template for GivTCP is installed with Predbat. If you are using a different inverter then you will need to copy the appropriate apps.yaml template from the above list and use it to replace the GivTCP apps.yaml - if you copy but don't replace the standard template then Predbat will not function correctly.","title":"Inverter setup"},{"location":"inverter-setup/#givenergy-with-givtcp","text":"It's recommended that you first watch the Installing GivTCP and Mosquitto Add-on's video from Speak to the Geek . Although the video covers GivTCP v2 and v3 has been recently released, the installation and setup process are very similar. The below instructions assume you are installing GivTCP v3, with changes highlighted against GivTCP v2 as covered in the video. Install Mosquitto Broker add-on: Go to Settings / Add-ons / Add-on Store (bottom right) Scroll down the add-on store list, to find 'Mosquitto broker', click on the add-on, then click 'INSTALL' Once the Mosquitto broker has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on, and click 'START' to start the add-on Next, configure Mosquitto broker by going to Settings / Devices and Services / Integrations. Mosquitto broker should appear as a Discovered integration so click the blue 'CONFIGURE' button, then SUBMIT to complete configuring Mosquitto broker With GivTCP v3 you no longer need to create a dedicated Home Assistant user for MQTT so this part of the video can be skipped over Install the GivTCP add-on: Go to Settings / Add-ons / Add-on Store Click the three dots in the top right corner, then Repositories You'll need to add the GivTCP repository as an additional custom repository so paste/type ' https://github.com/britkat1980/ha-addons ' into the text box and click 'Add' the 'Close' NB: this URL is for GivTCP v3, not v2 as covered in the video. Click the back button and then re-navigate to Settings / Add-ons / Add-on Store so Home Assistant picks up the GivTCP add-on from the custom repository Scroll down the add-on store list, to find 'GivTCP-V3', you should see the three addons; the production version, the latest beta and the latest dev versions. Click on the 'GivTCP' add-on, then click 'INSTALL' Once GivTCP has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on Configure GivTCP: The configuration process for GivTCP in v3 has changed from that shown in the video, the Configuration tab is no longer used and all configuration is now done via the add-on's Web interface On the GivTCP add-on, click 'START' to start the add-on Once the add-on has started, click 'Open Web UI' or go to http://homeassistant.local:8099/ , then click 'Go to Config Page' to configure GivTCP GivTCP will auto-discover your inverters and batteries so you shouldn't need to manually enter these, but check the IP address(s) it finds are correct If you have a single AIO then for Predbat to be able to communicate via REST to the AIO, it MUST be the first device configured in GivTCP. Conversely if you have a gateway and multiple AIO's then the gateway MUST be the first device in GivTCP If you have multiple inverters you may wish to change the default device prefixes that GivTCP assigns ('givtcp', 'givtcp2', 'givtcp3', etc) to make it easier to identify your devices within Home Assistant. For example, if you have a gateway and two AIOs you could use the prefixes 'GW', 'AIO-1' and 'AIO-2'. The prefixes should be set before you start using GivTCP in anger as changing the prefixes later on will result in both the old and new sensor names appearing in Home Assistant with the 'old' sensors being \"unavailable\". Note that if you do change the givtcp prefixes then you will also have to edit the apps.yaml configuration file to match, and change the sensor names that Predbat is looking for (by default prefixed 'givtcp_xxx') to your new sensor naming structure Click Next and Next to get to the Selfrun page, and turn on Self Run. The Self Run Loop Timer is how often GivTCP will retrieve data from your inverters - it's recommended that set this to a value between 20 and 60, but not less than 15 seconds as otherwise the inverter will then spend all its time talking to GivTCP and won't communicate with the GivEnergy portal and app GivTCP now auto-populates the MQTT page so as long as you're using Mosquitto broker within Home Assistant; you won't need to create a dedicated MQTT user or enter the details on the MQTT page You don't need to configure the Influx page. Tariff and Palm pages can also be skipped as these functions are done by Predbat (Optional) On the Web page, you can turn the Dashboard on to see a simple power flow diagram for your inverters (similar to the GivEnergy mobile app) On the 'Misc' page check that 'Print Raw' is set to on for added monitoring Finally, click 'Save and Restart' and GivTCP should start communicating with your inverters and will automatically create a set of 'givtcp_xxx' entities in Home Assistant for your inverter data, inverter controls and battery data Check the GivTCP Log tab that there aren't any errors; it should end with 'Publishing Home Assistant Discovery messages' Before you start using GivTCP to control your inverter Verify in the GivEnergy portal settings the following inverter settings are set correctly as these are settings that Predbat doesn't control, and if not set correctly could affect your battery activity: \"Inverter Charge Power Percentage\" is set to 100 (Predbat has its own low-rate charge control you can use if you wish) \"Inverter Discharge Power Percentage\" is set to 100. If you do wish to set a lower discharge rate then its recommended that instead you set inverter_limit_discharge in apps.yaml to the rate \"Battery Cutoff % Limit\" is set to 4 \"Enable AC Charge Upper Limit' is enabled (if you have this option) That charge slot 2 (or more) are disabled (as Predbat only uses slot1) That discharge slot 2 (or more) are disabled (as Predbat only uses slot1) Specific Predbat configuration requirements for certain GivEnergy equipment The rest of the Predbat installation instructions should now be followed, but its worth highlighting that there are a few specific settings that should be set for certain GivEnergy equipment. These settings are documented in the appropriate place in the documentation, but for ease of identification, are repeated here: If you are using GivTCP v3 and have an AIO or 3-phase inverter then you will need to manually set geserial in apps.yaml to your inverter serial number as the auto-detect doesn't work for this setup If you have a single AIO then control is directly to the AIO. Ensure geserial in apps.yaml is correctly picking the AIO and comment out geserial2 lines If you have multiple AIOs then all control of the AIOs is done through the Gateway so geserial in apps.yaml should be set to the Gateway serial number If you have multiple AIOs you might want to consider setting inverter charge and discharge limits unless you want to charge and discharge at the full 12kWh! If you have a 2.6kWh, 5.2kWh or AIO battery then you will need to set battery_scaling in apps.yaml as the battery size is incorrectly reported to GivTCP If you have an older inverter (AC3 or Gen 1 hybrid) with firmware that has battery pause support you may need to comment out pause start and end time controls in apps.yaml If you have a Gen 2, Gen 3 or AIO then you may need to set inverter_reserve_max in apps.yaml to 98. If you have a Gen 1 or a firmware version that allows the reserve being set to 100 then you can change the default from 98 to 100 If your inverter has been wired as an EPS (Emergency Power Supply) or AIO 'whole home backup', consider setting input_number.predbat_set_reserve_min to reserve some battery power for use in emergencies. NB: GivTCP and Predbat do not currently yet work together for 3-phase inverters . This is being worked on by the author of GivTCP, e.g. see GivTCP issue: unable to charge or discharge 3 phase inverters with predbat","title":"GivEnergy with GivTCP"},{"location":"inverter-setup/#solis-inverters","text":"To run PredBat with Solis hybrid inverters, follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solisx_rtc Real Time Clock sensor.solisx_battery_power Battery Power Instead of apps.yaml use ginlong_solis.yaml from this Repo as your starting template. The majority of settings should be correct but please check. You will need to un-comment the template line to enable it. Save it to the appropriate Predbat software directory . Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Your inverter will require a \"button press\" triggered by Predbat to update the schedules. Some Solis inverter integrations feature a combined charge/discharge update button, in which case a single entry of: charge_discharge_update_button: - button.solis_charge_discharge is sufficient. For other configurations (for example using the \"solis_fb00\" plugin) where separate buttons are used for charging and discharging, provide both: charge_update_button: - button.solis_charge discharge_update_button: - button.solis_discharge Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration.","title":"Solis Inverters"},{"location":"inverter-setup/#solax-gen4-inverters","text":"Use the template configuration from: solax.sx4.yaml Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Please see this ticket in Github for ongoing discussion: https://github.com/springfall2008/batpred/issues/259","title":"Solax Gen4 Inverters"},{"location":"inverter-setup/#sofar-inverters","text":"For this integration, the key elements are: Hardware - sofar2mqtt EPS board - Relatively easy to solder and flash, or can be bought pre-made. Software - Sofar MQTT integration - MQTT integration Home Assistant configuration - sofar_inverter.yaml (in templates directory), defines the custom HA entities and should be added to HA's configuration.yaml . This is the default Sofar HA configuration with a couple of additional inputs to support battery capacity. Predbat configuration - sofar.yaml template for Predbat (in templates directory). This file should be copied to apps.yaml Please note that the inverter needs to be put into \"Passive Mode\" for the sofar2mqtt to control the inverter. This integration has various limitations, it can charge and discharge the battery but does not have finer control over reserve and target SOC% Note: You will need to change the min reserve in Home Assistant to match your minimum battery level ( input_number.predbat_set_reserve_min ). Please see this ticket in Github for ongoing discussions: https://github.com/springfall2008/batpred/issues/395","title":"Sofar Inverters"},{"location":"inverter-setup/#huawei-inverters","text":"The discussion ticket is here: https://github.com/springfall2008/batpred/issues/684 Please copy the template apps.yaml from https://github.com/springfall2008/batpred/blob/main/templates/huawei.yaml and modify them for your system Ensure you set input_number.predbat_set_reserve_min to the minimum value for your system which may be 12%","title":"Huawei Inverters"},{"location":"inverter-setup/#solaredge-inverters","text":"The discussion ticket is here: https://github.com/springfall2008/batpred/issues/181 Please copy the template apps.yaml from https://github.com/springfall2008/batpred/blob/main/templates/solaredge.yaml and modify them for your system The default entity name prefix for the integration is 'solaredge' but if you have changed this on installation then you will need to amend the apps.yaml template and the template sensors to match your new prefix Ensure that number.solaredge_i1_storage_command_timeout is set to a reasonably high value e.g. 3600 seconds to avoid the commands issued being cancelled Power Control Options, as well as Enable Battery Control, must be enabled in the Solaredge Modbus Multi integration configuration, and switch.solaredge_i1_advanced_power_control must be on. For pv_today , pv_power and load_power sensors to work you need to create these as a template within your Home Assistant configuration.yaml . Please see: https://gist.github.com/Ashpork/f80fb0d3cb22356a12ed24734065061c . These sensors are not critical so you can just comment it out in apps.yaml if you can't get it to work template: - sensor: - name: \"Solar Panel Production W\" unique_id: solar_panel_production_w unit_of_measurement: \"W\" icon: mdi:solar-power state: > {% set i1_dc_power = states('sensor.solaredge_i1_dc_power') | float(0) %} {% set b1_dc_power = states('sensor.solaredge_b1_dc_power') | float(0) %} {% if (i1_dc_power + b1_dc_power <= 0) %} 0 {% else %} {{ (i1_dc_power + b1_dc_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_dc_power') | is_number and states('sensor.solaredge_b1_dc_power') | is_number }} - name: \"Solar House Consumption W\" unique_id: solar_house_consumption_w unit_of_measurement: \"W\" icon: mdi:home state: > {% set i1_ac_power = states('sensor.solaredge_i1_ac_power') | float(0) %} {% set m1_ac_power = states('sensor.solaredge_m1_ac_power') | float(0) %} {% if (i1_ac_power - m1_ac_power <= 0) %} 0 {% else %} {{ (i1_ac_power - m1_ac_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_ac_power') | is_number and states('sensor.solaredge_m1_ac_power') | is_number }} sensor: - platform: integration source: sensor.solar_panel_production_w method: left unit_prefix: k name: solar_panel_production_kwh If you have multiple batteries connected to your SolarEdge inverter and are using the SolarEdge Modbus Multi integration, this enumerates the multiple batteries as b1, b2, b3, etc with separate entities per battery. You will need to make a number of changes to the solaredge apps.yaml, replacing the following entries: battery_rate_max: - sensor.calc_power_batteries_max_charge_power # maximum charge power of all the batteries battery_power: - sensor.calc_power_batteries_dc_power soc_percent: - sensor.calc_battery_all_state # average SoC of the batteries soc_max: - sensor.calc_battery_total_capacity # combined kWh maximum value of all the batteries soc_kw: - sensor.calc_battery_current_capacity set charge_rate and discharge_rate to the SolarEdge inverter values, e.g. 5000 And add the following additional template sensors to configuration.yaml: - sensor: # Template sensor for Max Battery Charge rate # This is the sum of all three batteries charge rate as the max charge rate can be higher than inverter capacity (e.g. 8k) when charging from AC+Solar # Returns 5000W as the minimum max value, the single battery charge/discharge limit to ensure at least one battery can always be charged if one or more batteries have 'gone offline' to modbus - name: \"Calc Power - Batteries Max Charge Power\" unique_id: calc_power_batteries_max_charge_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_max_charge_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_max_charge_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_max_charge_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) | int %} {{ (myValue if (myValue) > 5000 else 5000) }} # Calculate Total Battery Power Value - name: \"Calc Power - Batteries DC Power\" unique_id: calc_power_batteries_dc_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_dc_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_dc_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_dc_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Average state of charge across the batteries - name: \"Calc Battery All State\" unique_id: calc_battery_all_state unit_of_measurement: \"%\" state: > {% set myB1 = float(states('sensor.solaredge_b1_state_of_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_state_of_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_state_of_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3) / 3) | round(0) %} {{ myValue }} # Total Energy Stored in the Batteries - name: \"Calc Battery Total Capacity\" unique_id: calc_battery_total_capacity unit_of_measurement: kWh state: > {% set myB1 = float(states('sensor.solaredge_b1_maximum_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_maximum_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_maximum_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Current Energy Stored in the Batteries - name: \"Calc Battery Current Capacity\" unique_id: calc_battery_current_capacity unit_of_measurement: kWh state: > {% set myValue = (float(states('sensor.calc_battery_all_state'),0) / 100) * float(states('sensor.calc_battery_total_capacity'),0) %} {{ myValue }}","title":"SolarEdge Inverters"},{"location":"inverter-setup/#givenergy-with-ge_cloud","text":"This is an experimental system, please discuss it on the ticket: https://github.com/springfall2008/batpred/issues/905 First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_cloud.yaml from templates into your apps.yaml and edit Set geserial to your inverter serial number Make sure that the 'discharge down to' registers are set to 4% and slots 2, 3 and 4 for charge and discharge are disabled in the portal (if you have them)","title":"GivEnergy with ge_cloud"},{"location":"inverter-setup/#givenergy-with-ems","text":"First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_ems.yaml from templates into your apps.yaml and edit Set geserial to your first inverter serial and geserial2 to the second (look in HA for entity names) Set geseriale to the EMS inverter serial number (look in HA for the entity names) Turn off charge, export and discharge slots 2, 3 and 4 as Predbat will only use slot 1 - set the start and end times for these to 00:00","title":"GivEnergy with EMS"},{"location":"inverter-setup/#givenergyoctopus-cloud-direct-no-home-assistant","text":"Take the template and enter your GivEnergy API key directly into apps.yaml Set your Octopus API key in apps.yaml Set your Solcast API key in apps.yaml Review any other configuration settings Launch Predbat with hass.py (from the Predbat-addon repository) either via a Docker or just on a Linux/MAC/WSL command line shell.","title":"GivEnergy/Octopus Cloud Direct - No Home Assistant"},{"location":"inverter-setup/#fox","text":"Experimental I've managed to get Batpred working on my Fox ESS inverter, connected via an Elfin EW11 modbus and using Nathan's Fox ESS Modbus tool. See: https://github.com/springfall2008/batpred/issues/1401 The template is in the templates area, give it a try","title":"Fox"},{"location":"inverter-setup/#lux-power","text":"This requires the LuxPython component which integrates with your Lux Power inverter Copy the template luxpower.yaml from templates into your apps.yaml and edit inverter and battery settings as required LuxPower does not have a SoC max entity in kWh and the SoC percentage entity never reports the battery reaching 100%, so create the following template helper sensors: name: Lux SoC Max kWh template: {{ (states(\"sensor.lux_battery_capacity_ah\") |float) * (states(\"sensor.lux_battery_voltage_live\") | float) / 1000}} unit of measurement: kWh device class: Energy state class: Total name: Lux Battery SoC Corrected template: {% set soc = states('sensor.lux_battery')|int %} {% set charging_stopped = states('sensor.lux_bms_limit_charge_live')|float == 0 %} {% if charging_stopped and soc > 97 %} 100 {% else %} {{ soc }} {% endif %} unit of measurement: % device class: Battery state class: Measurement","title":"Lux Power"},{"location":"inverter-setup/#growatt-with-solar-assistant","text":"You need to have a Solar Assistant installation https://solar-assistant.io Growatt has two popular series of inverters, SPA and SPH. Copy the template that matches your model from templates into your apps.yaml and edit inverter and battery settings as required. Yours may have different entity IDs on Home Assistant.","title":"Growatt with Solar Assistant"},{"location":"inverter-setup/#sunsynk","text":"Copy the Sunsynk apps.yaml template and edit for your system. Create the following Home Assistant automations: alias: Predbat Charge / Discharge Control description: \"Turn SunSynk charge/discharge on/off to mirror Predbat\" trigger: - platform: state entity_id: - binary_sensor.predbat_charging to: \"on\" id: predbat_charge_on - platform: state entity_id: - binary_sensor.predbat_charging to: \"off\" id: predbat_charge_off - platform: state entity_id: - binary_sensor.predbat_exporting to: \"on\" id: predbat_discharge_on - platform: state entity_id: - binary_sensor.predbat_exporting to: \"off\" id: predbat_discharge_off condition: [] action: - choose: - conditions: - condition: trigger id: - predbat_charge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_grid_charge_timezone1 - conditions: - condition: trigger id: - predbat_charge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_grid_charge_timezone1 data: {} - conditions: - condition: trigger id: - predbat_discharge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_solar_sell - conditions: - condition: trigger id: - predbat_discharge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_solar_sell data: {} mode: single alias: PredBat - Copy Charge Limit description: Copy Battery SOC to all timezone (time) slots trigger: - platform: state entity_id: - number.sunsynk_set_soc_timezone1 to: null condition: [] action: - service: number.set_value data_template: entity_id: - number.sunsynk_set_soc_timezone2 - number.sunsynk_set_soc_timezone3 - number.sunsynk_set_soc_timezone4 - number.sunsynk_set_soc_timezone5 - number.sunsynk_set_soc_timezone6 value: \"{{ states('number.sunsynk_set_soc_timezone1')|int(20) }}\" mode: single Create the following templates sensors in your configuration.yaml: template: sensor: - name: \"sunsynk_max_battery_charge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_charge_current_limit')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_max_battery_discharge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_discharge_current_limit')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_charge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_charge_current')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_discharge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_discharge_current')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }}","title":"Sunsynk"},{"location":"inverter-setup/#sigenergy-sigenstor","text":"To integrate your Sigenergy Sigenstor inverter with Predbat, you will need to follow the steps below: make sure the inverter is already integrated into Home Assistant. Here is a ( repo ) with full integration (this is the Python version of the Sigenergy Home Assistant integration). Copy the template sigenergy_sigenstor.yaml template over your apps.yaml and edit for your system. The following additions are needed to facilitate integration with Predbat and need to put put in Home Assistant configuration.yaml or a package yaml: input_select: predbat_requested_mode: name: \"Predbat Requested Mode\" options: - \"Demand\" - \"Charging\" - \"Freeze Charging\" - \"Discharging\" - \"Freeze Discharging\" initial: \"Demand\" icon: mdi:battery-unknown automation: - id: predbat_requested_mode_action alias: \"Predbat Requested Mode Action\" description: \"Acts as a mapper for the input_select.predbat_requested_mode to the select.sigen_plant_remote_ems_control_mode\" mode: single triggers: - trigger: state entity_id: - input_select.predbat_requested_mode conditions: [] actions: - action: select.select_option metadata: {} target: entity_id: select.sigen_plant_remote_ems_control_mode data: option: > {% if is_state('input_select.predbat_requested_mode', \"Demand\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Discharging\") %}Command Discharging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Discharging\") %}Command Discharging (ESS First) {% endif %} - choose: # Set charging limit to 0 when requested mode is Freeze Charging - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_charging_limit value: 0 # Set discharging limit to 0 when requested mode is Freeze Discharging - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_discharging_limit value: 0 # If neither of the above conditions are met, set the limits to the input numbers - conditions: - condition: not conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_charging_limit value: \"{{ [(states('input_number.charge_rate') | float / 1000) | round(2), states('sensor.sigen_inverter_ess_rated_charge_power') | float] | min}}\" - service: number.set_value data_template: entity_id: number.sigen_plant_ess_max_discharging_limit value: \"{{ [(states('input_number.discharge_rate') | float / 1000) | round(2), states('sensor.sigen_inverter_ess_rated_discharge_power') | float] | min}}\" - id: \"automation_sigen_ess_max_charging_limit_input_number_action\" alias: \"Predbat max charging limit action\" description: \"Mapper from input_number.charge_rate to number.sigen_plant_ess_max_charging_limit\" triggers: - trigger: state entity_id: input_number.charge_rate action: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_charging_limit data: value: \"{{ (states('input_number.charge_rate')| float / 1000) | round(2) }}\" mode: single - id: \"automation_sigen_ess_max_discharging_limit_input_number_action\" alias: \"Predbat max discharging limit action\" description: \"Mapper from input_number.discharge_rate to number.sigen_plant_ess_max_discharging_limit\" triggers: - trigger: state entity_id: input_number.discharge_rate action: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_discharging_limit data: value: \"{{ (states('input_number.discharge_rate')| float / 1000) | round(2) | int }}\" mode: single input_number: charge_rate: name: Battery charge rate initial: 6950 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W discharge_rate: name: Battery discharge rate initial: 8000 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W","title":"Sigenergy Sigenstor"},{"location":"inverter-setup/#i-want-to-add-an-unsupported-inverter-to-predbat","text":"First copy one of the template configurations that is close to your system and try to configure it to match the sensors you have Create a GitHub ticket for support and add what you know to the ticket Then find out how to control your inverter inside Home Assistant, ideally share any automation you have to control the inverter You can create a new inverter type in apps.yaml and change the options as to which controls it has Set inverter_type in apps.yaml to match the custom inverter definition ('MINE' in the example below) The easy way to integrate using Home Assistant services to start charges and discharges, edit the template below: inverter_type: MINE inverter: name: \"My Shiny new Inverter\" has_rest_api: False has_mqtt_api: False output_charge_control: \"power\" has_charge_enable_time: False has_discharge_enable_time: False has_target_soc: False has_reserve_soc: False charge_time_format: \"S\" charge_time_entity_is_option: False soc_units: \"%\" num_load_entities: 1 has_ge_inverter_mode\": False time_button_press: False clock_time_format: \"%Y-%m-%d %H:%M:%S\" write_and_poll_sleep: 2 has_time_window: False support_charge_freeze: False support_discharge_freeze\": False # Services to control charging/discharging charge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power and Grid\" charge_stop_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power\" discharge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Maximize Self Consumption\"","title":"I want to add an unsupported inverter to Predbat"},{"location":"inverter-setup/#inverter-control-option","text":"The following options are supported per inverter:","title":"Inverter control option"},{"location":"inverter-setup/#has_rest_api","text":"When True the REST API will be used to fetch data/control the inverter. This is currently only for GivEnergy inverters with GivTCP and givtcp_rest must be set in apps.yaml","title":"has_rest_api"},{"location":"inverter-setup/#has_mqtt_api","text":"When True the MQTT API to Home Assistant will be used to issue control messages for the inverter The MQTT/publish service is used with the topic as defined by mqtt_topic in apps.yaml Messages will be sent through these controls: Values that are updated: topic /set/reserve - payload=reserve topic /set/charge_rate - payload=new_rate topic /set/discharge_rate - payload=new_rate topic /set/target_soc - payload=target_soc These three change between battery charge/discharge and auto (idle) mode: topic /set/charge - payload=charge_rate topic /set/discharge - payload=discharge_rate topic /set/auto - payload=true","title":"has_mqtt_api"},{"location":"inverter-setup/#service-api","text":"When True a Home Assistant service will be used to issue control messages for the inverter For each service you wish to use it must be defined in apps.yaml. There are two ways to define a service, the basic mode: charge_start_service: my_service_name_charge Will call my_service_name_charge for the charge start service. Or the custom method: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" charge_start_time: \"{charge_start_time}\" charge_end_time: \"{charge_end_time}\" Here you can define all the values passed to the service and use the default values from the template or define your own. You can also call more than one service e.g: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" - service: switch.turn_off entity_id: switch.tsunami_charger Note: By default the service will only be called once until things change, e.g. charge_start_service will be called once and then won't be called again until charge_stop_service stops the charge. If however, you want the service to be called on each Predbat run then you should set repeat to True for the given service e.g: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" repeat: True","title":"Service API"},{"location":"inverter-setup/#charge_start_service","text":"Called to start a charge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SOC to charge to power - The charge power to use charge_start_time - Start time for the charge charge_end_time - End time for the charge","title":"charge_start_service"},{"location":"inverter-setup/#charge_freeze_service","text":"If defined will be called for freeze charge, otherwise, charge_start_service is used for freeze charge also.","title":"charge_freeze_service"},{"location":"inverter-setup/#discharge_start_service","text":"Called to start a discharge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SOC to discharge to power - The discharge power to use","title":"discharge_start_service"},{"location":"inverter-setup/#discharge_freeze_service","text":"If defined will be called for Discharge freeze, otherwise, discharge_start_service is used for freeze discharge also.","title":"discharge_freeze_service"},{"location":"inverter-setup/#charge_stop_service","text":"Called to stop a charge device_id - as defined in apps.yaml by device_id","title":"charge_stop_service"},{"location":"inverter-setup/#discharge_stop_service","text":"Called to stop a discharge, if not set then charge_stop_service will be used instead device_id - as defined in apps.yaml by device_id","title":"discharge_stop_service"},{"location":"inverter-setup/#output_charge_control","text":"Set to power, current or none When power the inverter has a charge_rate and discharge_rate setting in watts defined in apps.yaml When current the inverter has timed_charge_current and timed_discharge_current setting in amps defined in apps.yaml","title":"output_charge_control"},{"location":"inverter-setup/#charge_control_immediate","text":"When True the inverter timed_charge_current or timed_discharge_current is used to control charging or discharging as/when it starts and stops rather than using a timed method.","title":"charge_control_immediate"},{"location":"inverter-setup/#current_dp","text":"Sets the number of decimal places when setting the current in Amps, which should be 0 or 1","title":"current_dp"},{"location":"inverter-setup/#has_charge_enable_time","text":"When True the inverter has a setting defined in apps.yaml called scheduled_charge_enable when can be used to enable/disable timed charging.","title":"has_charge_enable_time"},{"location":"inverter-setup/#has_discharge_enable_time","text":"When True the inverter has a setting defined in apps.yaml called scheduled_discharge_enable when can be used to enable/disable timed discharging.","title":"has_discharge_enable_time"},{"location":"inverter-setup/#has_target_soc","text":"When True the inverter has a target charge SoC setting in apps.yaml called charge_limit . When False charging must be turned on and off by Predbat rather than the inverter doing it based on the target SoC %.","title":"has_target_soc"},{"location":"inverter-setup/#has_reserve_soc","text":"When True the inverter has a discharge reserve SoC setting in apps.yaml called reserve which is the target % to discharge the battery down to. When False discharging must be turned on and off by Predbat rather than the inverter doing it based on discharge Soc %.","title":"has_reserve_soc"},{"location":"inverter-setup/#has_timed_pause","text":"When True the inverter has a setting in apps.yaml called pause_mode and settings pause_start_time and pause_end_time which can be used to pause the inverter from charging and discharging the battery - this is for GivEnergy systems only right now.","title":"has_timed_pause"},{"location":"inverter-setup/#charge_time_format","text":"When set to \"HH:MM:SS\" the inverter has: charge_start_time charge_end_time discharge_start_time discharge_end_time Which are option selectors in the format HH:MM:SS (e.g. 12:23:00) where seconds are always 00. When set to \"H M\" the inverter has: charge_start_hour charge_end_hour charge_start_minute charge_end_minute discharge_start_hour discharge_end_hour discharge_start_minute discharge_end_minute Settings in apps.yaml which can be used to set the start and end times of charges and discharges","title":"charge_time_format"},{"location":"inverter-setup/#charge_time_entity_is_option","text":"When True charge_start_time charge_end_time discharge_start_time and discharge_end_time are all Options, when false they are number values.","title":"charge_time_entity_is_option"},{"location":"inverter-setup/#clock_time_format","text":"Defines the time format of the inverter clock setting inverter_time in apps.yaml","title":"clock_time_format"},{"location":"inverter-setup/#soc_units","text":"Defines the units of the SOC setting (currently not used)","title":"soc_units"},{"location":"inverter-setup/#time_button_press","text":"When true the inverter has a button press which is needed to update the inverter registers from the Home Assistant values. The apps.yaml setting charge_discharge_update_button is the entity name of the button that must be pressed and polled until it updates after each inverter register change.","title":"time_button_press"},{"location":"inverter-setup/#support_charge_freeze","text":"When True the inverter supports charge freeze modes","title":"support_charge_freeze"},{"location":"inverter-setup/#support_discharge_freeze","text":"When True the inverter supports discharge freeze modes","title":"support_discharge_freeze"},{"location":"inverter-setup/#has_ge_inverter_mode","text":"When True the inverter as the GivEnergy inverter modes (ECO, Timed Export etc).","title":"has_ge_inverter_mode"},{"location":"inverter-setup/#num_load_entities","text":"Sets the number of load_power_n settings in apps.yaml are present in addition to load_power (the default)","title":"num_load_entities"},{"location":"inverter-setup/#write_and_poll_sleep","text":"Sets the number of seconds between polls of inverter settings","title":"write_and_poll_sleep"},{"location":"inverter-setup/#has_idle_time","text":"When True the inverter has an idle time register which must be set to the start and end times for ECO mode (GivEnergy EMS)","title":"has_idle_time"},{"location":"inverter-setup/#can_span_midnight","text":"When True start and end times for charge and discharge can span midnight e.g. 23:00:00 - 01:00:00 is a 2-hour slot.","title":"can_span_midnight"},{"location":"inverter-setup/#charge_discharge_with_rate","text":"When True when charging discharge rate must be 0 and visa-versa. When false the rate does not have to change.","title":"charge_discharge_with_rate"},{"location":"manual-api/","text":"Predbat automation API CAUTION This is an expert feature only, you can break Predbat if you set the wrong things here. While for most people Predbat will do what you want without any adjustments there are some special cases where users wish to write some more complex automations which override Predbat settings For settings inside Home Assistant e.g. switch.predbat_ , select.predbat_ and input_number.predbat_* you can already use an automation to change these values For settings in apps.yaml it's very difficult or impossible to update them via an automation. For this reason, there is a selector called select.predbat_manual_api which works a bit like the manual override ones but this can have new values added using the select API in Home Assistant. The only function the selector itself serves is to store override commands, you can clear from the selector but you have to set them using a service call. Certain settings from apps.yaml may be overridden using this method. Each override is in a string format and works a bit like a web URL, setting the command and the values. Data retention The data for overrides is kept inside the Home Assistant selector itself and so will survive a reboot. There is likely a limit to the size of this data so be sure to remove old overrides when you are done with them. Keep in mind it's easy to lose all of the overrides with the 'off' option so do not keep important data here only use it for short-term automations. Supported command formats The supported formats are: off <command>=<value> <command>(index)=<value> <command>?<name>=<value> <command>(index)?<name>=<value> <command>?<name>=<value>&<name2>=<value2> <command>(index)?<name>=<value>&<name2>=<value2> Commands are disabled again by putting them in square brackets e.g: [<command>?<name>=<value>&<name2>=<value2>] ```` Below is an example of setting a rate override, you can clear all overrides by calling 'off' or this specific one only by calling the same thing again but in square brackets [] For the rates you can use **rates_export_override** or **rates_import_override** with all the same options as [apps.yaml](energy-rates.md#manually-over-riding-energy-rates) but in a URL type format: ```text rates_export_override?start=17:00:00&end=19:00:00&rate=0 See below for an [example of using the API to over-ride predicted house load] If you override a single value item in a list with something like: inverter_limit(0)=4000 To disable this override again: [inverter_limit(0)=4000] If you omit the index then all entries in the list will be overridden. To disable all overrides off Supported overrides The following settings can be overridden with this method: rates_export_override rates_import_override inverter_limit export_limit days_previous days_previous_weight inverter_battery_rate_min inverter_reserve_max battery_rate_max car_charging_soc car_charging_limit car_charging_battery_size battery_scaling forecast_hours import_export_scaling inverter_limit_charge inverter_limit_discharge Example solution to over-ride predicted house load One common feedback is there is no mechanism in Predbat to alter the predicted house load, for example ignoring the effects of extra washing load in the past, or to take account of planned extra load such as cooking a big Sunday dinner. The Predbat manual API provides a mechanism to meet this need by setting an export (or import) rates override. Control variables Create a date/time helper called predbat_override_date of type date, another called predbat_override_start_time of type time, and a third called predbat_override_end_time also of type time. Create an input number helper called predbat_override_load_percent. I made it an input field and with a maximum value of 5. These will hold the date, start time, end time and load adjustment percentage. Create an automation script to send the event details to Predbat: alias: Send Load Adjustment details to Predbat manual API sequence: - action: select.select_option data: option: >- rates_export_override?date={{ states('input_datetime.predbat_override_date')| as_timestamp | timestamp_custom('%Y-%m-%d') }}&start={{ states('input_datetime.predbat_override_start_time') }}&end={{ states('input_datetime.predbat_override_end_time') }}&load_scaling={{ states('input_number.predbat_override_load_percent')|float }} target: entity_id: select.predbat_manual_api mode: single description: \"\" The script collects the above input variables, and sends these to Predbat as an export rate override. Dashboard: On an existing Home Assistant dashboard, or on a new one, create a control of type 'entities' and paste the following in: type: entities entities: - entity: input_datetime.predbat_override_session_date - entity: input_datetime.predbat_override_start_time - entity: input_datetime.predbat_override_end_time - entity: input_number.predbat_override_load_percent - type: button name: Send Load Adjustment details to Predbat icon: mdi:script-text-play-outline action_name: Execute tap_action: action: perform-action perform_action: script.send_load_adjustment_details_to_predbat_manual_api You simply enter the date, start time, end time and load percentage adjustment (e.g. 0.5=50%), then click the 'Execute' button. The load adjustment details will be sent to the Predbat manual API and you will see the load change and a small +/- symbol against the export rate in the Predbat plan.","title":"Predbat automation API"},{"location":"manual-api/#predbat-automation-api","text":"CAUTION This is an expert feature only, you can break Predbat if you set the wrong things here. While for most people Predbat will do what you want without any adjustments there are some special cases where users wish to write some more complex automations which override Predbat settings For settings inside Home Assistant e.g. switch.predbat_ , select.predbat_ and input_number.predbat_* you can already use an automation to change these values For settings in apps.yaml it's very difficult or impossible to update them via an automation. For this reason, there is a selector called select.predbat_manual_api which works a bit like the manual override ones but this can have new values added using the select API in Home Assistant. The only function the selector itself serves is to store override commands, you can clear from the selector but you have to set them using a service call. Certain settings from apps.yaml may be overridden using this method. Each override is in a string format and works a bit like a web URL, setting the command and the values.","title":"Predbat automation API"},{"location":"manual-api/#data-retention","text":"The data for overrides is kept inside the Home Assistant selector itself and so will survive a reboot. There is likely a limit to the size of this data so be sure to remove old overrides when you are done with them. Keep in mind it's easy to lose all of the overrides with the 'off' option so do not keep important data here only use it for short-term automations.","title":"Data retention"},{"location":"manual-api/#supported-command-formats","text":"The supported formats are: off <command>=<value> <command>(index)=<value> <command>?<name>=<value> <command>(index)?<name>=<value> <command>?<name>=<value>&<name2>=<value2> <command>(index)?<name>=<value>&<name2>=<value2> Commands are disabled again by putting them in square brackets e.g: [<command>?<name>=<value>&<name2>=<value2>] ```` Below is an example of setting a rate override, you can clear all overrides by calling 'off' or this specific one only by calling the same thing again but in square brackets [] For the rates you can use **rates_export_override** or **rates_import_override** with all the same options as [apps.yaml](energy-rates.md#manually-over-riding-energy-rates) but in a URL type format: ```text rates_export_override?start=17:00:00&end=19:00:00&rate=0 See below for an [example of using the API to over-ride predicted house load] If you override a single value item in a list with something like: inverter_limit(0)=4000 To disable this override again: [inverter_limit(0)=4000] If you omit the index then all entries in the list will be overridden. To disable all overrides off","title":"Supported command formats"},{"location":"manual-api/#supported-overrides","text":"The following settings can be overridden with this method: rates_export_override rates_import_override inverter_limit export_limit days_previous days_previous_weight inverter_battery_rate_min inverter_reserve_max battery_rate_max car_charging_soc car_charging_limit car_charging_battery_size battery_scaling forecast_hours import_export_scaling inverter_limit_charge inverter_limit_discharge","title":"Supported overrides"},{"location":"manual-api/#example-solution-to-over-ride-predicted-house-load","text":"One common feedback is there is no mechanism in Predbat to alter the predicted house load, for example ignoring the effects of extra washing load in the past, or to take account of planned extra load such as cooking a big Sunday dinner. The Predbat manual API provides a mechanism to meet this need by setting an export (or import) rates override. Control variables Create a date/time helper called predbat_override_date of type date, another called predbat_override_start_time of type time, and a third called predbat_override_end_time also of type time. Create an input number helper called predbat_override_load_percent. I made it an input field and with a maximum value of 5. These will hold the date, start time, end time and load adjustment percentage. Create an automation script to send the event details to Predbat: alias: Send Load Adjustment details to Predbat manual API sequence: - action: select.select_option data: option: >- rates_export_override?date={{ states('input_datetime.predbat_override_date')| as_timestamp | timestamp_custom('%Y-%m-%d') }}&start={{ states('input_datetime.predbat_override_start_time') }}&end={{ states('input_datetime.predbat_override_end_time') }}&load_scaling={{ states('input_number.predbat_override_load_percent')|float }} target: entity_id: select.predbat_manual_api mode: single description: \"\" The script collects the above input variables, and sends these to Predbat as an export rate override. Dashboard: On an existing Home Assistant dashboard, or on a new one, create a control of type 'entities' and paste the following in: type: entities entities: - entity: input_datetime.predbat_override_session_date - entity: input_datetime.predbat_override_start_time - entity: input_datetime.predbat_override_end_time - entity: input_number.predbat_override_load_percent - type: button name: Send Load Adjustment details to Predbat icon: mdi:script-text-play-outline action_name: Execute tap_action: action: perform-action perform_action: script.send_load_adjustment_details_to_predbat_manual_api You simply enter the date, start time, end time and load percentage adjustment (e.g. 0.5=50%), then click the 'Execute' button. The load adjustment details will be sent to the Predbat manual API and you will see the load change and a small +/- symbol against the export rate in the Predbat plan.","title":"Example solution to over-ride predicted house load"},{"location":"output-data/","text":"Output data Each time Predbat runs it outputs a lot of information about the current performance of your solar/battery system and the predicted load, PV, cost, CO2, car charging, etc. This section of the documentation explains the different output and logging data that Predbat produces and gives an overview of how to display that information within Home Assistant. There can never be a single Predbat dashboard that suits every user, so instead Predbat gives a starter set of displays that can be adapted to your individual needs. Web interface The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles. Displaying output data Each Predbat configuration item is named input_number.predbat_xxx , switch.predbat_yyy or select.predbat_zzz depending on the control type. Creating a simple Predbat dashboard Each time Predbat runs it auto-generates a dashboard with the filename predbat_dashboard.yaml that can be used as a starter for your own Predbat dashboard. Depending on how you installed Predbat this predbat_dashboard.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat add-on installation method , it will be in the directory /addon_configs/6adb4f0d_predbat/ , if the combined AppDaemon/Predbat add-on installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/ , or with the HACS, Appdaemon add-on then Predbat installation method , it's /config/appdaemon/apps/batpred/config/ . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to open the predbat_dashboard.yaml file - see editing configuration files within Home Assistant if you need to install an editor. Once opened, select and copy all the contents of the predbat_dashboard.yaml file and add the contents to a new dashboard page: Go to System/Dashboards, click 'Open' against an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then click 'Open' Click the pencil icon in the top right corner, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and paste the contents of the predbat_dashboard.yaml file copied earlier, then 'Save'. This will give you a simple Predbat control and output dashboard that you can then resequence and customise as you wish. Creating a compact Predbat control dashboard You can also create a dashboard page that's dynamically generated to automatically include all the Predbat control and output entities, so when new entities are added in future Predbat releases, you don't have to edit the dashboard. Firstly you need to install HACS if it isn't already installed, and then install two HACS front-end components: Auto Entities ( https://github.com/thomasloven/lovelace-auto-entities ) automatically generates a list of entities that match a wildcard expression Lovelace Collapsable Cards ( https://github.com/RossMcMillan92/lovelace-collapsable-cards ) wraps the entity lists within a drop-down toggle Installation steps: Click the HACS icon on the left-hand side panel Click 'Frontend' Click the three dots in the top right corner then 'Custom Repositories' Paste (or type) in the following repository name https://github.com/RossMcMillan92/lovelace-collapsable-cards , choose Type 'Dashboard', and click Add Close the Custom Repositories dialogue Click 'Explore & Download Repositories' Search for 'collapsable cards', click the name of it, check it's the right one, click 'Download', 'Download' again, then 'Reload' Click 'Explore & Download Repositories' again, search for 'auto-entities', then 'Download', 'Download', 'Reload' Now create the dynamic dashboard: Go to Settings/Dashboards, click 'Open' against an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then click 'Open' Click the pencil icon in the top right corner, then the plus symbol on the far right of the next row to create a new View Enter a title of the View, then Save Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following YAML into the dashboard and click 'Save': type: vertical-stack title: Predbat \ud83e\udd87 cards: - type: entities entities: - entity: predbat.status - type: weblink name: Predbat Web Console url: /hassio/ingress/6adb4f0d_predbat - entity: update.predbat_version - entity: select.predbat_update - entity: select.predbat_mode - entity: select.predbat_saverestore - entity: switch.predbat_active - type: custom:collapsable-cards title: \ud83d\udd00 Control defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udd22 Input Variables defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: input_number.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd00 Switches defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: switch.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd22 Selectors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: select.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: '#\ufe0f\u20e3 Sensors' defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udcb7 Cost Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*cost* - entity_id: predbat.*rate* - entity_id: predbat.*metric* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udcb7 Saving Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*saving* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd5b Time/Duration Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \u26a1 Power Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*soc* - entity_id: predbat.*energy* - entity_id: predbat.*load* - entity_id: predbat.*battery* - entity_id: predbat.*kw* - entity_id: predbat.*power* - entity_id: predbat.*charge* - entity_id: predbat.*iboost* - entity_id: predbat.*grid* - entity_id: sensor.predbat_pv* exclude: - entity_id: predbat.*savings* - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: 1\ufe0f\u20e3 Binary Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: binary_sensor.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false This will give you a compact dynamically created list of all Predbat entities which groups the entities by type and is collapsed by default to prevent screen clutter. Credit @DJBenson for the code. Viewing the Predbat plan predbat.plan_html - A sensor that contains an HTML render of the Predbat predicted best plan, detailing import and export rates, predicted house load, solar generation, any solar clipping, battery SoC, car and iBoost charging, and Predbat's planned charging and discharging activities. The plan is contained in the 'html' attribute, and its recommended to Create the Predbat Plan card as an easy way to see the plan that Predbat has created. The sensor also contains the 'text' attribute which gives a HTML formatted brief text description of the Predbat plan. If you are using the Predbat add-on or docker then the Predbat plan can also be viewed via the 'Plan' view of the Predbat web interface , and the text description via the 'Dash' view . Graphing the Predbat predictions A set of Apex Charts can also be created to see graphically what Predbat plans to do - Creating the charts . Renditions of the key charts can also be seen in the 'Charts' view of the Predbat web interface . Basic status switch.predbat_active - Automatically set by Predbat to On when Predbat is busy calculating or controlling your inverter, or Off when Predbat is waiting for the next time it needs to perform a plan calculation update. If you toggle this switch in Home Assistant it will force Predbat to perform an update now (useful for automations). predbat.status - Gives the current status & errors and logs any changes that Predbat makes to your inverter. The different Predbat status values and their meanings are detailed in what does Predbat do . predbat.status additionally has the following attributes that are automatically populated: Last updated - date and time that Predbat last updated the plan Debug - A set of arrays containing Predbat's planned charging and discharging time windows and battery limits (in kWh) Version - version of Predbat that's running Error - binary value true or false depending upon whether Predbat is in an error status or nor Baseline data Predbat outputs the following sensors to predict what your battery is expected to do over the forecast_hours duration of the plan with no changes made by Predbat. This is considered to be the 'baseline' plan: NB: All of Predbat's forecasts are from midnight today to the forecast_hours duration (set in apps.yaml) into the future and shouldn't be confused with 'today' figures. e.g. predbat.pv_energy is the actual PV energy from midnight today, and for the predicted forecast_hours (typically 48) ahead so will be much larger than sensor.solcast_pv_forecast_today which is today's Solcast PV forecast. predbat.battery_cycle - Predicted baseline battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_hours_left - The number of hours left until your home battery is predicted to run out under the baseline plan (stops at the maximum prediction time) predbat.battery_power - The sensor is always zero; attributes contain the predicted remaining battery power under the baseline plan, in 5-minute slots, for charting predbat.car_soc - The expected charge level of your car at the end of the baseline plan. Can also be charted predbat.charge_end - Predicted end time of the next forced battery charging under the baseline plan predbat.charge_limit - Predicted baseline battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.charge_limit_kw - Predicted baseline battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.charge_start - Predicted start time of the next forced battery charging under the baseline plan predbat.duration - The duration of the prediction maximum in hours predbat.export_energy - Total kWh of predicted exports under the baseline plan with attributes of the predicted export kWh and their time slots predbat.grid_power - The sensor is always zero; attributes contain the predicted Grid power (positive or negative for import or export) in kW per 5-minute slots to the end of the baseline plan for charting predbat.import_energy - Total kWh of predicted imports under baseline plan with attributes of the predicted import kWh and their time slots predbat.import_energy_battery - Total kWh of predicted import energy used to charge the home battery under the baseline plan predbat.import_energy_house - Predicted import energy used by the home under the baseline plan that is not provided by your home battery (e.g. due to a flat battery or load above the maximum discharge rate) predbat.load_energy - Total kWh of predicted house load under the baseline plan with attributes of the predicted load kWh in 5-minute slots to the end of the plan predbat.load_power - Total kW of predicted house load power to the end of the baseline plan, with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.metric - Total predicted cost for the baseline plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.pv_energy - Predicted PV energy in kWh under the baseline plan with attributes of the predicted PV generation in kWh with time slots predbat.pv_power - Predicted PV power now with attributes that contain the predicted PV power in kW per 5-minute slots to the end of the baseline plan for charting predbat.soc_kw - Predicted state of charge (in kWh) at the end of the baseline plan prediction, not very useful in itself, but the attributes hold prediction data in 5-minute intervals which can be charted with Apex Charts (or similar) predbat.soc_min_kwh - Predicted lowest battery SoC value in kWh under the baseline plan with attribute of the date/time that that lowest SoC occurs at PV 10% Baseline data Predbat outputs the following baseline results under the PV 10% scenario for the forecast_hours duration of the plan, these are known as the 'base10' predictions: predbat.base10_export_energy- Total predicted export energy in kWh for the PV 10% scenario, with attributes of the predicted export kWh and their time slots predbat.base10_import_energy- Total predicted import energy in kWh for the PV 10% scenario, with attributes of the predicted import kWh and their time slots predbat.base10_load_energy - Total predicted house load in kWh for the PV 10% scenario predbat.base10_metric - Total predicted cost for the PV 10% scenario, with attributes of the cost prediction in 5-minute slots to the end of the plan for charting predbat.base10_pv_energy - Predicted PV 10% energy in kWh with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw_base10 - Predicted final state of charge (in kWh) of the battery, with attributes of the predicted SoC in 5-minute time slots to the end of the plan under the PV 10% scenario, for charting Best Prediction data Predbat outputs the following 'best' entities from the forecast (for the forecast_hours duration) based on the lowest cost consumption plan. The 'best' plan in Predbat parlance is simply Predbat's lowest cost predicted plan: predbat.battery_cycle_best - Predicted best battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_power_best - Predicted remaining battery power in kW with attributes of the future prediction in 5-minute slots predbat.best_battery_hours_left - Predicted total number of hours of battery capacity left under the best plan predbat.best_charge_end - Predicted end time of the next forced battery charging under the best plan predbat.best_charge_limit - Predicted best battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.best_charge_limit_kw - Predicted best battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.best_charge_start - Predicted start time of the next forced battery charging under the best plan predbat.best_export_end - Predicted end time of the next forced battery export under the best plan predbat.best_export_limit - Predicted best battery export limit in percent (will be 0% when discharging or 100% when not) with attributes of all future battery exports (kWh and time slots) predbat.best_export_limit_kw - Predicted best battery export limit in kWh predbat.best_export_start - Predicted start time of the next forced battery export under the best plan predbat.best_export_energy - Total kWh of predicted exports under the best plan, with attributes of the predicted export kWh and their time slots predbat.best_import_energy - Total kWh of predicted imports under the best plan, with attributes of the predicted import kWh and their time slots predbat.best_import_energy_battery - Total kWh of predicted import energy to charge the home battery under the best plan predbat.best_import_energy_house - Total kWh of predicted import energy used directly by the house under the best plan (e.g. due to a flat battery or the house load is greater than the max discharge rate) predbat.best_load_energy - Total kWh of predicted house load energy in kWh under the best plan with attributes of the predicted load kWh in 5 minute slots to the end of the plan predbat.best_metric - Total predicted cost for the best plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.best_pv_energy - Predicted PV energy in kWh under the best plan with attributes of the predicted PV generation in kWh with time slots predbat.best_soc_min_kwh - Predicted lowest battery SoC value in kWh under the best plan with attribute of the date/time that that lowest SoC occurs at predbat.car_soc_best - See Car data below predbat.carbon_best - See Carbon data below predbat.grid_power_best - The sensor is always zero; attributes contain the predicted Grid power (positive or negative for import or export), in kW per 5 minute slots to the end of the best plan for charting predbat.iboost_best - See iBoost data below predbat.load_power_best - Total kW of predicted house load power to the end of the best plan, with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.pv_power_best - The sensor is always zero; attributes contain the predicted PV power in kW per 5-minute slots to the end of the best plan for charting predbat.soc_kw_best - Predicted final state of charge (in kWh) with attributes of the predicted SoC in 5-minute time slots to the end of the best plan, for charting predbat.soc_kw_best_h1 - Single data point for the predicted state of charge in 1 hour (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h8 - Single data point for the predicted state of charge in 8 hours (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h12 - Single data point for the predicted state of charge in 12 hours (useful for calibration charts, predicted vs actual) Best PV 10% Prediction data Predbat outputs the following best results under the PV 10% scenario for the forecast_hours duration, these are known as the 'best10' prediction: predbat.best10_metric - Predicted best cost in pence using the PV 10% solar forecast predbat.best10_export_energy- Predicted best export energy in kWh for PV 10% predbat.best10_import_energy- Predicted best import energy in kWH for PV 10% predbat.best10_load_energy - Predicted best load energy in kWh for PV 10% predbat.best10_pv_energy - Predicted best PV 10% energy in kWh predbat.soc_kw_best10 - As soc_kw_best but using the PV 10%, also holds minute-by-minute data (in attributes) to be charted In-day load adjustment data The following sensors are used in the in-day adjustment chart - see creating the Predbat charts and in-day load adjustment : predbat.load_energy_actual - Total kWh of house load to end of plan, energy up to 'now' taken from today's actual energy, energy after 'now' from Predbat's prediction. Attributes of this actual/predicted energy in 5-minute slots from midnight today to the end of the plan for charting predbat.load_energy_adjusted - Total kWh of predicted house load to end of the plan, adjusted based on variance of today's actual load to the predicted load (based on historical data), dampened according to input_number.predbat_metric_inday_adjust_damping. Attributes contain the 5-minute slot forecasts to the end of the plan for charting predbat.load_energy_predicted - Total predicted kWh of house load to end of plan, attributes of predicted load in 5-minute slots from midnight today to the end of the plan for charting predbat.load_inday_adjustment - the % in-day adjustment factor used to adjust Predbat's predicted load by the actual load today 'Today' energy data The following sensor's output by Predbat give the 'today' energy readings. They mirror input sensors fed into Predbat in apps.yaml and are used in the data prediction chart - see creating the Predbat charts : predbat.export_energy_h0 - Mirrors the export_today sensor configured in apps.yaml and gives today's total kWh of export energy predbat.import_energy_h0 - Mirrors the import_today sensor configured in apps.yaml and gives today's total kWh of import energy predbat.load_energy_h0 - Mirrors the load_today sensor configured in apps.yaml and gives today's total kWh of house load energy. Note that if you have configured load scaling then load_energy_h0 will have been scaled by the scaling factor. predbat.pv_energy_h0 - Mirrors the pv_today sensor configured in apps.yaml and gives today's total kWh of generated PV energy predbat.soc_kw_h0 - Mirrors the soc_kwh sensor configured in apps.yaml and gives today's total kWh of battery state of charge (SoC). Note that if you have configured battery scaling then soc_kw_h0 will have been scaled by the configured scaling factor Battery status The following sensors are set based on what Predbat is currently controlling the battery to do: binary_sensor.predbat_charging - Set to 'on' when Predbat is force charging the battery (from solar, or if that is insufficient, from grid import), or 'off' otherwise binary_sensor.predbat_exporting - Set to 'on' when Predbat is force discharging the battery for export income, 'off' otherwise. These are useful for automations if for example, you want to turn off car charging when the battery is being exported. Export trigger binary_sensor.predbat_export_trigger_NAME - custom binary sensors that are set to On by Predbat when more than a specified amount of energy is being exported - see Triggers in apps.yaml Prediction window predbat.record - The sensor is always zero; attributes contain the time window for the current predicted plan Energy rate data Low-rate import entities predbat.low_rate_cost - The lowest import rate cost in Pence predbat.low_rate_duration - The time duration in minutes of the next low rate slot predbat.low_rate_end - End time of the next low import rate slot predbat.low_rate_start - Start time of the next low import rate slot predbat.low_rate_cost_2, predbat.low_rate_end_2, predbat.low_rate_start_2 - The cost and times of the following low import rate slot binary_sensor.predbat_low_rate_slot - A sensor that is 'on' to indicate when there is a low energy rate import slot active, 'off' otherwise High-rate export entities predbat.high_rate_export_cost - The highest export rate cost in Pence predbat.high_rate_export_duration - The time duration in minutes of the next high rate slot predbat.high_rate_export_end - End time of the next high export rate slot predbat.high_rate_export_start - Start time of the next high export rate slot predbat.high_rate_export_cost_2, predbat.high_rate_export_end_2, predbat.high_rate_export_start_2 - The cost and times of the following high export rate slot binary_sensor.predbat_high_rate_export_slot - A sensor that is 'on' to indicate when there is a high export rate slot active, 'off' otherwise Other rate entities predbat.rates - The current energy import rate in Pence with attributes of yesterday's, today and tomorrow's rates which can be charted predbat.rates_export - The current energy export rates in Pence (also can be charted) predbat.rates_gas - The current gas rates in Pence (also can be charted) predbat.cost_today - The total cost of energy so far today (since midnight) with attributes of the total cost every 5 minutes since midnight today predbat.cost_today_export - Same as predbat.cost_today, but for all export income since midnight today predbat.cost_today_import - Same as predbat.cost_today, but for all import costs since midnight today predbat.cost_hour - The total cost of energy averaged over the last hour predbat.cost_today_export - Same as predbat.cost_hour, but for export predbat.cost_today_import - Same as predbat.cost_hour, but for import predbat.ppkwh_today - The cost in pence/kWh of the house load today accounting for the change in battery level predbat.ppkwh_hour - The cost in pence/kWh of the house load averaged over the last hour, accounting for the change in battery level Inverter data Some inverters store inverter settings in flash memory that can have a limited number of write cycles so Predbat counts the commands that it sends to the inverter so you can keep track of this: predbat.inverter_register_writes is the incrementing total number of writes across all inverters If you want to create a utility meter to record daily inverter register writes, add the following to your configuration.yaml (NB: the utility meter has to be defined in YAML, it cannot be configured via the HA User Interface): utility_meter: # Predbat daily inverter writes utility meter predbat_daily_inverter_writes: source: predbat.inverter_register_writes name: Predbat Daily Inverter Writes unique_id: predbat_daily_inverter_writes cycle: daily Add a card of type 'markdown' to your dashboard to display a simple dashboard of inverter writes: type: markdown content: >- {% set dd = (as_timestamp(now()) - as_timestamp(\"2024-12-22 17:20:00\")) | timestamp_custom(\"%j\")| int %} {% set tw = (states('predbat.inverter_register_writes') | int) %} {{ dd }} days, total {{ tw }} inverter writes {{ states('sensor.predbat_daily_inverter_writes')|int }} writes today Average {{ (tw / dd ) | int }} writes per day You'll need to change the hard-coded timestamp \"2024-12-12...\" to the date/time you first started counting Predbat inverter writes from to get the number of days and average writes per day correct. Car data binary_sensor.predbat_car_charging_slot - A binary sensor indicating when to charge your car (if car planning is enabled) - which can be used in an automation as described in Predbat led car charging predbat.car_charging_start - The time that car charging is planned to start at, in HH:MM:SS format predbat.car_soc_best - Predicted charge level of your car in the best plan at the end of the plan using the proposed car charging SoC% and charge window. Can also be charted predbat.cost_today_car - Current cost in pence so far today of charging the car, with attribute of the projected future car charging costs and slots predbat.cost_total_car - A running total in pence of the below cost_yesterday_car sensor, with attribute of the total in pounds predbat.cost_yesterday_car - A sensor that gives the total energy costs in pence of charging the car for yesterday (00:00-23:59 on the previous day) iBoost Solar Diverter data binary_sensor.predbat_iboost_active - A binary sensor indicating when there is excess solar and the solar diverter (e.g. iBoost, Eddi or just plain immersion heater) should be active, can be used for automations to trigger the immersion heater boost input_number.predbat_iboost_today - Gives the amount of energy modelled that will be sent to the solar diverter today, increments during the day and is reset to zero at 11:30pm each night predbat.iboost_best - Predicted energy in kWh going into the iBoost solar diverter under the best plan You can use the iboost_best sensor to create a custom template sensor that gives the time to next planned iBoost: {% set iboost_times = state_attr(\"predbat.iboost_best\",\"results\") %} {% set times = iboost_times.keys()|list %} {% set iboost_energy = iboost_times.values()|list %} {% set ni = namespace(x=0) %} {% set data = namespace(h_bool=False) %} {% set iboost_starts = \"\" %} {% for ni in range(0,times|count()-1) if data.h_bool == false %} {% if iboost_energy[ni+1]-iboost_energy[ni] > 0 %} {% set data.h_bool = true %}{{ (as_timestamp (times[ni])-as_timestamp (now()) ) / 3600 | round (0) }} {% else %} {% endif %} {% endfor %} {% if data.h_bool == false %} {{100}} {% endif %} If no iBoost is imminent then the sensor is set to 100h, and if currently boosting it will produce a small negative answer. Thanks to @mogons57 for the template sensor code. Carbon data The following sensors output by Predbat give historic and predicted carbon data. They are used in the carbon chart - see creating the Predbat charts . predbat.carbon - Predicted Carbon energy in g at the end of the plan with attributes giving the breakdown of predicted Carbon impact by half hour time slots predbat.carbon_best - Predicted Carbon intensity in g for your home under the best plan based on grid imports, grid exports and the grid's projected carbon intensity predbat.carbon_now - A sensor that gives the current Grid Carbon intensity in g/kWh predbat.carbon_today - A sensor that tracks your home's Carbon impact today in g based on your grid import minus your grid export Cost saving data The following sensors output by Predbat give cost-saving data that Predbat achieved, i.e. the financial benefits of using Predbat. They are used in the daily cost-saving and total cost-savings charts - see creating the Predbat charts : predbat.cost_yesterday - A sensor that gives the total energy costs in pence for yesterday (00:00-23:59 on the previous day) predbat.savings_total_actual - A running total in pence of the above cost_yesterday sensor, with attribute of the total in pounds predbat.savings_total_predbat - A running total in pence of the below savings_yesterday_predbat sensor, with attribute of the total in pounds predbat.savings_total_pvbat - A running total of the below savings_yesterday_pvbat sensor, with attribute of the total in pounds predbat.savings_total_soc - A running total of what the final SoC in kWh would have been at the end of each day if you were not using Predbat predbat.savings_yesterday_predbat - A sensor which tells you how much money Predbat saved you yesterday compared to not using Predbat, and only charging at the lowest import rate in the 24 hour period predbat.savings_yesterday_pvbat - A sensor which tells you how much money you saved from using Predbat vs not having a PV and battery system at all and all house load being met from grid import Solar forecast data The following sensors give the forecast Solar data from Solcast. Predbat populates these sensors irrespective of whether you are using the Predbat direct Solcast or Solcast integration method to get your Solar forecast, but if you are using the Solcast integration then the Predbat sensors mirror the similarly named Solcast integration sensors so could be disabled if you so wish. sensor.predbat_pv_today - Tracks the PV forecast in kWh for today, attributes give the remaining amount today and the half-hourly data sensor.predbat_pv_tomorrow - Tracks the PV forecast in kWh for tomorrow, attributes give the remaining amount today and the half-hourly data sensor.predbat_pv_d2 - Similar to the above, but tracking the PV forecast for the day after tomorrow sensor.predbat_pv_d3 - PV forecast for two days after tomorrow sensor.predbat_pv_forecast_h0 - Tracks the PV 'power now' forecast in Watts, attributes give the 10% and 90% power now forecast Dummy inverter sensors Predbat can now manage different inverter types, some of which don't have all the same control characteristics. Predbat might create dummy entities for control aspects that your inverter doesn't natively support. For example, for each Gen 1 hybrid inverter (N=0, 1, etc if there are multiple inverters), Predbat creates the following dummy inverter entities: sensor.predbat_ge_N_idle_end_time sensor.predbat_ge_N_idle_start_time sensor.predbat_ge_N_scheduled_discharge_enable These sensors can be ignored and excluded from the recorder history if you wish. Alert data predbat.alerts - Gives you data on the currently active weather alert (if configured) and in the attributes a list of all active alerts with their details Predbat Logfile Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so this file should be checked if predbat.status reports an error, or if you want to verify that Predbat is running OK. There is a lot of output in the logfile, this is normal! If you are using the Predbat add-on then the logfile can easily be viewed via the 'Log' tab of the Predbat web interface . To directly view the physical logfile, it can be found in one of three different directories in Home Assistant with slightly different filenames depending on how you installed Predbat: if you have used the Predbat add-on installation method , the logfile will be /addon_configs/6adb4f0d_predbat/predbat.log , if the HACS, Appdaemon add-on then Predbat installation method , it's /homeassistant/appdaemon/appdaemon.log , or if the combined AppDaemon/Predbat add-on installation method was used, it's /addon_configs/46f69597_appdaemon-predbat/predbat.log . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to view Predbat's logfile if you are not using the Predbat add-on. See editing configuration files within Home Assistant if you need to install an editor. Automated monitoring that Predbat and GivTCP are running OK With GivTCP and Predbat performing an important function, managing your battery charging and discharging to best reduce your electricity bills, you may find these automations useful to monitor that GivTCP and Predbat are running OK, and if not, to raise an alert on your mobile device running the Home Assistant Companion app. To create a new automation: Settings / Automations & Scenes Create Automation / Create new Automation Three dots (top right corner) / Edit in YAML Delete the existing (template) automation code and copy/paste the supplied automation code below GivTCP activity monitor This automation will raise an alert if any of the following occur: The inverter goes offline for more than 15 minutes No last_updated_time received from the inverter for more than 15 minutes Inverter temperature less than 5 degrees for more than 15 minutes (should never happen) The battery goes offline to the inverter for more than 15 minutes GivTCP add-on is not running Mosquitto broker add-on is not running Predbat/AppDaemon-predbat or AppDaemon add-on (as appropriate) is not running The script will need to be customised for your inverter ID, battery ID and mobile details, and can be extended for multiple inverters and batteries by duplicating the triggers and adding appropriate battery and inverter IDs. alias: GivTCP activity monitor description: Alert when communications to GivTCP have ceased for 15 minutes triggers: - trigger: state entity_id: sensor.givtcp_<inverter id>_last_updated_time to: \"null\" for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<inverter id>_status from: online for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: numeric_state entity_id: - sensor.givtcp_<inverter id>_invertor_temperature for: minutes: 15 below: 10 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<battery id>_battery_cells to: unknown for: minutes: 15 variables: alert_text: Battery <battery_id> is offline to GivTCP restart_app: GivTCP - trigger: state entity_id: - binary_sensor.givtcp_running to: \"off\" for: minutes: 15 variables: alert_text: GivTCP add-on is not running restart_app: GivTCP - trigger: state entity_id: - binary_sensor.mosquitto_broker_running to: \"off\" for: minutes: 15 variables: alert_text: Mosquitto Broker add-on is not running restart_app: Mosquitto actions: - action: notify.mobile_app_<your mobile device id> alias: Send a notification data: title: GivTCP communication issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} for the past 15 minutes, restarting {{ restart_app }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - choose: - conditions: - condition: template value_template: \"{{ restart_app == 'GivTCP' }}\" sequence: - alias: Restart GivTCP add-on action: hassio.addon_restart data: addon: 533ea71a_givtcp - conditions: - condition: template value_template: \"{{ restart_app == 'Mosquitto' }}\" sequence: - alias: Restart Mosquitto add-on action: hassio.addon_restart data: addon: core_mosquitto trace: stored_traces: 20 mode: single The last two triggers (GivTCP and Mosquitto running) trigger if any of these add-ons that Predbat is dependent upon are not running. You will need to enable a binary sensor for each add-on to be able to use these triggers in the automation: Navigate to Settings / Devices and Services / Devices and search for 'GivTCP' Click on the GivTCP add-on, and under 'Sensors', click 'XX entities not shown' Click the 'Running' sensor, then the cogwheel, and Enable the sensor Repeat these steps for the 'Mosquitto' add-on. As an extension to the above, if you don't want the automation to restart the failing add-on and instead just send an alert that there is a problem, delete the 'choose' code above. Restarting GivTCP does however lose the current GivTCP log-in Home Assistant. NB: If you are using GivTCP v2 rather than v3, replace the '533ea71a_givtcp' with 'a6a2857d_givtcp'. Predbat error monitor This automation will raise an alert if Predbat's status turns to Error for more than 5 minutes. In normal operation, Predbat will automatically run and update its forecast every 5 minutes. If the automation detects that Predbat has not done this for 20 minutes, then an alert will be raised and the automation will restart the Predbat add-on to try to resolve a 'hung Predbat' issue. In the same way for the GivTCP and Mosquitto add-ons above, the last trigger requires you to enable a binary sensor that detects that the Predbat/AppDaemon add-on is running. Follow the same steps to enable the binary sensor for either the 'Predbat', 'AppDaemon' or 'AppDaemon-predbat' add-on depending on which Predbat installation method you followed. The script will need to be customised for your mobile details. alias: Predbat error monitor description: Alert when Predbat has raised an exception trace: stored_traces: 20 triggers: - trigger: template alias: Predbat status contains 'Error' for 5 minutes value_template: \"{{ 'Error' in states('predbat.status') }}\" for: minutes: 5 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat is in error status for 5 minutes entity_id: predbat.status attribute: error to: \"true\" for: minutes: 5 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat status.last_updated has not changed for 20 minutes entity_id: predbat.status attribute: last_updated for: minutes: 20 variables: alert_text: >- Predbat stalled? Restarting. last_updated=' {{ state_attr('predbat.status','last_updated')|as_timestamp|timestamp_custom('%a %H:%M') }}', unchanged for 20 mins; Status='{{ states('predbat.status') }}' restart_predbat: \"Y\" - trigger: state alias: Predbat add-on not running for 15 minutes entity_id: binary_sensor.predbat_running to: \"off\" for: minutes: 15 variables: alert_text: Predbat add-on is not running, restarting restart_predbat: \"Y\" - trigger: state alias: predbat_active stuck on for 20 minutes entity_id: - switch.predbat_active for: minutes: 20 variables: alert_text: Predbat active has been stuck on (updating the plan) for 20 minutes, restarting restart_predbat: \"Y\" actions: - action: notify.mobile_app_<your mobile device id> alias: Send alert message data: title: Predbat status issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - if: - condition: template value_template: \"{{ restart_predbat == 'Y' }}\" then: - action: hassio.addon_restart data: addon: 6adb4f0d_predbat alias: Restart Predbat add-on mode: single NB: If you are using AppDaemon rather than the Predbat add-on, replace '6adb4f0d_predbat' with 'a0d7b954_appdaemon' and change 'binary_sensor.predbat_running' to 'binary_sensor.appdaemon_running'. An error alert looks like this:","title":"Output data"},{"location":"output-data/#output-data","text":"Each time Predbat runs it outputs a lot of information about the current performance of your solar/battery system and the predicted load, PV, cost, CO2, car charging, etc. This section of the documentation explains the different output and logging data that Predbat produces and gives an overview of how to display that information within Home Assistant. There can never be a single Predbat dashboard that suits every user, so instead Predbat gives a starter set of displays that can be adapted to your individual needs.","title":"Output data"},{"location":"output-data/#web-interface","text":"The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles.","title":"Web interface"},{"location":"output-data/#displaying-output-data","text":"Each Predbat configuration item is named input_number.predbat_xxx , switch.predbat_yyy or select.predbat_zzz depending on the control type.","title":"Displaying output data"},{"location":"output-data/#creating-a-simple-predbat-dashboard","text":"Each time Predbat runs it auto-generates a dashboard with the filename predbat_dashboard.yaml that can be used as a starter for your own Predbat dashboard. Depending on how you installed Predbat this predbat_dashboard.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat add-on installation method , it will be in the directory /addon_configs/6adb4f0d_predbat/ , if the combined AppDaemon/Predbat add-on installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/ , or with the HACS, Appdaemon add-on then Predbat installation method , it's /config/appdaemon/apps/batpred/config/ . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to open the predbat_dashboard.yaml file - see editing configuration files within Home Assistant if you need to install an editor. Once opened, select and copy all the contents of the predbat_dashboard.yaml file and add the contents to a new dashboard page: Go to System/Dashboards, click 'Open' against an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then click 'Open' Click the pencil icon in the top right corner, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and paste the contents of the predbat_dashboard.yaml file copied earlier, then 'Save'. This will give you a simple Predbat control and output dashboard that you can then resequence and customise as you wish.","title":"Creating a simple Predbat dashboard"},{"location":"output-data/#creating-a-compact-predbat-control-dashboard","text":"You can also create a dashboard page that's dynamically generated to automatically include all the Predbat control and output entities, so when new entities are added in future Predbat releases, you don't have to edit the dashboard. Firstly you need to install HACS if it isn't already installed, and then install two HACS front-end components: Auto Entities ( https://github.com/thomasloven/lovelace-auto-entities ) automatically generates a list of entities that match a wildcard expression Lovelace Collapsable Cards ( https://github.com/RossMcMillan92/lovelace-collapsable-cards ) wraps the entity lists within a drop-down toggle Installation steps: Click the HACS icon on the left-hand side panel Click 'Frontend' Click the three dots in the top right corner then 'Custom Repositories' Paste (or type) in the following repository name https://github.com/RossMcMillan92/lovelace-collapsable-cards , choose Type 'Dashboard', and click Add Close the Custom Repositories dialogue Click 'Explore & Download Repositories' Search for 'collapsable cards', click the name of it, check it's the right one, click 'Download', 'Download' again, then 'Reload' Click 'Explore & Download Repositories' again, search for 'auto-entities', then 'Download', 'Download', 'Reload' Now create the dynamic dashboard: Go to Settings/Dashboards, click 'Open' against an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then click 'Open' Click the pencil icon in the top right corner, then the plus symbol on the far right of the next row to create a new View Enter a title of the View, then Save Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following YAML into the dashboard and click 'Save': type: vertical-stack title: Predbat \ud83e\udd87 cards: - type: entities entities: - entity: predbat.status - type: weblink name: Predbat Web Console url: /hassio/ingress/6adb4f0d_predbat - entity: update.predbat_version - entity: select.predbat_update - entity: select.predbat_mode - entity: select.predbat_saverestore - entity: switch.predbat_active - type: custom:collapsable-cards title: \ud83d\udd00 Control defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udd22 Input Variables defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: input_number.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd00 Switches defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: switch.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd22 Selectors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: select.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: '#\ufe0f\u20e3 Sensors' defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udcb7 Cost Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*cost* - entity_id: predbat.*rate* - entity_id: predbat.*metric* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udcb7 Saving Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*saving* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd5b Time/Duration Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \u26a1 Power Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*soc* - entity_id: predbat.*energy* - entity_id: predbat.*load* - entity_id: predbat.*battery* - entity_id: predbat.*kw* - entity_id: predbat.*power* - entity_id: predbat.*charge* - entity_id: predbat.*iboost* - entity_id: predbat.*grid* - entity_id: sensor.predbat_pv* exclude: - entity_id: predbat.*savings* - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: 1\ufe0f\u20e3 Binary Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: binary_sensor.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false This will give you a compact dynamically created list of all Predbat entities which groups the entities by type and is collapsed by default to prevent screen clutter. Credit @DJBenson for the code.","title":"Creating a compact Predbat control dashboard"},{"location":"output-data/#viewing-the-predbat-plan","text":"predbat.plan_html - A sensor that contains an HTML render of the Predbat predicted best plan, detailing import and export rates, predicted house load, solar generation, any solar clipping, battery SoC, car and iBoost charging, and Predbat's planned charging and discharging activities. The plan is contained in the 'html' attribute, and its recommended to Create the Predbat Plan card as an easy way to see the plan that Predbat has created. The sensor also contains the 'text' attribute which gives a HTML formatted brief text description of the Predbat plan. If you are using the Predbat add-on or docker then the Predbat plan can also be viewed via the 'Plan' view of the Predbat web interface , and the text description via the 'Dash' view .","title":"Viewing the Predbat plan"},{"location":"output-data/#graphing-the-predbat-predictions","text":"A set of Apex Charts can also be created to see graphically what Predbat plans to do - Creating the charts . Renditions of the key charts can also be seen in the 'Charts' view of the Predbat web interface .","title":"Graphing the Predbat predictions"},{"location":"output-data/#basic-status","text":"switch.predbat_active - Automatically set by Predbat to On when Predbat is busy calculating or controlling your inverter, or Off when Predbat is waiting for the next time it needs to perform a plan calculation update. If you toggle this switch in Home Assistant it will force Predbat to perform an update now (useful for automations). predbat.status - Gives the current status & errors and logs any changes that Predbat makes to your inverter. The different Predbat status values and their meanings are detailed in what does Predbat do . predbat.status additionally has the following attributes that are automatically populated: Last updated - date and time that Predbat last updated the plan Debug - A set of arrays containing Predbat's planned charging and discharging time windows and battery limits (in kWh) Version - version of Predbat that's running Error - binary value true or false depending upon whether Predbat is in an error status or nor","title":"Basic status"},{"location":"output-data/#baseline-data","text":"Predbat outputs the following sensors to predict what your battery is expected to do over the forecast_hours duration of the plan with no changes made by Predbat. This is considered to be the 'baseline' plan: NB: All of Predbat's forecasts are from midnight today to the forecast_hours duration (set in apps.yaml) into the future and shouldn't be confused with 'today' figures. e.g. predbat.pv_energy is the actual PV energy from midnight today, and for the predicted forecast_hours (typically 48) ahead so will be much larger than sensor.solcast_pv_forecast_today which is today's Solcast PV forecast. predbat.battery_cycle - Predicted baseline battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_hours_left - The number of hours left until your home battery is predicted to run out under the baseline plan (stops at the maximum prediction time) predbat.battery_power - The sensor is always zero; attributes contain the predicted remaining battery power under the baseline plan, in 5-minute slots, for charting predbat.car_soc - The expected charge level of your car at the end of the baseline plan. Can also be charted predbat.charge_end - Predicted end time of the next forced battery charging under the baseline plan predbat.charge_limit - Predicted baseline battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.charge_limit_kw - Predicted baseline battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.charge_start - Predicted start time of the next forced battery charging under the baseline plan predbat.duration - The duration of the prediction maximum in hours predbat.export_energy - Total kWh of predicted exports under the baseline plan with attributes of the predicted export kWh and their time slots predbat.grid_power - The sensor is always zero; attributes contain the predicted Grid power (positive or negative for import or export) in kW per 5-minute slots to the end of the baseline plan for charting predbat.import_energy - Total kWh of predicted imports under baseline plan with attributes of the predicted import kWh and their time slots predbat.import_energy_battery - Total kWh of predicted import energy used to charge the home battery under the baseline plan predbat.import_energy_house - Predicted import energy used by the home under the baseline plan that is not provided by your home battery (e.g. due to a flat battery or load above the maximum discharge rate) predbat.load_energy - Total kWh of predicted house load under the baseline plan with attributes of the predicted load kWh in 5-minute slots to the end of the plan predbat.load_power - Total kW of predicted house load power to the end of the baseline plan, with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.metric - Total predicted cost for the baseline plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.pv_energy - Predicted PV energy in kWh under the baseline plan with attributes of the predicted PV generation in kWh with time slots predbat.pv_power - Predicted PV power now with attributes that contain the predicted PV power in kW per 5-minute slots to the end of the baseline plan for charting predbat.soc_kw - Predicted state of charge (in kWh) at the end of the baseline plan prediction, not very useful in itself, but the attributes hold prediction data in 5-minute intervals which can be charted with Apex Charts (or similar) predbat.soc_min_kwh - Predicted lowest battery SoC value in kWh under the baseline plan with attribute of the date/time that that lowest SoC occurs at","title":"Baseline data"},{"location":"output-data/#pv-10-baseline-data","text":"Predbat outputs the following baseline results under the PV 10% scenario for the forecast_hours duration of the plan, these are known as the 'base10' predictions: predbat.base10_export_energy- Total predicted export energy in kWh for the PV 10% scenario, with attributes of the predicted export kWh and their time slots predbat.base10_import_energy- Total predicted import energy in kWh for the PV 10% scenario, with attributes of the predicted import kWh and their time slots predbat.base10_load_energy - Total predicted house load in kWh for the PV 10% scenario predbat.base10_metric - Total predicted cost for the PV 10% scenario, with attributes of the cost prediction in 5-minute slots to the end of the plan for charting predbat.base10_pv_energy - Predicted PV 10% energy in kWh with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw_base10 - Predicted final state of charge (in kWh) of the battery, with attributes of the predicted SoC in 5-minute time slots to the end of the plan under the PV 10% scenario, for charting","title":"PV 10% Baseline data"},{"location":"output-data/#best-prediction-data","text":"Predbat outputs the following 'best' entities from the forecast (for the forecast_hours duration) based on the lowest cost consumption plan. The 'best' plan in Predbat parlance is simply Predbat's lowest cost predicted plan: predbat.battery_cycle_best - Predicted best battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_power_best - Predicted remaining battery power in kW with attributes of the future prediction in 5-minute slots predbat.best_battery_hours_left - Predicted total number of hours of battery capacity left under the best plan predbat.best_charge_end - Predicted end time of the next forced battery charging under the best plan predbat.best_charge_limit - Predicted best battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.best_charge_limit_kw - Predicted best battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.best_charge_start - Predicted start time of the next forced battery charging under the best plan predbat.best_export_end - Predicted end time of the next forced battery export under the best plan predbat.best_export_limit - Predicted best battery export limit in percent (will be 0% when discharging or 100% when not) with attributes of all future battery exports (kWh and time slots) predbat.best_export_limit_kw - Predicted best battery export limit in kWh predbat.best_export_start - Predicted start time of the next forced battery export under the best plan predbat.best_export_energy - Total kWh of predicted exports under the best plan, with attributes of the predicted export kWh and their time slots predbat.best_import_energy - Total kWh of predicted imports under the best plan, with attributes of the predicted import kWh and their time slots predbat.best_import_energy_battery - Total kWh of predicted import energy to charge the home battery under the best plan predbat.best_import_energy_house - Total kWh of predicted import energy used directly by the house under the best plan (e.g. due to a flat battery or the house load is greater than the max discharge rate) predbat.best_load_energy - Total kWh of predicted house load energy in kWh under the best plan with attributes of the predicted load kWh in 5 minute slots to the end of the plan predbat.best_metric - Total predicted cost for the best plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.best_pv_energy - Predicted PV energy in kWh under the best plan with attributes of the predicted PV generation in kWh with time slots predbat.best_soc_min_kwh - Predicted lowest battery SoC value in kWh under the best plan with attribute of the date/time that that lowest SoC occurs at predbat.car_soc_best - See Car data below predbat.carbon_best - See Carbon data below predbat.grid_power_best - The sensor is always zero; attributes contain the predicted Grid power (positive or negative for import or export), in kW per 5 minute slots to the end of the best plan for charting predbat.iboost_best - See iBoost data below predbat.load_power_best - Total kW of predicted house load power to the end of the best plan, with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.pv_power_best - The sensor is always zero; attributes contain the predicted PV power in kW per 5-minute slots to the end of the best plan for charting predbat.soc_kw_best - Predicted final state of charge (in kWh) with attributes of the predicted SoC in 5-minute time slots to the end of the best plan, for charting predbat.soc_kw_best_h1 - Single data point for the predicted state of charge in 1 hour (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h8 - Single data point for the predicted state of charge in 8 hours (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h12 - Single data point for the predicted state of charge in 12 hours (useful for calibration charts, predicted vs actual)","title":"Best Prediction data"},{"location":"output-data/#best-pv-10-prediction-data","text":"Predbat outputs the following best results under the PV 10% scenario for the forecast_hours duration, these are known as the 'best10' prediction: predbat.best10_metric - Predicted best cost in pence using the PV 10% solar forecast predbat.best10_export_energy- Predicted best export energy in kWh for PV 10% predbat.best10_import_energy- Predicted best import energy in kWH for PV 10% predbat.best10_load_energy - Predicted best load energy in kWh for PV 10% predbat.best10_pv_energy - Predicted best PV 10% energy in kWh predbat.soc_kw_best10 - As soc_kw_best but using the PV 10%, also holds minute-by-minute data (in attributes) to be charted","title":"Best PV 10% Prediction data"},{"location":"output-data/#in-day-load-adjustment-data","text":"The following sensors are used in the in-day adjustment chart - see creating the Predbat charts and in-day load adjustment : predbat.load_energy_actual - Total kWh of house load to end of plan, energy up to 'now' taken from today's actual energy, energy after 'now' from Predbat's prediction. Attributes of this actual/predicted energy in 5-minute slots from midnight today to the end of the plan for charting predbat.load_energy_adjusted - Total kWh of predicted house load to end of the plan, adjusted based on variance of today's actual load to the predicted load (based on historical data), dampened according to input_number.predbat_metric_inday_adjust_damping. Attributes contain the 5-minute slot forecasts to the end of the plan for charting predbat.load_energy_predicted - Total predicted kWh of house load to end of plan, attributes of predicted load in 5-minute slots from midnight today to the end of the plan for charting predbat.load_inday_adjustment - the % in-day adjustment factor used to adjust Predbat's predicted load by the actual load today","title":"In-day load adjustment data"},{"location":"output-data/#today-energy-data","text":"The following sensor's output by Predbat give the 'today' energy readings. They mirror input sensors fed into Predbat in apps.yaml and are used in the data prediction chart - see creating the Predbat charts : predbat.export_energy_h0 - Mirrors the export_today sensor configured in apps.yaml and gives today's total kWh of export energy predbat.import_energy_h0 - Mirrors the import_today sensor configured in apps.yaml and gives today's total kWh of import energy predbat.load_energy_h0 - Mirrors the load_today sensor configured in apps.yaml and gives today's total kWh of house load energy. Note that if you have configured load scaling then load_energy_h0 will have been scaled by the scaling factor. predbat.pv_energy_h0 - Mirrors the pv_today sensor configured in apps.yaml and gives today's total kWh of generated PV energy predbat.soc_kw_h0 - Mirrors the soc_kwh sensor configured in apps.yaml and gives today's total kWh of battery state of charge (SoC). Note that if you have configured battery scaling then soc_kw_h0 will have been scaled by the configured scaling factor","title":"'Today' energy data"},{"location":"output-data/#battery-status","text":"The following sensors are set based on what Predbat is currently controlling the battery to do: binary_sensor.predbat_charging - Set to 'on' when Predbat is force charging the battery (from solar, or if that is insufficient, from grid import), or 'off' otherwise binary_sensor.predbat_exporting - Set to 'on' when Predbat is force discharging the battery for export income, 'off' otherwise. These are useful for automations if for example, you want to turn off car charging when the battery is being exported.","title":"Battery status"},{"location":"output-data/#export-trigger","text":"binary_sensor.predbat_export_trigger_NAME - custom binary sensors that are set to On by Predbat when more than a specified amount of energy is being exported - see Triggers in apps.yaml","title":"Export trigger"},{"location":"output-data/#prediction-window","text":"predbat.record - The sensor is always zero; attributes contain the time window for the current predicted plan","title":"Prediction window"},{"location":"output-data/#energy-rate-data","text":"","title":"Energy rate data"},{"location":"output-data/#low-rate-import-entities","text":"predbat.low_rate_cost - The lowest import rate cost in Pence predbat.low_rate_duration - The time duration in minutes of the next low rate slot predbat.low_rate_end - End time of the next low import rate slot predbat.low_rate_start - Start time of the next low import rate slot predbat.low_rate_cost_2, predbat.low_rate_end_2, predbat.low_rate_start_2 - The cost and times of the following low import rate slot binary_sensor.predbat_low_rate_slot - A sensor that is 'on' to indicate when there is a low energy rate import slot active, 'off' otherwise","title":"Low-rate import entities"},{"location":"output-data/#high-rate-export-entities","text":"predbat.high_rate_export_cost - The highest export rate cost in Pence predbat.high_rate_export_duration - The time duration in minutes of the next high rate slot predbat.high_rate_export_end - End time of the next high export rate slot predbat.high_rate_export_start - Start time of the next high export rate slot predbat.high_rate_export_cost_2, predbat.high_rate_export_end_2, predbat.high_rate_export_start_2 - The cost and times of the following high export rate slot binary_sensor.predbat_high_rate_export_slot - A sensor that is 'on' to indicate when there is a high export rate slot active, 'off' otherwise","title":"High-rate export entities"},{"location":"output-data/#other-rate-entities","text":"predbat.rates - The current energy import rate in Pence with attributes of yesterday's, today and tomorrow's rates which can be charted predbat.rates_export - The current energy export rates in Pence (also can be charted) predbat.rates_gas - The current gas rates in Pence (also can be charted) predbat.cost_today - The total cost of energy so far today (since midnight) with attributes of the total cost every 5 minutes since midnight today predbat.cost_today_export - Same as predbat.cost_today, but for all export income since midnight today predbat.cost_today_import - Same as predbat.cost_today, but for all import costs since midnight today predbat.cost_hour - The total cost of energy averaged over the last hour predbat.cost_today_export - Same as predbat.cost_hour, but for export predbat.cost_today_import - Same as predbat.cost_hour, but for import predbat.ppkwh_today - The cost in pence/kWh of the house load today accounting for the change in battery level predbat.ppkwh_hour - The cost in pence/kWh of the house load averaged over the last hour, accounting for the change in battery level","title":"Other rate entities"},{"location":"output-data/#inverter-data","text":"Some inverters store inverter settings in flash memory that can have a limited number of write cycles so Predbat counts the commands that it sends to the inverter so you can keep track of this: predbat.inverter_register_writes is the incrementing total number of writes across all inverters If you want to create a utility meter to record daily inverter register writes, add the following to your configuration.yaml (NB: the utility meter has to be defined in YAML, it cannot be configured via the HA User Interface): utility_meter: # Predbat daily inverter writes utility meter predbat_daily_inverter_writes: source: predbat.inverter_register_writes name: Predbat Daily Inverter Writes unique_id: predbat_daily_inverter_writes cycle: daily Add a card of type 'markdown' to your dashboard to display a simple dashboard of inverter writes: type: markdown content: >- {% set dd = (as_timestamp(now()) - as_timestamp(\"2024-12-22 17:20:00\")) | timestamp_custom(\"%j\")| int %} {% set tw = (states('predbat.inverter_register_writes') | int) %} {{ dd }} days, total {{ tw }} inverter writes {{ states('sensor.predbat_daily_inverter_writes')|int }} writes today Average {{ (tw / dd ) | int }} writes per day You'll need to change the hard-coded timestamp \"2024-12-12...\" to the date/time you first started counting Predbat inverter writes from to get the number of days and average writes per day correct.","title":"Inverter data"},{"location":"output-data/#car-data","text":"binary_sensor.predbat_car_charging_slot - A binary sensor indicating when to charge your car (if car planning is enabled) - which can be used in an automation as described in Predbat led car charging predbat.car_charging_start - The time that car charging is planned to start at, in HH:MM:SS format predbat.car_soc_best - Predicted charge level of your car in the best plan at the end of the plan using the proposed car charging SoC% and charge window. Can also be charted predbat.cost_today_car - Current cost in pence so far today of charging the car, with attribute of the projected future car charging costs and slots predbat.cost_total_car - A running total in pence of the below cost_yesterday_car sensor, with attribute of the total in pounds predbat.cost_yesterday_car - A sensor that gives the total energy costs in pence of charging the car for yesterday (00:00-23:59 on the previous day)","title":"Car data"},{"location":"output-data/#iboost-solar-diverter-data","text":"binary_sensor.predbat_iboost_active - A binary sensor indicating when there is excess solar and the solar diverter (e.g. iBoost, Eddi or just plain immersion heater) should be active, can be used for automations to trigger the immersion heater boost input_number.predbat_iboost_today - Gives the amount of energy modelled that will be sent to the solar diverter today, increments during the day and is reset to zero at 11:30pm each night predbat.iboost_best - Predicted energy in kWh going into the iBoost solar diverter under the best plan You can use the iboost_best sensor to create a custom template sensor that gives the time to next planned iBoost: {% set iboost_times = state_attr(\"predbat.iboost_best\",\"results\") %} {% set times = iboost_times.keys()|list %} {% set iboost_energy = iboost_times.values()|list %} {% set ni = namespace(x=0) %} {% set data = namespace(h_bool=False) %} {% set iboost_starts = \"\" %} {% for ni in range(0,times|count()-1) if data.h_bool == false %} {% if iboost_energy[ni+1]-iboost_energy[ni] > 0 %} {% set data.h_bool = true %}{{ (as_timestamp (times[ni])-as_timestamp (now()) ) / 3600 | round (0) }} {% else %} {% endif %} {% endfor %} {% if data.h_bool == false %} {{100}} {% endif %} If no iBoost is imminent then the sensor is set to 100h, and if currently boosting it will produce a small negative answer. Thanks to @mogons57 for the template sensor code.","title":"iBoost Solar Diverter data"},{"location":"output-data/#carbon-data","text":"The following sensors output by Predbat give historic and predicted carbon data. They are used in the carbon chart - see creating the Predbat charts . predbat.carbon - Predicted Carbon energy in g at the end of the plan with attributes giving the breakdown of predicted Carbon impact by half hour time slots predbat.carbon_best - Predicted Carbon intensity in g for your home under the best plan based on grid imports, grid exports and the grid's projected carbon intensity predbat.carbon_now - A sensor that gives the current Grid Carbon intensity in g/kWh predbat.carbon_today - A sensor that tracks your home's Carbon impact today in g based on your grid import minus your grid export","title":"Carbon data"},{"location":"output-data/#cost-saving-data","text":"The following sensors output by Predbat give cost-saving data that Predbat achieved, i.e. the financial benefits of using Predbat. They are used in the daily cost-saving and total cost-savings charts - see creating the Predbat charts : predbat.cost_yesterday - A sensor that gives the total energy costs in pence for yesterday (00:00-23:59 on the previous day) predbat.savings_total_actual - A running total in pence of the above cost_yesterday sensor, with attribute of the total in pounds predbat.savings_total_predbat - A running total in pence of the below savings_yesterday_predbat sensor, with attribute of the total in pounds predbat.savings_total_pvbat - A running total of the below savings_yesterday_pvbat sensor, with attribute of the total in pounds predbat.savings_total_soc - A running total of what the final SoC in kWh would have been at the end of each day if you were not using Predbat predbat.savings_yesterday_predbat - A sensor which tells you how much money Predbat saved you yesterday compared to not using Predbat, and only charging at the lowest import rate in the 24 hour period predbat.savings_yesterday_pvbat - A sensor which tells you how much money you saved from using Predbat vs not having a PV and battery system at all and all house load being met from grid import","title":"Cost saving data"},{"location":"output-data/#solar-forecast-data","text":"The following sensors give the forecast Solar data from Solcast. Predbat populates these sensors irrespective of whether you are using the Predbat direct Solcast or Solcast integration method to get your Solar forecast, but if you are using the Solcast integration then the Predbat sensors mirror the similarly named Solcast integration sensors so could be disabled if you so wish. sensor.predbat_pv_today - Tracks the PV forecast in kWh for today, attributes give the remaining amount today and the half-hourly data sensor.predbat_pv_tomorrow - Tracks the PV forecast in kWh for tomorrow, attributes give the remaining amount today and the half-hourly data sensor.predbat_pv_d2 - Similar to the above, but tracking the PV forecast for the day after tomorrow sensor.predbat_pv_d3 - PV forecast for two days after tomorrow sensor.predbat_pv_forecast_h0 - Tracks the PV 'power now' forecast in Watts, attributes give the 10% and 90% power now forecast","title":"Solar forecast data"},{"location":"output-data/#dummy-inverter-sensors","text":"Predbat can now manage different inverter types, some of which don't have all the same control characteristics. Predbat might create dummy entities for control aspects that your inverter doesn't natively support. For example, for each Gen 1 hybrid inverter (N=0, 1, etc if there are multiple inverters), Predbat creates the following dummy inverter entities: sensor.predbat_ge_N_idle_end_time sensor.predbat_ge_N_idle_start_time sensor.predbat_ge_N_scheduled_discharge_enable These sensors can be ignored and excluded from the recorder history if you wish.","title":"Dummy inverter sensors"},{"location":"output-data/#alert-data","text":"predbat.alerts - Gives you data on the currently active weather alert (if configured) and in the attributes a list of all active alerts with their details","title":"Alert data"},{"location":"output-data/#predbat-logfile","text":"Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so this file should be checked if predbat.status reports an error, or if you want to verify that Predbat is running OK. There is a lot of output in the logfile, this is normal! If you are using the Predbat add-on then the logfile can easily be viewed via the 'Log' tab of the Predbat web interface . To directly view the physical logfile, it can be found in one of three different directories in Home Assistant with slightly different filenames depending on how you installed Predbat: if you have used the Predbat add-on installation method , the logfile will be /addon_configs/6adb4f0d_predbat/predbat.log , if the HACS, Appdaemon add-on then Predbat installation method , it's /homeassistant/appdaemon/appdaemon.log , or if the combined AppDaemon/Predbat add-on installation method was used, it's /addon_configs/46f69597_appdaemon-predbat/predbat.log . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server add-ons) to view Predbat's logfile if you are not using the Predbat add-on. See editing configuration files within Home Assistant if you need to install an editor.","title":"Predbat Logfile"},{"location":"output-data/#automated-monitoring-that-predbat-and-givtcp-are-running-ok","text":"With GivTCP and Predbat performing an important function, managing your battery charging and discharging to best reduce your electricity bills, you may find these automations useful to monitor that GivTCP and Predbat are running OK, and if not, to raise an alert on your mobile device running the Home Assistant Companion app. To create a new automation: Settings / Automations & Scenes Create Automation / Create new Automation Three dots (top right corner) / Edit in YAML Delete the existing (template) automation code and copy/paste the supplied automation code below","title":"Automated monitoring that Predbat and GivTCP are running OK"},{"location":"output-data/#givtcp-activity-monitor","text":"This automation will raise an alert if any of the following occur: The inverter goes offline for more than 15 minutes No last_updated_time received from the inverter for more than 15 minutes Inverter temperature less than 5 degrees for more than 15 minutes (should never happen) The battery goes offline to the inverter for more than 15 minutes GivTCP add-on is not running Mosquitto broker add-on is not running Predbat/AppDaemon-predbat or AppDaemon add-on (as appropriate) is not running The script will need to be customised for your inverter ID, battery ID and mobile details, and can be extended for multiple inverters and batteries by duplicating the triggers and adding appropriate battery and inverter IDs. alias: GivTCP activity monitor description: Alert when communications to GivTCP have ceased for 15 minutes triggers: - trigger: state entity_id: sensor.givtcp_<inverter id>_last_updated_time to: \"null\" for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<inverter id>_status from: online for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: numeric_state entity_id: - sensor.givtcp_<inverter id>_invertor_temperature for: minutes: 15 below: 10 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<battery id>_battery_cells to: unknown for: minutes: 15 variables: alert_text: Battery <battery_id> is offline to GivTCP restart_app: GivTCP - trigger: state entity_id: - binary_sensor.givtcp_running to: \"off\" for: minutes: 15 variables: alert_text: GivTCP add-on is not running restart_app: GivTCP - trigger: state entity_id: - binary_sensor.mosquitto_broker_running to: \"off\" for: minutes: 15 variables: alert_text: Mosquitto Broker add-on is not running restart_app: Mosquitto actions: - action: notify.mobile_app_<your mobile device id> alias: Send a notification data: title: GivTCP communication issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} for the past 15 minutes, restarting {{ restart_app }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - choose: - conditions: - condition: template value_template: \"{{ restart_app == 'GivTCP' }}\" sequence: - alias: Restart GivTCP add-on action: hassio.addon_restart data: addon: 533ea71a_givtcp - conditions: - condition: template value_template: \"{{ restart_app == 'Mosquitto' }}\" sequence: - alias: Restart Mosquitto add-on action: hassio.addon_restart data: addon: core_mosquitto trace: stored_traces: 20 mode: single The last two triggers (GivTCP and Mosquitto running) trigger if any of these add-ons that Predbat is dependent upon are not running. You will need to enable a binary sensor for each add-on to be able to use these triggers in the automation: Navigate to Settings / Devices and Services / Devices and search for 'GivTCP' Click on the GivTCP add-on, and under 'Sensors', click 'XX entities not shown' Click the 'Running' sensor, then the cogwheel, and Enable the sensor Repeat these steps for the 'Mosquitto' add-on. As an extension to the above, if you don't want the automation to restart the failing add-on and instead just send an alert that there is a problem, delete the 'choose' code above. Restarting GivTCP does however lose the current GivTCP log-in Home Assistant. NB: If you are using GivTCP v2 rather than v3, replace the '533ea71a_givtcp' with 'a6a2857d_givtcp'.","title":"GivTCP activity monitor"},{"location":"output-data/#predbat-error-monitor","text":"This automation will raise an alert if Predbat's status turns to Error for more than 5 minutes. In normal operation, Predbat will automatically run and update its forecast every 5 minutes. If the automation detects that Predbat has not done this for 20 minutes, then an alert will be raised and the automation will restart the Predbat add-on to try to resolve a 'hung Predbat' issue. In the same way for the GivTCP and Mosquitto add-ons above, the last trigger requires you to enable a binary sensor that detects that the Predbat/AppDaemon add-on is running. Follow the same steps to enable the binary sensor for either the 'Predbat', 'AppDaemon' or 'AppDaemon-predbat' add-on depending on which Predbat installation method you followed. The script will need to be customised for your mobile details. alias: Predbat error monitor description: Alert when Predbat has raised an exception trace: stored_traces: 20 triggers: - trigger: template alias: Predbat status contains 'Error' for 5 minutes value_template: \"{{ 'Error' in states('predbat.status') }}\" for: minutes: 5 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat is in error status for 5 minutes entity_id: predbat.status attribute: error to: \"true\" for: minutes: 5 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat status.last_updated has not changed for 20 minutes entity_id: predbat.status attribute: last_updated for: minutes: 20 variables: alert_text: >- Predbat stalled? Restarting. last_updated=' {{ state_attr('predbat.status','last_updated')|as_timestamp|timestamp_custom('%a %H:%M') }}', unchanged for 20 mins; Status='{{ states('predbat.status') }}' restart_predbat: \"Y\" - trigger: state alias: Predbat add-on not running for 15 minutes entity_id: binary_sensor.predbat_running to: \"off\" for: minutes: 15 variables: alert_text: Predbat add-on is not running, restarting restart_predbat: \"Y\" - trigger: state alias: predbat_active stuck on for 20 minutes entity_id: - switch.predbat_active for: minutes: 20 variables: alert_text: Predbat active has been stuck on (updating the plan) for 20 minutes, restarting restart_predbat: \"Y\" actions: - action: notify.mobile_app_<your mobile device id> alias: Send alert message data: title: Predbat status issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - if: - condition: template value_template: \"{{ restart_predbat == 'Y' }}\" then: - action: hassio.addon_restart data: addon: 6adb4f0d_predbat alias: Restart Predbat add-on mode: single NB: If you are using AppDaemon rather than the Predbat add-on, replace '6adb4f0d_predbat' with 'a0d7b954_appdaemon' and change 'binary_sensor.predbat_running' to 'binary_sensor.appdaemon_running'. An error alert looks like this:","title":"Predbat error monitor"},{"location":"predbat-plan-card/","text":"Predbat Plan card Predbat can create its own plan card which can be added to your Home Assistant dashboard. At a glance, the Predbat plan shows you the plan going forward for home demand, EV charging, iBoost and your battery, and any actions that Predbat is planning to take. Displaying the Predbat plan Firstly install the HTML template card in HACS: In HACS, click on Frontend Click the blue Explore and download repositories button and type 'HTML' Click on 'HTML Jinja2 Template card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' NB: Do not install the very similarly named 'Lovelace Html card', it won't work! You must install the 'HTML Jinja2 Template card'. Next, on a Home Assistant dashboard, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following to display the Predbat plan: type: custom:html-template-card title: Predbat plan ignore_line_breaks: true content: | {{ state_attr('predbat.plan_html', 'html') }} You should see something like this: If you get an error 'Custom element doesn't exist: html-template-card' then you've not installed the Jinja2 template card correctly from HACS. Understanding the Predbat plan For every half-hour period (slot) that Predbat has planned for (the forecast_hours setting in apps.yaml ), the Predbat plan shows: The import rate in pence for that slot The export rate in pence for that slot What 'status' Predbat will be in (e.g. Charging, Discharging) Any limit applied (e.g. charging to 70%) Forecast Solar generation (from Solcast) Forecast house load (from your historical load data) Planned car charging (if car charging is configured in Predbat) Planned iBoost immersion heating (if iBoost is configured) What the battery SoC will be at the start of the 30-minute slot The forecast cost for the half-hour slot A running total cost Forecast CO2 Carbon intensity and Carbon footprint emitted by the grid's electricity generation, and the direction of travel over the slot (if carbon forecasting is enabled) Rate symbols (import and export): ? \u2146 - Rate that has been modified based on input_number.predbat_metric_future_rate_offset_import or input_number.predbat_metric_future_rate_offset_export ? \u2696 - Rate that has been estimated using future rate estimation data (e.g. Nordpool) = - Rate that has been overridden by the user's apps.yaml \u00b1 - Rate that has been adjusted with a rate offset in the user's apps.yaml $ - Rate that has been adjusted for an Octopus Saving session ? - Rate that has not yet been defined and the previous day's data was used instead Battery SoC symbols: \u2192 - Current SoC expected to remain level \u2198 - Current SoC expected to fall \u2197 - Current SoC expected to rise Cost symbols: \u2192 - Current cost expected to remain level \u2198 - Current cost expected to fall (due to export) \u2197 - Current cost expected to rise (due to import or standing charge) Explaining each column in the Predbat plan in more detail: Time - Predbat plans your home, solar and battery load in 30-minute slots, on the :00 and :30 minutes past each hour. The Predbat slots are therefore aligned to Octopus Agile slots or rate change times on any other tariff. Import - The import rate for that time slot in pence. The rate will be coloured Blue if the price is zero pence or negative, Green if the rate is less than the import rate threshold, Red if the rate is more than 1.5 times the import rate threshold, and Yellow if the rate is between 1 and 1.5 times the import rate threshold. See the Predbat customisation guide for an explanation of the import rate threshold (and overriding it), but in essence Predbat will consider blue and green-coloured slots as preferred candidates for importing, yellow and red (higher rates) will not. If battery charging is planned by Predbat for a particular slot, the import rate for that slot will be highlighted in bold text. Export - Similarly, the export rate for that time slot in pence. The rate will be coloured White if the price is less than the export rate threshold, Yellow if it is more than the export rate threshold, and pale Red if the rate is more than 1.5 times the export rate threshold. So in essence, Yellow and Red coloured export rates will be considered as priorities for exporting, and White will not. If battery discharging is planned by Predbat for a particular slot, the export rate for that slot will be highlighted in bold text. State - Predbat's status controls whether the battery is charging, discharging to support house load (Demand mode), discharging and force exported, or being held at the current level. Alongside the state is an arrow which points upwards if the battery SoC is increasing (i.e. charging), to the right if the battery SoC remains constant, or downwards if the battery SoC is decreasing (i.e. discharging). If Predbat's plan has been over-ridden and the slot has been manually controlled to be a Charging slot, Discharging or Idle, then alongside the State and battery SoC arrow will be an upside down 'F' indicating it is a 'Forced' activity. The slot will be coloured Green for Charging, Yellow for Discharging, Silver Grey for Freeze Charging, Dark Grey for Freeze Discharging, Pale Blue for Hold Charging or White for Idle. NB: The Predbat plan is shown in 30-minute time slots but Predbat actually plans battery activity in 5-minute segments within the 30-minute slot. If the Home Assistant control switch.predbat_calculate_export_oncharge is set to True, then within a 30-minute slot (and depending on import and export rates), Predbat could potentially plan for there to be both charging and discharging activity - if Predbat plans this, the state will show as both Charging and Exporting in the same slot. Limit % - Alongside any battery activity (charging, discharging, etc) there will be a SoC limit. This limit is what the SoC is planned to be at the end of the 30-minute time slot. e.g. 'Charge\u2197 70%' is charge to 70% SoC, and 'Exp\u2198 4%' is force exporting the battery to the 4% reserve level. PV kWh - The predicted solar forecast for the half-hour slot, estimated from the Solcast Forecast . If the PV forecast is above 0.2kWh for the slot it will be coloured Melon Red with a little sun symbol, above 0.1kWh it will be Yellow with a sun symbol, otherwise, it will be Silver-Grey. Load kWh - The predicted house load for the half-hour slot, estimated as a weighted average of the number of days_previous Historical data from your inverter or other house load sensor. If the load forecast is 0.5kWh or above for the slot it will be coloured Orangey-Red, from 0.25kWh to 0.5 it will be coloured Yellow, above 0 to 0.25, it will be Light Green, and if zero, it will be coloured White. Clip kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the total amount of energy predicted to be lost due to clipping either due to your inverter not being able to handle all the PV that has been generated (due to lack of AC capacity or DC charging), or due to an export limit being set. If the amount of solar clipping predicted to occur in that slot is more than 0.1kWh then the kWh will be coloured Orange, if its more than 0.01kWh it will be coloured Yellow, otherwise, it will be White. Xload kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the load that was added externally to Predbat with load_forecast settings, this might come from PredAI, PredHeat or other sources depending on your configuration. Car kWh - The total predicted car charging for the half-hour slot. This column will only be shown if num_cars in apps.yaml is 1 or more. If the car is planned to be charged in that slot then the kWh will be coloured Yellow, otherwise, it will be White. iBoost kWh - The energy planned for solar diverter immersion heating such as iBoost or MyEnergi Eddi. This column will only be shown if switch.predbat_iboost_enable is set to True. If the solar diverter is planned to be on in that slot then the kWh will be coloured Yellow, otherwise it will be White. SoC % - The estimate of battery State of Charge percentage at the start of the time slot together with an arrow pointing up, to the right or downwards to indicate whether the battery SoC is increasing, remaining constant or decreasing during the time slot. The 'SoC %' can be read in conjunction with the 'Limit %'; the SoC column gives the estimated SoC at the beginning of the slot, the Limit column the estimated SoC at the end of the slot. If the SoC is 50% or greater it will be coloured Green, 20% or greater, Yellow, and if less than 20%, Orangey-Red. Cost - The estimated cost in pence for the time slot together with an arrow indicating whether the total cost today is increasing, staying flat or decreasing. If the cost for the slot is 10p or more it will be coloured Orangey-Red, \u00bdp or more it will be coloured Yellow, -\u00bdp or less it will be coloured Green, otherwise, it will be coloured White. Total - The total cumulative cost so far for 'today' at the start of the slot, including the standing charge. At midnight tonight this cumulative cost will be reset to the daily standing charge (or zero if metric_standing_charge wasn't set in apps.yaml ). Due to the way Predbat works, the total cost is always reported (in Predbat output entities, this HTML plan, in the Apex charts , etc) as starting from midnight today and adding on from there. Looking at the sample Predbat plan above as an example, the plan starts at 10:00 with the total cost today already being \u00a33.13. The house load is then fully met through the day and evening by the battery (with some PV top-up charging) so the total cost remains constant at \u00a33.13. In the 22:30 and 23:00 slots there is a little grid import, and then at 23:30 there's grid import and the battery starts to be charged. As you can see the Total continues to increase in the plan past midnight with each Total being the Total from the preceding slot plus the Cost estimate from the preceding slot - a reminder that Total gives the running total at the start of the slot. The total cost is always coloured White. CO2 (g/kWh) - The estimated CO2 Carbon intensity emitted by the grid when generating electricity at the start of the 30-minute slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The CO2 value will be coloured according to how high the carbon footprint intensity is: greater or equal to 450g/kWh it will be deep red; greater or equal to 290, dark red; then golden orange from 200 upwards; yellow from 120; green from 40 and light green if less than 40. CO2 (kg) - The estimated CO2 Carbon footprint that the grid will emit generating electricity at the start of the slot and the direction of travel over the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The carbon amount in kg will be coloured according to the direction of travel over the slot; if the carbon value rises by 10kg or more it will be orange with an upward arrow; if falling by 10kg or more it will be green with a downwards arrow, and in the middle, white with a horizontal arrow. Debug mode for Predbat Plan If Predbat expert mode is turned on then a number of additional controls and switches are made available in Home Assistant. If switch.predbat_plan_debug is then turned on then the Predbat plan shows additional 'debugging' information for the import rate, export rate, load and PV columns, and the clip kWh column described above. The Predbat plan will now look like this with plan_debug turned on: Import and Export rates will now show the actual rate (according to how you have set up the energy rates ) and also in brackets the effective import or export rate. The effective rate takes into account battery and inverter energy losses for charging and discharging and converting from DC to AC and vice-versa. Note that the Cost and Total columns are always based on the actual Import and Export rate. Using the above debug plan as an example: At 22:30 the battery is being charged. The actual import rate is 14.07p, but after conversion losses to store the grid AC into the DC battery, the energy being put into the battery has effectively cost 14.81p - for every 1kWh of AC grid import you don't get 1kWh of DC stored in the battery, so 1kWh of battery charge has effectively cost slightly more than the import rate. At 00:30 the battery is being force exported and excess energy (above the estimated house load of 0.47kWh) will be exported. The actual export rate is 18.22p but after losses converting the stored DC battery charge into AC to supply the home and export it, the energy being exported has effectively only earned 17.31p - it will take slightly more than 1kWh of stored DC battery charge to get 1kWh of AC to use or export so each discharged and exported kWh earns slightly less. Putting these together, at 00:00, the effective import rate (after losses) is 13.93p, the effective export rate is 17.31p, so even though battery and inverter conversion losses have been incurred, there is still a 3.38p profit per kWh and Predbat plans to charge and then export the battery in the same slot to generate that profit. With debug mode turned on, the Load column shows the predicted load in kWh for the half-hour slot and in brackets the modelled load variance value using the load variance model . The PV column in debug mode changes shows the predicted PV generation in kWh for the half-hour slot and the Solcast 10% forecast in brackets. Note that Predbat's forecasted PV generation already contains a input_number.predbat_pv_metric10_weight weighted value of the Solcast 10% forecast . Note that the values in brackets in the load and PV columns are each only shown if they are non-zero. The debug mode on the Predbat plan can be quite useful to understand from the import and export rates after conversion losses , why Predbat plans to charge or force export the battery. There's a further explanation of the Predbat forecast and plan in the FAQ's. Customising and Reformatting the Predbat Plan An additional independent front-end Home Assistant component the 'Predbat Table Card' is available on HACS that gives a number of additional customisation and configuration options to tailor how the Predbat plan looks: Change the sequence of columns and which columns are shown in the plan Restyle the columns, or retain the Predbat original colour scheme Apply custom light/dark themes See the Predbat Table Card repository for more details.","title":"Predbat Plan card"},{"location":"predbat-plan-card/#predbat-plan-card","text":"Predbat can create its own plan card which can be added to your Home Assistant dashboard. At a glance, the Predbat plan shows you the plan going forward for home demand, EV charging, iBoost and your battery, and any actions that Predbat is planning to take.","title":"Predbat Plan card"},{"location":"predbat-plan-card/#displaying-the-predbat-plan","text":"Firstly install the HTML template card in HACS: In HACS, click on Frontend Click the blue Explore and download repositories button and type 'HTML' Click on 'HTML Jinja2 Template card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' NB: Do not install the very similarly named 'Lovelace Html card', it won't work! You must install the 'HTML Jinja2 Template card'. Next, on a Home Assistant dashboard, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following to display the Predbat plan: type: custom:html-template-card title: Predbat plan ignore_line_breaks: true content: | {{ state_attr('predbat.plan_html', 'html') }} You should see something like this: If you get an error 'Custom element doesn't exist: html-template-card' then you've not installed the Jinja2 template card correctly from HACS.","title":"Displaying the Predbat plan"},{"location":"predbat-plan-card/#understanding-the-predbat-plan","text":"For every half-hour period (slot) that Predbat has planned for (the forecast_hours setting in apps.yaml ), the Predbat plan shows: The import rate in pence for that slot The export rate in pence for that slot What 'status' Predbat will be in (e.g. Charging, Discharging) Any limit applied (e.g. charging to 70%) Forecast Solar generation (from Solcast) Forecast house load (from your historical load data) Planned car charging (if car charging is configured in Predbat) Planned iBoost immersion heating (if iBoost is configured) What the battery SoC will be at the start of the 30-minute slot The forecast cost for the half-hour slot A running total cost Forecast CO2 Carbon intensity and Carbon footprint emitted by the grid's electricity generation, and the direction of travel over the slot (if carbon forecasting is enabled) Rate symbols (import and export): ? \u2146 - Rate that has been modified based on input_number.predbat_metric_future_rate_offset_import or input_number.predbat_metric_future_rate_offset_export ? \u2696 - Rate that has been estimated using future rate estimation data (e.g. Nordpool) = - Rate that has been overridden by the user's apps.yaml \u00b1 - Rate that has been adjusted with a rate offset in the user's apps.yaml $ - Rate that has been adjusted for an Octopus Saving session ? - Rate that has not yet been defined and the previous day's data was used instead Battery SoC symbols: \u2192 - Current SoC expected to remain level \u2198 - Current SoC expected to fall \u2197 - Current SoC expected to rise Cost symbols: \u2192 - Current cost expected to remain level \u2198 - Current cost expected to fall (due to export) \u2197 - Current cost expected to rise (due to import or standing charge) Explaining each column in the Predbat plan in more detail: Time - Predbat plans your home, solar and battery load in 30-minute slots, on the :00 and :30 minutes past each hour. The Predbat slots are therefore aligned to Octopus Agile slots or rate change times on any other tariff. Import - The import rate for that time slot in pence. The rate will be coloured Blue if the price is zero pence or negative, Green if the rate is less than the import rate threshold, Red if the rate is more than 1.5 times the import rate threshold, and Yellow if the rate is between 1 and 1.5 times the import rate threshold. See the Predbat customisation guide for an explanation of the import rate threshold (and overriding it), but in essence Predbat will consider blue and green-coloured slots as preferred candidates for importing, yellow and red (higher rates) will not. If battery charging is planned by Predbat for a particular slot, the import rate for that slot will be highlighted in bold text. Export - Similarly, the export rate for that time slot in pence. The rate will be coloured White if the price is less than the export rate threshold, Yellow if it is more than the export rate threshold, and pale Red if the rate is more than 1.5 times the export rate threshold. So in essence, Yellow and Red coloured export rates will be considered as priorities for exporting, and White will not. If battery discharging is planned by Predbat for a particular slot, the export rate for that slot will be highlighted in bold text. State - Predbat's status controls whether the battery is charging, discharging to support house load (Demand mode), discharging and force exported, or being held at the current level. Alongside the state is an arrow which points upwards if the battery SoC is increasing (i.e. charging), to the right if the battery SoC remains constant, or downwards if the battery SoC is decreasing (i.e. discharging). If Predbat's plan has been over-ridden and the slot has been manually controlled to be a Charging slot, Discharging or Idle, then alongside the State and battery SoC arrow will be an upside down 'F' indicating it is a 'Forced' activity. The slot will be coloured Green for Charging, Yellow for Discharging, Silver Grey for Freeze Charging, Dark Grey for Freeze Discharging, Pale Blue for Hold Charging or White for Idle. NB: The Predbat plan is shown in 30-minute time slots but Predbat actually plans battery activity in 5-minute segments within the 30-minute slot. If the Home Assistant control switch.predbat_calculate_export_oncharge is set to True, then within a 30-minute slot (and depending on import and export rates), Predbat could potentially plan for there to be both charging and discharging activity - if Predbat plans this, the state will show as both Charging and Exporting in the same slot. Limit % - Alongside any battery activity (charging, discharging, etc) there will be a SoC limit. This limit is what the SoC is planned to be at the end of the 30-minute time slot. e.g. 'Charge\u2197 70%' is charge to 70% SoC, and 'Exp\u2198 4%' is force exporting the battery to the 4% reserve level. PV kWh - The predicted solar forecast for the half-hour slot, estimated from the Solcast Forecast . If the PV forecast is above 0.2kWh for the slot it will be coloured Melon Red with a little sun symbol, above 0.1kWh it will be Yellow with a sun symbol, otherwise, it will be Silver-Grey. Load kWh - The predicted house load for the half-hour slot, estimated as a weighted average of the number of days_previous Historical data from your inverter or other house load sensor. If the load forecast is 0.5kWh or above for the slot it will be coloured Orangey-Red, from 0.25kWh to 0.5 it will be coloured Yellow, above 0 to 0.25, it will be Light Green, and if zero, it will be coloured White. Clip kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the total amount of energy predicted to be lost due to clipping either due to your inverter not being able to handle all the PV that has been generated (due to lack of AC capacity or DC charging), or due to an export limit being set. If the amount of solar clipping predicted to occur in that slot is more than 0.1kWh then the kWh will be coloured Orange, if its more than 0.01kWh it will be coloured Yellow, otherwise, it will be White. Xload kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the load that was added externally to Predbat with load_forecast settings, this might come from PredAI, PredHeat or other sources depending on your configuration. Car kWh - The total predicted car charging for the half-hour slot. This column will only be shown if num_cars in apps.yaml is 1 or more. If the car is planned to be charged in that slot then the kWh will be coloured Yellow, otherwise, it will be White. iBoost kWh - The energy planned for solar diverter immersion heating such as iBoost or MyEnergi Eddi. This column will only be shown if switch.predbat_iboost_enable is set to True. If the solar diverter is planned to be on in that slot then the kWh will be coloured Yellow, otherwise it will be White. SoC % - The estimate of battery State of Charge percentage at the start of the time slot together with an arrow pointing up, to the right or downwards to indicate whether the battery SoC is increasing, remaining constant or decreasing during the time slot. The 'SoC %' can be read in conjunction with the 'Limit %'; the SoC column gives the estimated SoC at the beginning of the slot, the Limit column the estimated SoC at the end of the slot. If the SoC is 50% or greater it will be coloured Green, 20% or greater, Yellow, and if less than 20%, Orangey-Red. Cost - The estimated cost in pence for the time slot together with an arrow indicating whether the total cost today is increasing, staying flat or decreasing. If the cost for the slot is 10p or more it will be coloured Orangey-Red, \u00bdp or more it will be coloured Yellow, -\u00bdp or less it will be coloured Green, otherwise, it will be coloured White. Total - The total cumulative cost so far for 'today' at the start of the slot, including the standing charge. At midnight tonight this cumulative cost will be reset to the daily standing charge (or zero if metric_standing_charge wasn't set in apps.yaml ). Due to the way Predbat works, the total cost is always reported (in Predbat output entities, this HTML plan, in the Apex charts , etc) as starting from midnight today and adding on from there. Looking at the sample Predbat plan above as an example, the plan starts at 10:00 with the total cost today already being \u00a33.13. The house load is then fully met through the day and evening by the battery (with some PV top-up charging) so the total cost remains constant at \u00a33.13. In the 22:30 and 23:00 slots there is a little grid import, and then at 23:30 there's grid import and the battery starts to be charged. As you can see the Total continues to increase in the plan past midnight with each Total being the Total from the preceding slot plus the Cost estimate from the preceding slot - a reminder that Total gives the running total at the start of the slot. The total cost is always coloured White. CO2 (g/kWh) - The estimated CO2 Carbon intensity emitted by the grid when generating electricity at the start of the 30-minute slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The CO2 value will be coloured according to how high the carbon footprint intensity is: greater or equal to 450g/kWh it will be deep red; greater or equal to 290, dark red; then golden orange from 200 upwards; yellow from 120; green from 40 and light green if less than 40. CO2 (kg) - The estimated CO2 Carbon footprint that the grid will emit generating electricity at the start of the slot and the direction of travel over the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The carbon amount in kg will be coloured according to the direction of travel over the slot; if the carbon value rises by 10kg or more it will be orange with an upward arrow; if falling by 10kg or more it will be green with a downwards arrow, and in the middle, white with a horizontal arrow.","title":"Understanding the Predbat plan"},{"location":"predbat-plan-card/#debug-mode-for-predbat-plan","text":"If Predbat expert mode is turned on then a number of additional controls and switches are made available in Home Assistant. If switch.predbat_plan_debug is then turned on then the Predbat plan shows additional 'debugging' information for the import rate, export rate, load and PV columns, and the clip kWh column described above. The Predbat plan will now look like this with plan_debug turned on: Import and Export rates will now show the actual rate (according to how you have set up the energy rates ) and also in brackets the effective import or export rate. The effective rate takes into account battery and inverter energy losses for charging and discharging and converting from DC to AC and vice-versa. Note that the Cost and Total columns are always based on the actual Import and Export rate. Using the above debug plan as an example: At 22:30 the battery is being charged. The actual import rate is 14.07p, but after conversion losses to store the grid AC into the DC battery, the energy being put into the battery has effectively cost 14.81p - for every 1kWh of AC grid import you don't get 1kWh of DC stored in the battery, so 1kWh of battery charge has effectively cost slightly more than the import rate. At 00:30 the battery is being force exported and excess energy (above the estimated house load of 0.47kWh) will be exported. The actual export rate is 18.22p but after losses converting the stored DC battery charge into AC to supply the home and export it, the energy being exported has effectively only earned 17.31p - it will take slightly more than 1kWh of stored DC battery charge to get 1kWh of AC to use or export so each discharged and exported kWh earns slightly less. Putting these together, at 00:00, the effective import rate (after losses) is 13.93p, the effective export rate is 17.31p, so even though battery and inverter conversion losses have been incurred, there is still a 3.38p profit per kWh and Predbat plans to charge and then export the battery in the same slot to generate that profit. With debug mode turned on, the Load column shows the predicted load in kWh for the half-hour slot and in brackets the modelled load variance value using the load variance model . The PV column in debug mode changes shows the predicted PV generation in kWh for the half-hour slot and the Solcast 10% forecast in brackets. Note that Predbat's forecasted PV generation already contains a input_number.predbat_pv_metric10_weight weighted value of the Solcast 10% forecast . Note that the values in brackets in the load and PV columns are each only shown if they are non-zero. The debug mode on the Predbat plan can be quite useful to understand from the import and export rates after conversion losses , why Predbat plans to charge or force export the battery. There's a further explanation of the Predbat forecast and plan in the FAQ's.","title":"Debug mode for Predbat Plan"},{"location":"predbat-plan-card/#customising-and-reformatting-the-predbat-plan","text":"An additional independent front-end Home Assistant component the 'Predbat Table Card' is available on HACS that gives a number of additional customisation and configuration options to tailor how the Predbat plan looks: Change the sequence of columns and which columns are shown in the plan Restyle the columns, or retain the Predbat original colour scheme Apply custom light/dark themes See the Predbat Table Card repository for more details.","title":"Customising and Reformatting the Predbat Plan"},{"location":"predheat/","text":"Predheat Predheat attempts to model water-based central heating systems based on a boiler or a heat pump. Further details can be found in the Predheat YouTube video Operation The app runs every 5 minutes and it will automatically update its prediction for the heating system for the next period, up to a maximum of 48 hours. The inputs are as follows An external temperature sensor, can be a real one or one created by an Internet service An internal temperature sensor, ideally from your home thermostat. The target temperature sensor, is what your home thermostat is set to. A heating energy sensor in kWh (not strictly required but needed to plot historical usage and calibrate) The flow temperature setting of your heating, can be static or a sensor Your current energy rates, either from the Octopus Energy plugin or hand-typed into the configuration Some data about your home that you have to figure out for yourself and calibrate The outputs are: Prediction of the internal house temperature going forward, including times when the heating will be active. Your predicted energy usage and costs. The energy usage, if electric, can also be connected to Predbat to help you project your home battery usage. Future versions will also offer Predbat to run in master mode, controlling your home's heating in the same way as a smart thermostat (e.g. Nest) Installation guide Predheat is now part of Predbat, you will need to configure it using apps.yaml and then enable it by turning on switch.predbat_predheat_enable Openweather install See: https://www.home-assistant.io/integrations/openweathermap Create an OpenWeather account and then register for a \"One Call by Call\" subscription plan. This does need a credit/debit card but won't cost anything. You get 1000 API calls a day for free, so edit your limit in the account to 1000 to avoid ever being charged. Then add in the Home Assistant service and connect up your API key to obtain hourly weather data. Use the v3.0 API and ensure you have a 2024 version of Home Assistant. Apex Charts install Use HACS to install Apex Charts (Lovelace frontend add-on) - https://github.com/RomRider/apexcharts-card There is a template for the Predheat charts in: https://raw.githubusercontent.com/springfall2008/batpred/refs/heads/main/templates/example_chart_predbat.yaml_template Create a new Apex chart for each chart in this template and copy the YAML code into the chart. Configuration guide You need to edit apps.yaml to configure your system. Copy the following template into The Predbat apps.yaml and edit the settings: predheat.yaml Set the mode ( mode ) to 'gas' or 'pump' depending on if you have a gas boiler or heat pump Set the external temperature sensor ( external_temperature ) either to a real sensor or create one from the open weather map by adding this sensor to your configuration.yaml file for HA: template: - sensor: - name: \"external_temperature\" unit_of_measurement: 'c' state_class: measurement state: > {{ state_attr('weather.openweathermap', 'temperature') }} Set internal_temperature to point to one or more internal temperature sensors, if you have a heating thermostat then ideally link it to this or to a sensor at least in a similar area of the house. The weather configuration points to the Open Weather Map sensor by default so should work as-is. Set the target_temperature to point to a sensor that indicates what your boiler thermostat is set to, or manually enter the temperature setting here. Set smart_thermostat to True if your thermostat starts the boiler ahead of time for the new target temperature or False for regular options. Set heating_energy To point to a sensor that indicates the energy consumed by your boiler/heat pump in kWh. If the sensor isn't accurate then use heating_energy_scaling to adjust it to the actual energy consumed. You can also comment this line out if you don't have a sensor, but no historical cost information will be produced. Now you need to make a list of all your radiators in the house, measure them and look up their BTU output at Delta 50 and their volume in Litres. The links below may be useful for various standard radiators: https://www.bestheating.com/milano-kent-straight-chrome-heated-towel-rail-various-sizes-91119 https://www.bestheating.com/milano-compact-type-11-single-panel-radiator-multi-sizes-available-74174 https://www.bestheating.com/milano-compact-type-22-double-panel-radiator-multi-sizes-available-74176 https://www.bestheating.com/milano-compact-type-21-double-panel-plus-radiator-multi-sizes-available-74175 Add up all the BTUs and divide by 3.41 to gain the heat output in Watts and set that in heat_output configuration option. Add up all the litres of water, add in some extra for the piping and an expansion vessel if present (e.g. 5-10 litres) and set heat_volume accordingly. Set the heat_max_power and heat_min_power to the minimum and maximum power output of your boiler/heat pump in watts. This should be specified as the maximum output power and not the maximum input energy. E.g. a heat pump with a COP of 4 might output 7kW but could only consume 1.7kW. Set hysteresis To the amount of hysteresis in degrees applied by your thermostat when turning it on, the default is 0.5 Set hysteresis_off To the amount of hysteresis in degrees applied by your thermostat when turning it off, the default is 0.1 Set heating_cop to the nominal COP of your system. For a gas boiler use 1.0 (as the efficiency will be based on flow temperature) or for a heat pump set it to the best value which is likely around 4.0 (it will be scaled down for cold weather). Set flow_temp To the target flow temperature of your system, either via a sensor or as a fixed value. E.g. gas boilers are often set to say 60 or 70 degrees while heat pumps are much lower e.g. 30 or 40. Set flow_difference_target to be the difference in flow temperature (in vs out) where your heating system will run at full power if it is above. e.g. for gas boilers this maybe something around 40 while on a heat pump, it could be much lower e.g. 10. Set volume_temp If you have a sensor on your radiators which can confirm the water temperature, this must not be near the heat pump/boiler but instead as close to the interior temperature sensor as possible. If you do not have a sensor then instead PredHeat will calculate the next temperature and store it in next_volume_temp for use in the next calculation cycle. For energy rates, they will come from the Predbat configuration, ensure you have your electric or gas rates set correctly. Note you can also change the tables for gas_efficiency , heat_pump_efficiency and delta_correction in the Predheat configuration but the defaults should be fine to get going. Now comes the tricky part, we need to calculate the heat loss for your house: What will help here is historical temperature data, find a time period in the last few weeks when your heating was turned off (for a few hours beforehand) and the house is cooling down. Measure the number of degrees the house drops by in a given time period. Divide that figure (e.g. 1.5 degrees) by the time period e.g. (3 hours) and then again divide it by the average difference between the inside and outside temperature (e.g. 19 degrees inside, 9 degrees outside, so a temperature difference of 4 degrees) = 1.5 degrees / 3 hours / 10 degrees difference = 0.05. Set that figure to heat_loss_degrees . It may be best to compute this when it's cold out and if you have your heating turned off overnight. Note in future versions of Predheat I might make this calculation automatic. Next, we need to work out the number of watts of heat loss in the house, this can be done by looking at the energy consumed when the heating comes on. Pick a period of heating, ideally from the time the temperature starts increasing for a complete hour of increase, looking at the increase in temperature in degrees, add to that static heat loss which is heat_loss_degrees (internal temp - external temp) 1 hour to get the total degrees accounted for. Now divide that by the external temperature difference again / (internal_temp - external_temp) and multiply the final figure by the energy your system consumed in Watts during that period (can be found either from your sensor or just by looking at your energy bill for the same 1 hour period). The final figure should be the number of watts your house loses per 1 degree of external temperature difference and be set to heat_loss_watts Then you can set heat_gain_static to be the static heat output of other things in your house eg. computers and people. You can figure this out by looking at how many degrees of temperature difference your house can maintain without any heating and multiply up your heat loss watts figure by this. Weather Compensation If your heat source makes use of weather compensation then add the following to the configuration to map out your heat curve. The example has a flow temp of 45C at -3C outside and 25C at 15C outside: weather_compensation: -20: 45.0 -3: 45.0 15: 25.0 20: 25.0 Predheat will fill in the gaps between the points provided.","title":"Predheat"},{"location":"predheat/#predheat","text":"Predheat attempts to model water-based central heating systems based on a boiler or a heat pump. Further details can be found in the Predheat YouTube video","title":"Predheat"},{"location":"predheat/#operation","text":"The app runs every 5 minutes and it will automatically update its prediction for the heating system for the next period, up to a maximum of 48 hours. The inputs are as follows An external temperature sensor, can be a real one or one created by an Internet service An internal temperature sensor, ideally from your home thermostat. The target temperature sensor, is what your home thermostat is set to. A heating energy sensor in kWh (not strictly required but needed to plot historical usage and calibrate) The flow temperature setting of your heating, can be static or a sensor Your current energy rates, either from the Octopus Energy plugin or hand-typed into the configuration Some data about your home that you have to figure out for yourself and calibrate The outputs are: Prediction of the internal house temperature going forward, including times when the heating will be active. Your predicted energy usage and costs. The energy usage, if electric, can also be connected to Predbat to help you project your home battery usage. Future versions will also offer Predbat to run in master mode, controlling your home's heating in the same way as a smart thermostat (e.g. Nest)","title":"Operation"},{"location":"predheat/#installation-guide","text":"Predheat is now part of Predbat, you will need to configure it using apps.yaml and then enable it by turning on switch.predbat_predheat_enable","title":"Installation guide"},{"location":"predheat/#openweather-install","text":"See: https://www.home-assistant.io/integrations/openweathermap Create an OpenWeather account and then register for a \"One Call by Call\" subscription plan. This does need a credit/debit card but won't cost anything. You get 1000 API calls a day for free, so edit your limit in the account to 1000 to avoid ever being charged. Then add in the Home Assistant service and connect up your API key to obtain hourly weather data. Use the v3.0 API and ensure you have a 2024 version of Home Assistant.","title":"Openweather install"},{"location":"predheat/#apex-charts-install","text":"Use HACS to install Apex Charts (Lovelace frontend add-on) - https://github.com/RomRider/apexcharts-card There is a template for the Predheat charts in: https://raw.githubusercontent.com/springfall2008/batpred/refs/heads/main/templates/example_chart_predbat.yaml_template Create a new Apex chart for each chart in this template and copy the YAML code into the chart.","title":"Apex Charts install"},{"location":"predheat/#configuration-guide","text":"You need to edit apps.yaml to configure your system. Copy the following template into The Predbat apps.yaml and edit the settings: predheat.yaml Set the mode ( mode ) to 'gas' or 'pump' depending on if you have a gas boiler or heat pump Set the external temperature sensor ( external_temperature ) either to a real sensor or create one from the open weather map by adding this sensor to your configuration.yaml file for HA: template: - sensor: - name: \"external_temperature\" unit_of_measurement: 'c' state_class: measurement state: > {{ state_attr('weather.openweathermap', 'temperature') }} Set internal_temperature to point to one or more internal temperature sensors, if you have a heating thermostat then ideally link it to this or to a sensor at least in a similar area of the house. The weather configuration points to the Open Weather Map sensor by default so should work as-is. Set the target_temperature to point to a sensor that indicates what your boiler thermostat is set to, or manually enter the temperature setting here. Set smart_thermostat to True if your thermostat starts the boiler ahead of time for the new target temperature or False for regular options. Set heating_energy To point to a sensor that indicates the energy consumed by your boiler/heat pump in kWh. If the sensor isn't accurate then use heating_energy_scaling to adjust it to the actual energy consumed. You can also comment this line out if you don't have a sensor, but no historical cost information will be produced. Now you need to make a list of all your radiators in the house, measure them and look up their BTU output at Delta 50 and their volume in Litres. The links below may be useful for various standard radiators: https://www.bestheating.com/milano-kent-straight-chrome-heated-towel-rail-various-sizes-91119 https://www.bestheating.com/milano-compact-type-11-single-panel-radiator-multi-sizes-available-74174 https://www.bestheating.com/milano-compact-type-22-double-panel-radiator-multi-sizes-available-74176 https://www.bestheating.com/milano-compact-type-21-double-panel-plus-radiator-multi-sizes-available-74175 Add up all the BTUs and divide by 3.41 to gain the heat output in Watts and set that in heat_output configuration option. Add up all the litres of water, add in some extra for the piping and an expansion vessel if present (e.g. 5-10 litres) and set heat_volume accordingly. Set the heat_max_power and heat_min_power to the minimum and maximum power output of your boiler/heat pump in watts. This should be specified as the maximum output power and not the maximum input energy. E.g. a heat pump with a COP of 4 might output 7kW but could only consume 1.7kW. Set hysteresis To the amount of hysteresis in degrees applied by your thermostat when turning it on, the default is 0.5 Set hysteresis_off To the amount of hysteresis in degrees applied by your thermostat when turning it off, the default is 0.1 Set heating_cop to the nominal COP of your system. For a gas boiler use 1.0 (as the efficiency will be based on flow temperature) or for a heat pump set it to the best value which is likely around 4.0 (it will be scaled down for cold weather). Set flow_temp To the target flow temperature of your system, either via a sensor or as a fixed value. E.g. gas boilers are often set to say 60 or 70 degrees while heat pumps are much lower e.g. 30 or 40. Set flow_difference_target to be the difference in flow temperature (in vs out) where your heating system will run at full power if it is above. e.g. for gas boilers this maybe something around 40 while on a heat pump, it could be much lower e.g. 10. Set volume_temp If you have a sensor on your radiators which can confirm the water temperature, this must not be near the heat pump/boiler but instead as close to the interior temperature sensor as possible. If you do not have a sensor then instead PredHeat will calculate the next temperature and store it in next_volume_temp for use in the next calculation cycle. For energy rates, they will come from the Predbat configuration, ensure you have your electric or gas rates set correctly. Note you can also change the tables for gas_efficiency , heat_pump_efficiency and delta_correction in the Predheat configuration but the defaults should be fine to get going. Now comes the tricky part, we need to calculate the heat loss for your house: What will help here is historical temperature data, find a time period in the last few weeks when your heating was turned off (for a few hours beforehand) and the house is cooling down. Measure the number of degrees the house drops by in a given time period. Divide that figure (e.g. 1.5 degrees) by the time period e.g. (3 hours) and then again divide it by the average difference between the inside and outside temperature (e.g. 19 degrees inside, 9 degrees outside, so a temperature difference of 4 degrees) = 1.5 degrees / 3 hours / 10 degrees difference = 0.05. Set that figure to heat_loss_degrees . It may be best to compute this when it's cold out and if you have your heating turned off overnight. Note in future versions of Predheat I might make this calculation automatic. Next, we need to work out the number of watts of heat loss in the house, this can be done by looking at the energy consumed when the heating comes on. Pick a period of heating, ideally from the time the temperature starts increasing for a complete hour of increase, looking at the increase in temperature in degrees, add to that static heat loss which is heat_loss_degrees (internal temp - external temp) 1 hour to get the total degrees accounted for. Now divide that by the external temperature difference again / (internal_temp - external_temp) and multiply the final figure by the energy your system consumed in Watts during that period (can be found either from your sensor or just by looking at your energy bill for the same 1 hour period). The final figure should be the number of watts your house loses per 1 degree of external temperature difference and be set to heat_loss_watts Then you can set heat_gain_static to be the static heat output of other things in your house eg. computers and people. You can figure this out by looking at how many degrees of temperature difference your house can maintain without any heating and multiply up your heat loss watts figure by this.","title":"Configuration guide"},{"location":"predheat/#weather-compensation","text":"If your heat source makes use of weather compensation then add the following to the configuration to map out your heat curve. The example has a flow temp of 45C at -3C outside and 25C at 15C outside: weather_compensation: -20: 45.0 -3: 45.0 15: 25.0 20: 25.0 Predheat will fill in the gaps between the points provided.","title":"Weather Compensation"},{"location":"rest_api/","text":"Predbat REST API Predbat supports a REST API operated via its Web Interface, this is normally intended for use when Predbat runs in a Docker or Standalone rather than in Home Assistant /api/state - Method GET entity_id -> The entity to get, if not specified all entities are returned Example: /api/state?entity_id=predbat.status { \"state\": \"Demand\", \"attributes\": {\"friendly_name\": \"Status\", \"detail\": \"\", \"icon\": \"mdi:information\", \"last_updated\": \"2025-02-23 20:49:57.855074\"} } /api/state - Method POST Sets the state of an entity, this is done by changing its value without calling the service API, this means Predbat will not notice the change Not normally recommended You must post in 'json' as follows { \"entity_id\": \"predbat.status\", \"state\": \"Hello\", \"attributes\": {\"friendly_name\" : \"Fire\"} } /api/service - Method POST This is the recommended way to change a Predbat value, it will either make the change via home assistant or directly via Predbat if not connected. You must post in 'json' with the service name and the service data, as per Home Assistant services: { \"service\": \"switch/turn_on\", \"data\": {\"entity_id\": \"switch.predbat_expert_mode\"} }","title":"Predbat REST API"},{"location":"rest_api/#predbat-rest-api","text":"Predbat supports a REST API operated via its Web Interface, this is normally intended for use when Predbat runs in a Docker or Standalone rather than in Home Assistant","title":"Predbat REST API"},{"location":"rest_api/#apistate-method-get","text":"entity_id -> The entity to get, if not specified all entities are returned Example: /api/state?entity_id=predbat.status { \"state\": \"Demand\", \"attributes\": {\"friendly_name\": \"Status\", \"detail\": \"\", \"icon\": \"mdi:information\", \"last_updated\": \"2025-02-23 20:49:57.855074\"} }","title":"/api/state - Method GET"},{"location":"rest_api/#apistate-method-post","text":"Sets the state of an entity, this is done by changing its value without calling the service API, this means Predbat will not notice the change Not normally recommended You must post in 'json' as follows { \"entity_id\": \"predbat.status\", \"state\": \"Hello\", \"attributes\": {\"friendly_name\" : \"Fire\"} }","title":"/api/state - Method POST"},{"location":"rest_api/#apiservice-method-post","text":"This is the recommended way to change a Predbat value, it will either make the change via home assistant or directly via Predbat if not connected. You must post in 'json' with the service name and the service data, as per Home Assistant services: { \"service\": \"switch/turn_on\", \"data\": {\"entity_id\": \"switch.predbat_expert_mode\"} }","title":"/api/service - Method POST"},{"location":"todo-list/","text":"To-do list See GitHub issues","title":"To-do list"},{"location":"todo-list/#to-do-list","text":"See GitHub issues","title":"To-do list"},{"location":"video-guides/","text":"Video Guides All the video guides are now available on my YouTube channel: Springfall2008 Basic installation Playlist of Predbat installation videos Setting Up Home Assistant Basics, File Editor, SSH, HACS, Octopus, eWelink Installing MQTT and GivTCP on Home Assistant Predbat installation - Predbat, Solcast, Dashboard, Charts and Plans - Add On Method Configuration of apps.yaml Configuration of Predbat inside Home Assistant Understanding historical data Understanding the charts How to understand Predbat plans AppDaemon log files Documentation overview Other configuration videos Playlist of other Predbat configuration videos Multiple cars How to Tune your system for better performance Issues with Solcast free accounts and Home Assistant How to Install Predbat with the new Add On Features Playlist of Predbat feature videos Intelligent Octopus car charging Saving sessions and power-ups How to update Predbat Predbat mode and read-only mode Creating a dashboard Saving and restoring settings Manual plan override Charging curve and low power charging Controlling my car based on Predbat Slot Manual plan overrides for force charge/discharge/idle GivTCP auto restart feature GivEnergy Inverter Pause, Manual Freeze Charge/Discharge Optimising for Carbon Footprint Calculating your cost savings Comparing Energy Tariffs Introduction to Predheat Energy Tariffs Playlist of Tariff configuration videos Intelligent Octopus import + Agile export Intelligent Octopus import + Fixed export Octopus Agile import + Agile export Octopus Flux","title":"Video Guides"},{"location":"video-guides/#video-guides","text":"All the video guides are now available on my YouTube channel: Springfall2008","title":"Video Guides"},{"location":"video-guides/#basic-installation","text":"Playlist of Predbat installation videos Setting Up Home Assistant Basics, File Editor, SSH, HACS, Octopus, eWelink Installing MQTT and GivTCP on Home Assistant Predbat installation - Predbat, Solcast, Dashboard, Charts and Plans - Add On Method Configuration of apps.yaml Configuration of Predbat inside Home Assistant Understanding historical data Understanding the charts How to understand Predbat plans AppDaemon log files Documentation overview","title":"Basic installation"},{"location":"video-guides/#other-configuration-videos","text":"Playlist of other Predbat configuration videos Multiple cars How to Tune your system for better performance Issues with Solcast free accounts and Home Assistant How to Install Predbat with the new Add On","title":"Other configuration videos"},{"location":"video-guides/#features","text":"Playlist of Predbat feature videos Intelligent Octopus car charging Saving sessions and power-ups How to update Predbat Predbat mode and read-only mode Creating a dashboard Saving and restoring settings Manual plan override Charging curve and low power charging Controlling my car based on Predbat Slot Manual plan overrides for force charge/discharge/idle GivTCP auto restart feature GivEnergy Inverter Pause, Manual Freeze Charge/Discharge Optimising for Carbon Footprint Calculating your cost savings Comparing Energy Tariffs Introduction to Predheat","title":"Features"},{"location":"video-guides/#energy-tariffs","text":"Playlist of Tariff configuration videos Intelligent Octopus import + Agile export Intelligent Octopus import + Fixed export Octopus Agile import + Agile export Octopus Flux","title":"Energy Tariffs"},{"location":"web-interface/","text":"Web Interface The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles. Accessing the Web Interface If you are running the Predbat add-on then the Predbat Web Interface can be accessed by clicking 'Open Web UI' on the add-on screen (arrowed): You can also turn on the 'Show in sidebar' option (circled) to have direct access to the web interface from the Home Assistant side bar. Another option is to include a link on your dashboard using an entities card: - type: entities entities: - type: weblink name: Predbat web interface url: /hassio/ingress/6adb4f0d_predbat icon: mdi:bat If you are not using the Predbat Add-on then you may be able to access the Web Interface directly on port 5052 (e.g. with a Docker Container or native on your Linux/MAC). The port number can be changed by setting web_port in apps.yaml . NOTE: The Predbat web interface will not work with the AppDaemon or the Predbat-appdaemon installation methods. Web Interface Views A number of different views of Predbat are available and you can change your view using the top menu bar. Dash View The initial view is the Dash view which gives a summary of Predbat's status and mode, some easy-to-access debug options (see below), a text summary of Predbat's plan, and then all the output entities that Predbat creates. The Debug panel provides easy access to a number of files that are useful in diagnosing a problem and are usually required if you raise a Predbat Github issue : Download apps.yaml - provides a link to download your apps.yaml file . This is useful to identify issues with your Predbat configuration Create predbat_debug.yaml - turns Predbat's debug mode on and creates a Predbat debug file which contains your entire Predbat Home Assistant configuration; all the input settings for Predbat and all Predbat's output data including the current HTML plan, the best_* entities, etc. This debug file enables your setup to be recreated to identify any configuration issues it may have or Predbat bugs to be re-created. Confidential information such as your Solcast API or GECloud API are redacted in the debug file. Download predbat.log - provides a link to download the current Predbat logfile which contains progress and any error messages that occur whilst Predbat is running Download predbat_plan.html - provides a link to download the current Predbat HTML plan Note that before you can attach a downloaded apps.yaml or predbat_debug.yaml file to a Github issue you must rename the file extension, e.g. to '.txt', so for example apps.txt and predbat_debug.txt . This is because Github does not accept .yaml file attachments. Underneath the Debug panel is the Plan textual description panel which gives a brief summary of current battery level, forthcoming import rates, solar generation, planned charging, discharging and export activity. Below this is the Predbat Entities panel which details all the other Predbat output entities, their current state and attributes. Any entity name can be clicked to swap to the Entities view for that entity. Plan View This view provides an easy way to see what Predbat is planning for your battery/inverter. It displays the current Predbat plan in 30 minute segments showing import and export rates, Predbat's planned state for the battery (charging, discharging, etc), predicted solar generation, predicted house load, car charging, cost, etc. You can also create the Predbat Plan card to show this plan on your own custom dashboard. Entities View This view enables you to look at the history of any predbat output entity or (input) configuration setting. Select the entity required to be viewed, the time period of history to view the entity over (but note you may need to increase HA's purge_keep_days first). Predbat will then display the current value of the entity, a chart of its history and then a list of prior historical values: Charts View The Charts view provides an easy way of viewing a number of pre-created Predbat charts: Battery - Shows the historic Battery SoC for today and the predicted SoC for the plan duration under the Base/Base10/Best and Best10 scenarios (see explanation of these terms . The chart also shows where charging is planned under the Base and Best scenarios and forced Export under the Best scenario Power - Shows predicted Power for the plan duration. This includes battery charge and discharge, solar generation (PV), house load, iBoost load, car charging load, and grid import/export Cost - Shows the historic import, export and net total cost incurred for today and the predicted cost for the plan duration under the Base/Base10/Best and Best10 scenarios Rates - Shows historic and future import and export rates along with historic hourly and today pence per kWh so you can see where you have earned or spent the most on electricity during today InDay - Shows Predbat's predicted house load for today, the actual house load that has occurred so far today, and then Predbat's adjusted house load prediction based on the variance of today's actual load to predicted load PV - Shows today's predicted solar generation under the PV, PV10 and PV90 scenarios alongside today's actual solar generation PV7 - Similar to the PV chart but shows actual solar generation and forecast for the last 7 days including today Example PV chart: Config View The Config view provides a way to see and change all of Predbat's configuration entities in Home Assistant. For each entity is displayed the name, entity type, the current entity value and Predbat's default value for that entity. Any entities that are coloured pale red simply denote entities where you have changed the value from Predbat's default value - it does not indicate that the entity value is in error, its just that its different from the default value. Any entity name can be clicked to swap to the Entities view for that entity. You can also create a custom dashboard to see and update Predbat's control entities ; and full explanation of Predbat's control entities and what they do can be found in the customisation documentation . apps.yaml View Predbat validates your apps.yaml and if there are any configuration issues it displays a count of those errors and highlights the items in error in red: Further details of the apps.yaml error can be found in the Predbat Log Log View Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so the Log view provides an easy way to see and download the Predbat logfile. By default the Log view opens in the Warnings tab which shows a filtered list of Warnings and Errors in the Predbat logfile. The Errors tab shows a filtered list of logfile Errors, and the All tab shows all entries in the Predbat logfile. Normal log messages are coloured Green, Warnings are Orange, and Errors in Red. The Logfile view shows newest entries at the top and auto-refreshes so as Predbat is executing the most recent logs will appear at the top and the log will scroll downwards. The Download tab gives the ability to download the logfile. Further details about the Predbat logfile and its location is described in the output data document . Compare View The Compare View provides access to Predbat's Compare Energy Tariff feature which enables you compare what it would cost you (or you'd gain from export) on different energy tariffs with your predicted load and solar generation. Docs View Provides a quick link to the Predbat documentation . Toggle Dark Mode As it says, toggles the Predbat web interface between light and dark mode.","title":"Web Interface"},{"location":"web-interface/#web-interface","text":"The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles.","title":"Web Interface"},{"location":"web-interface/#accessing-the-web-interface","text":"If you are running the Predbat add-on then the Predbat Web Interface can be accessed by clicking 'Open Web UI' on the add-on screen (arrowed): You can also turn on the 'Show in sidebar' option (circled) to have direct access to the web interface from the Home Assistant side bar. Another option is to include a link on your dashboard using an entities card: - type: entities entities: - type: weblink name: Predbat web interface url: /hassio/ingress/6adb4f0d_predbat icon: mdi:bat If you are not using the Predbat Add-on then you may be able to access the Web Interface directly on port 5052 (e.g. with a Docker Container or native on your Linux/MAC). The port number can be changed by setting web_port in apps.yaml . NOTE: The Predbat web interface will not work with the AppDaemon or the Predbat-appdaemon installation methods.","title":"Accessing the Web Interface"},{"location":"web-interface/#web-interface-views","text":"A number of different views of Predbat are available and you can change your view using the top menu bar.","title":"Web Interface Views"},{"location":"web-interface/#dash-view","text":"The initial view is the Dash view which gives a summary of Predbat's status and mode, some easy-to-access debug options (see below), a text summary of Predbat's plan, and then all the output entities that Predbat creates. The Debug panel provides easy access to a number of files that are useful in diagnosing a problem and are usually required if you raise a Predbat Github issue : Download apps.yaml - provides a link to download your apps.yaml file . This is useful to identify issues with your Predbat configuration Create predbat_debug.yaml - turns Predbat's debug mode on and creates a Predbat debug file which contains your entire Predbat Home Assistant configuration; all the input settings for Predbat and all Predbat's output data including the current HTML plan, the best_* entities, etc. This debug file enables your setup to be recreated to identify any configuration issues it may have or Predbat bugs to be re-created. Confidential information such as your Solcast API or GECloud API are redacted in the debug file. Download predbat.log - provides a link to download the current Predbat logfile which contains progress and any error messages that occur whilst Predbat is running Download predbat_plan.html - provides a link to download the current Predbat HTML plan Note that before you can attach a downloaded apps.yaml or predbat_debug.yaml file to a Github issue you must rename the file extension, e.g. to '.txt', so for example apps.txt and predbat_debug.txt . This is because Github does not accept .yaml file attachments. Underneath the Debug panel is the Plan textual description panel which gives a brief summary of current battery level, forthcoming import rates, solar generation, planned charging, discharging and export activity. Below this is the Predbat Entities panel which details all the other Predbat output entities, their current state and attributes. Any entity name can be clicked to swap to the Entities view for that entity.","title":"Dash View"},{"location":"web-interface/#plan-view","text":"This view provides an easy way to see what Predbat is planning for your battery/inverter. It displays the current Predbat plan in 30 minute segments showing import and export rates, Predbat's planned state for the battery (charging, discharging, etc), predicted solar generation, predicted house load, car charging, cost, etc. You can also create the Predbat Plan card to show this plan on your own custom dashboard.","title":"Plan View"},{"location":"web-interface/#entities-view","text":"This view enables you to look at the history of any predbat output entity or (input) configuration setting. Select the entity required to be viewed, the time period of history to view the entity over (but note you may need to increase HA's purge_keep_days first). Predbat will then display the current value of the entity, a chart of its history and then a list of prior historical values:","title":"Entities View"},{"location":"web-interface/#charts-view","text":"The Charts view provides an easy way of viewing a number of pre-created Predbat charts: Battery - Shows the historic Battery SoC for today and the predicted SoC for the plan duration under the Base/Base10/Best and Best10 scenarios (see explanation of these terms . The chart also shows where charging is planned under the Base and Best scenarios and forced Export under the Best scenario Power - Shows predicted Power for the plan duration. This includes battery charge and discharge, solar generation (PV), house load, iBoost load, car charging load, and grid import/export Cost - Shows the historic import, export and net total cost incurred for today and the predicted cost for the plan duration under the Base/Base10/Best and Best10 scenarios Rates - Shows historic and future import and export rates along with historic hourly and today pence per kWh so you can see where you have earned or spent the most on electricity during today InDay - Shows Predbat's predicted house load for today, the actual house load that has occurred so far today, and then Predbat's adjusted house load prediction based on the variance of today's actual load to predicted load PV - Shows today's predicted solar generation under the PV, PV10 and PV90 scenarios alongside today's actual solar generation PV7 - Similar to the PV chart but shows actual solar generation and forecast for the last 7 days including today Example PV chart:","title":"Charts View"},{"location":"web-interface/#config-view","text":"The Config view provides a way to see and change all of Predbat's configuration entities in Home Assistant. For each entity is displayed the name, entity type, the current entity value and Predbat's default value for that entity. Any entities that are coloured pale red simply denote entities where you have changed the value from Predbat's default value - it does not indicate that the entity value is in error, its just that its different from the default value. Any entity name can be clicked to swap to the Entities view for that entity. You can also create a custom dashboard to see and update Predbat's control entities ; and full explanation of Predbat's control entities and what they do can be found in the customisation documentation .","title":"Config View"},{"location":"web-interface/#appsyaml-view","text":"Predbat validates your apps.yaml and if there are any configuration issues it displays a count of those errors and highlights the items in error in red: Further details of the apps.yaml error can be found in the Predbat Log","title":"apps.yaml View"},{"location":"web-interface/#log-view","text":"Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so the Log view provides an easy way to see and download the Predbat logfile. By default the Log view opens in the Warnings tab which shows a filtered list of Warnings and Errors in the Predbat logfile. The Errors tab shows a filtered list of logfile Errors, and the All tab shows all entries in the Predbat logfile. Normal log messages are coloured Green, Warnings are Orange, and Errors in Red. The Logfile view shows newest entries at the top and auto-refreshes so as Predbat is executing the most recent logs will appear at the top and the log will scroll downwards. The Download tab gives the ability to download the logfile. Further details about the Predbat logfile and its location is described in the output data document .","title":"Log View"},{"location":"web-interface/#compare-view","text":"The Compare View provides access to Predbat's Compare Energy Tariff feature which enables you compare what it would cost you (or you'd gain from export) on different energy tariffs with your predicted load and solar generation.","title":"Compare View"},{"location":"web-interface/#docs-view","text":"Provides a quick link to the Predbat documentation .","title":"Docs View"},{"location":"web-interface/#toggle-dark-mode","text":"As it says, toggles the Predbat web interface between light and dark mode.","title":"Toggle Dark Mode"},{"location":"what-does-predbat-do/","text":"What does Predbat do? Predbat is a home battery automation program. It automatically runs every 5 minutes and will update its prediction for the home battery levels for the next period, up to a maximum of 48 hours ahead. Predbat will automatically decide when to charge and discharge your battery to achieve the best (lowest) cost spend within the parameters you have set. It uses the solar production forecast from Solcast combined with your historical energy usage to make this prediction. The output is a prediction of the battery levels, solar generation, house load, charging activity, discharging activity, costs and import and export amounts based on 30-minute slots. Costs are based on energy pricing data, either manually configured (e.g. 7p from 11pm-4pm and 35p otherwise) or by using the Octopus Energy integration Both import and export rates are supported. Intelligent Octopus is also supported and takes into account allocated charging slots. The solar forecast used is the central scenario from Solcast (50%) with a configurable weighting towards the more pessimistic (10%) scenario. Predbat automatically programs your inverter with the appropriate charging and discharging controls. Both Hybrid inverters and AC-coupled inverters are supported by Predbat. Automatic planning of export slots is also supported, when enabled Predbat can start a forced discharge of the battery if the export rates are high and you have spare capacity. Historical load data is used to predict your consumption, optionally car charging load can be filtered out of this data. Predbat can be configured to manage the charging of your EV or to use a Solar Diverter, and take into account these loads on the house during these periods. Multiple inverter support is included but depends on all inverters running in lockstep. Terminology Basic terminology SoC - State of Charge - the % or kWh level of charge of your battery Target SoC - The target level that the battery is being charged to, e.g. we target 100% SoC means the battery is being charged to full Charge Limit - Another word for Target SoC Load - The energy your home is using to power your equipment e.g. oven, lights or electric car charging Grid - Your electric supply outside the house Import - Electricity drawn from the grid to be used in the home or to charge the battery Export - Electricity from your home from the battery or solar which is sent to the grid Demand - Demand Mode is when the battery covers the house load and charges from solar, to avoid importing or exporting (some systems call this ECO Mode). Charging - When your battery is charging, in Predbat this refers to force charge (from the grid). Discharge - The opposite of charge, when the battery is discharging. Exporting - When your battery is force discharging to create an export, in Predbat this refers to force export. Export Limit - When your battery is being force exported the export limit is the % battery level where the discharge will stop if reached. PV - Solar power that is generated in your home. Can also refer to a prediction of the solar for the day, by default is the 50% scenario (most likely generation). Inverter - The box that converts DC energy from solar or your battery into AC power for your home and the grid. The inverter also converts AC power from the grid into DC to charge a battery. Hybrid inverter - An inverter that can charge a battery from solar directly using DC power as well as charging it from AC power from the grid AC Coupled - A battery that comes with its own inverter and is always charged or discharged with AC (using an internal inverter) Micro Inverters - Small inverters that are fitted in line with the DC solar panels and produce AC power on a per-panel basis. Typically used with an AC-coupled battery. Slot - A period of time where Predbat acts e.g. charging. In Predbat everything is a multiple of 5 minutes Charge slots are always in multiples of 30 minutes and align to a 30-minute boundary to match the way energy rates are allocated Discharge slots can be any multiple of 5 minutes and always finish on a 30-minute boundary. Loss - Refers to energy lost in your system due to heat or other factors. PV10 - A prediction of the 10% scenario for solar, this is like a worst case, occurs 1 in 10 days PV90 - A prediction of the 90% scenario for solar, this is like a best case, occurs 1 in 10 days Base - Usually refers to the expected outcome if Predbat takes no further action, meaning just what is currently configured on your inverter. Best - The best plan that Predbat could come up with, as in what it will do (assuming Read-only is off) Actual - Used to refer to what has already happened in the past. Base10 - The base scenario but with the 10% outcome for Solar and Load (worst case) Charge Limit Base - This is the target charge % in the Base plan (what is currently set on your inverter) Best10 - The best plan but with the 10% outcome for Solar and Load (worst case) Charge Limit Best - This is the target charge % in the Best plan (what is currently set on your inverter) Export Limit Best - This is the target to force export to in % in the Best plan. Best SOC Keep - The amount of battery you want to keep in the plan that Predbat has made Predbat modes When you first install Predbat it will be in 'Monitor' mode. You can configure Predbat's mode of operation using the drop-down menu in select.predbat_mode . You will find a full description of Predbat Modes in the Customisation Guide. Once you are ready for Predbat to take control move this setting to one of the active control modes. Predbat status The current Predbat status is reported in the Home Assistant entity predbat.status : Demand - This is the default, the load will be covered by solar and/or battery. Excess solar will charge the battery or be exported if the battery is full. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. Charging - The battery charges from the grid and the grid also covers any load. Solar power will also be used to charge the battery. Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar power above the house load, the excess solar will be used to charge the battery, Hold charging - A type of charge where the target SoC % is the same as the current SoC %, effectively the same as a charge freeze (but without being explicitly selected). No Charge - A charge where the target SoC % is lower than the current battery SoC level so there will be no charging unless the usage is unexpectedly high. Exporting - The battery is being force-discharged. The house load will be covered by the battery and any excess is exported to the grid. Any solar generated will be exported. Freeze exporting - The battery is in demand mode, but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. Hold exporting - The plan was to force export but the minimum battery level was reached and thus the battery is kept in Demand mode. If the battery level again gets above the threshold it will be changed back to Export mode. Calibration - The inverter is calibrating the batteries. On GivEnergy systems the battery state of charge (SoC) level has to be calibrated by performing a full battery discharge and then a full charge so that the voltage levels associated with empty and full SoC can be determined. Predbat will pause executing the plan until the calibration automatically finishes - see Calibration FAQ . Error - If there is a configuration error or other problem, you should check the Predbat log file for more details.","title":"What does Predbat do?"},{"location":"what-does-predbat-do/#what-does-predbat-do","text":"Predbat is a home battery automation program. It automatically runs every 5 minutes and will update its prediction for the home battery levels for the next period, up to a maximum of 48 hours ahead. Predbat will automatically decide when to charge and discharge your battery to achieve the best (lowest) cost spend within the parameters you have set. It uses the solar production forecast from Solcast combined with your historical energy usage to make this prediction. The output is a prediction of the battery levels, solar generation, house load, charging activity, discharging activity, costs and import and export amounts based on 30-minute slots. Costs are based on energy pricing data, either manually configured (e.g. 7p from 11pm-4pm and 35p otherwise) or by using the Octopus Energy integration Both import and export rates are supported. Intelligent Octopus is also supported and takes into account allocated charging slots. The solar forecast used is the central scenario from Solcast (50%) with a configurable weighting towards the more pessimistic (10%) scenario. Predbat automatically programs your inverter with the appropriate charging and discharging controls. Both Hybrid inverters and AC-coupled inverters are supported by Predbat. Automatic planning of export slots is also supported, when enabled Predbat can start a forced discharge of the battery if the export rates are high and you have spare capacity. Historical load data is used to predict your consumption, optionally car charging load can be filtered out of this data. Predbat can be configured to manage the charging of your EV or to use a Solar Diverter, and take into account these loads on the house during these periods. Multiple inverter support is included but depends on all inverters running in lockstep.","title":"What does Predbat do?"},{"location":"what-does-predbat-do/#terminology","text":"","title":"Terminology"},{"location":"what-does-predbat-do/#basic-terminology","text":"SoC - State of Charge - the % or kWh level of charge of your battery Target SoC - The target level that the battery is being charged to, e.g. we target 100% SoC means the battery is being charged to full Charge Limit - Another word for Target SoC Load - The energy your home is using to power your equipment e.g. oven, lights or electric car charging Grid - Your electric supply outside the house Import - Electricity drawn from the grid to be used in the home or to charge the battery Export - Electricity from your home from the battery or solar which is sent to the grid Demand - Demand Mode is when the battery covers the house load and charges from solar, to avoid importing or exporting (some systems call this ECO Mode). Charging - When your battery is charging, in Predbat this refers to force charge (from the grid). Discharge - The opposite of charge, when the battery is discharging. Exporting - When your battery is force discharging to create an export, in Predbat this refers to force export. Export Limit - When your battery is being force exported the export limit is the % battery level where the discharge will stop if reached. PV - Solar power that is generated in your home. Can also refer to a prediction of the solar for the day, by default is the 50% scenario (most likely generation). Inverter - The box that converts DC energy from solar or your battery into AC power for your home and the grid. The inverter also converts AC power from the grid into DC to charge a battery. Hybrid inverter - An inverter that can charge a battery from solar directly using DC power as well as charging it from AC power from the grid AC Coupled - A battery that comes with its own inverter and is always charged or discharged with AC (using an internal inverter) Micro Inverters - Small inverters that are fitted in line with the DC solar panels and produce AC power on a per-panel basis. Typically used with an AC-coupled battery. Slot - A period of time where Predbat acts e.g. charging. In Predbat everything is a multiple of 5 minutes Charge slots are always in multiples of 30 minutes and align to a 30-minute boundary to match the way energy rates are allocated Discharge slots can be any multiple of 5 minutes and always finish on a 30-minute boundary. Loss - Refers to energy lost in your system due to heat or other factors. PV10 - A prediction of the 10% scenario for solar, this is like a worst case, occurs 1 in 10 days PV90 - A prediction of the 90% scenario for solar, this is like a best case, occurs 1 in 10 days Base - Usually refers to the expected outcome if Predbat takes no further action, meaning just what is currently configured on your inverter. Best - The best plan that Predbat could come up with, as in what it will do (assuming Read-only is off) Actual - Used to refer to what has already happened in the past. Base10 - The base scenario but with the 10% outcome for Solar and Load (worst case) Charge Limit Base - This is the target charge % in the Base plan (what is currently set on your inverter) Best10 - The best plan but with the 10% outcome for Solar and Load (worst case) Charge Limit Best - This is the target charge % in the Best plan (what is currently set on your inverter) Export Limit Best - This is the target to force export to in % in the Best plan. Best SOC Keep - The amount of battery you want to keep in the plan that Predbat has made","title":"Basic terminology"},{"location":"what-does-predbat-do/#predbat-modes","text":"When you first install Predbat it will be in 'Monitor' mode. You can configure Predbat's mode of operation using the drop-down menu in select.predbat_mode . You will find a full description of Predbat Modes in the Customisation Guide. Once you are ready for Predbat to take control move this setting to one of the active control modes.","title":"Predbat modes"},{"location":"what-does-predbat-do/#predbat-status","text":"The current Predbat status is reported in the Home Assistant entity predbat.status : Demand - This is the default, the load will be covered by solar and/or battery. Excess solar will charge the battery or be exported if the battery is full. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. Charging - The battery charges from the grid and the grid also covers any load. Solar power will also be used to charge the battery. Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar power above the house load, the excess solar will be used to charge the battery, Hold charging - A type of charge where the target SoC % is the same as the current SoC %, effectively the same as a charge freeze (but without being explicitly selected). No Charge - A charge where the target SoC % is lower than the current battery SoC level so there will be no charging unless the usage is unexpectedly high. Exporting - The battery is being force-discharged. The house load will be covered by the battery and any excess is exported to the grid. Any solar generated will be exported. Freeze exporting - The battery is in demand mode, but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. Hold exporting - The plan was to force export but the minimum battery level was reached and thus the battery is kept in Demand mode. If the battery level again gets above the threshold it will be changed back to Export mode. Calibration - The inverter is calibrating the batteries. On GivEnergy systems the battery state of charge (SoC) level has to be calibrated by performing a full battery discharge and then a full charge so that the voltage levels associated with empty and full SoC can be determined. Predbat will pause executing the plan until the calibration automatically finishes - see Calibration FAQ . Error - If there is a configuration error or other problem, you should check the Predbat log file for more details.","title":"Predbat status"}]}